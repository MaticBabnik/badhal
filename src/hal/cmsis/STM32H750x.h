/*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 * 
 * SPDX-License-Identifier: Apache-2.0
 * 
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file     test/STM32H750x.h
 * @brief    CMSIS HeaderFile
 * @version  1.7
 * @date     05. May 2024
 * @note     Generated by SVDConv V3.3.42 on Sunday, 05.05.2024 03:15:35
 *           from File 'STM32H750X.svd',
 */



/** @addtogroup 
  * @{
  */


/** @addtogroup STM32H750x
  * @{
  */


#ifndef STM32H750X_H
#define STM32H750X_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M7 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* =========================================  STM32H750x Specific Interrupt Numbers  ========================================= */
  WWDG1_IRQn                =   0,              /*!< 0  Window Watchdog interrupt                                              */
  PVD_PVM_IRQn              =   1,              /*!< 1  PVD through EXTI line                                                  */
  RTC_TAMP_STAMP_CSS_LSE_IRQn=   2,             /*!< 2  RTC tamper, timestamp                                                  */
  RTC_WKUP_IRQn             =   3,              /*!< 3  RTC Wakeup interrupt                                                   */
  FLASH_IRQn                =   4,              /*!< 4  Flash memory                                                           */
  RCC_IRQn                  =   5,              /*!< 5  RCC global interrupt                                                   */
  EXTI0_IRQn                =   6,              /*!< 6  EXTI Line 0 interrupt                                                  */
  EXTI1_IRQn                =   7,              /*!< 7  EXTI Line 1 interrupt                                                  */
  EXTI2_IRQn                =   8,              /*!< 8  EXTI Line 2 interrupt                                                  */
  EXTI3_IRQn                =   9,              /*!< 9  EXTI Line 3interrupt                                                   */
  EXTI4_IRQn                =  10,              /*!< 10 EXTI Line 4interrupt                                                   */
  DMA_STR0_IRQn             =  11,              /*!< 11 DMA1 Stream0                                                           */
  DMA_STR1_IRQn             =  12,              /*!< 12 DMA1 Stream1                                                           */
  DMA_STR2_IRQn             =  13,              /*!< 13 DMA1 Stream2                                                           */
  DMA_STR3_IRQn             =  14,              /*!< 14 DMA1 Stream3                                                           */
  DMA_STR4_IRQn             =  15,              /*!< 15 DMA1 Stream4                                                           */
  DMA_STR5_IRQn             =  16,              /*!< 16 DMA1 Stream5                                                           */
  DMA_STR6_IRQn             =  17,              /*!< 17 DMA1 Stream6                                                           */
  ADC1_2_IRQn               =  18,              /*!< 18 ADC1 and ADC2                                                          */
  FDCAN1_IT0_IRQn           =  19,              /*!< 19 FDCAN1 Interrupt 0                                                     */
  FDCAN2_IT0_IRQn           =  20,              /*!< 20 FDCAN2 Interrupt 0                                                     */
  FDCAN1_IT1_IRQn           =  21,              /*!< 21 FDCAN1 Interrupt 1                                                     */
  FDCAN2_IT1_IRQn           =  22,              /*!< 22 FDCAN2 Interrupt 1                                                     */
  EXTI9_5_IRQn              =  23,              /*!< 23 EXTI Line[9:5] interrupts                                              */
  TIM1_BRK_IRQn             =  24,              /*!< 24 TIM1 break interrupt                                                   */
  TIM1_UP_IRQn              =  25,              /*!< 25 TIM1 update interrupt                                                  */
  TIM1_TRG_COM_IRQn         =  26,              /*!< 26 TIM1 trigger and commutation                                           */
  TIM_CC_IRQn               =  27,              /*!< 27 TIM1 capture / compare                                                 */
  TIM2_IRQn                 =  28,              /*!< 28 TIM2 global interrupt                                                  */
  TIM3_IRQn                 =  29,              /*!< 29 TIM3 global interrupt                                                  */
  TIM4_IRQn                 =  30,              /*!< 30 TIM4 global interrupt                                                  */
  I2C1_EV_IRQn              =  31,              /*!< 31 I2C1 event interrupt                                                   */
  I2C1_ER_IRQn              =  32,              /*!< 32 I2C1 error interrupt                                                   */
  I2C2_EV_IRQn              =  33,              /*!< 33 I2C2 event interrupt                                                   */
  I2C2_ER_IRQn              =  34,              /*!< 34 I2C2 error interrupt                                                   */
  SPI1_IRQn                 =  35,              /*!< 35 SPI1 global interrupt                                                  */
  SPI2_IRQn                 =  36,              /*!< 36 SPI2 global interrupt                                                  */
  USART1_IRQn               =  37,              /*!< 37 USART1 global interrupt                                                */
  USART2_IRQn               =  38,              /*!< 38 USART2 global interrupt                                                */
  USART3_IRQn               =  39,              /*!< 39 USART3 global interrupt                                                */
  EXTI15_10_IRQn            =  40,              /*!< 40 EXTI Line[15:10] interrupts                                            */
  RTC_ALARM_IRQn            =  41,              /*!< 41 RTC alarms (A and B)                                                   */
  TIM8_BRK_TIM12_IRQn       =  43,              /*!< 43 TIM8 and 12 break global                                               */
  TIM8_UP_TIM13_IRQn        =  44,              /*!< 44 TIM8 and 13 update global                                              */
  TIM8_TRG_COM_TIM14_IRQn   =  45,              /*!< 45 TIM8 and 14 trigger /commutation and global                            */
  TIM8_CC_IRQn              =  46,              /*!< 46 TIM8 capture / compare                                                 */
  DMA1_STR7_IRQn            =  47,              /*!< 47 DMA1 Stream7                                                           */
  FMC_IRQn                  =  48,              /*!< 48 FMC global interrupt                                                   */
  SDMMC1_IRQn               =  49,              /*!< 49 SDMMC global interrupt                                                 */
  TIM5_IRQn                 =  50,              /*!< 50 TIM5 global interrupt                                                  */
  SPI3_IRQn                 =  51,              /*!< 51 SPI3 global interrupt                                                  */
  UART4_IRQn                =  52,              /*!< 52 UART4 global interrupt                                                 */
  UART5_IRQn                =  53,              /*!< 53 UART5 global interrupt                                                 */
  TIM6_DAC_IRQn             =  54,              /*!< 54 TIM6 global interrupt                                                  */
  TIM7_IRQn                 =  55,              /*!< 55 TIM7 global interrupt                                                  */
  DMA2_STR0_IRQn            =  56,              /*!< 56 DMA2 Stream0 interrupt                                                 */
  DMA2_STR1_IRQn            =  57,              /*!< 57 DMA2 Stream1 interrupt                                                 */
  DMA2_STR2_IRQn            =  58,              /*!< 58 DMA2 Stream2 interrupt                                                 */
  DMA2_STR3_IRQn            =  59,              /*!< 59 DMA2 Stream3 interrupt                                                 */
  DMA2_STR4_IRQn            =  60,              /*!< 60 DMA2 Stream4 interrupt                                                 */
  ETH_IRQn                  =  61,              /*!< 61 Ethernet global interrupt                                              */
  ETH_WKUP_IRQn             =  62,              /*!< 62 Ethernet wakeup through EXTI                                           */
  DMA2_STR5_IRQn            =  68,              /*!< 68 DMA2 Stream5 interrupt                                                 */
  DMA2_STR6_IRQn            =  69,              /*!< 69 DMA2 Stream6 interrupt                                                 */
  DMA2_STR7_IRQn            =  70,              /*!< 70 DMA2 Stream7 interrupt                                                 */
  USART6_IRQn               =  71,              /*!< 71 USART6 global interrupt                                                */
  I2C3_EV_IRQn              =  72,              /*!< 72 I2C3 event interrupt                                                   */
  I2C3_ER_IRQn              =  73,              /*!< 73 I2C3 error interrupt                                                   */
  OTG_HS_EP1_OUT_IRQn       =  74,              /*!< 74 OTG_HS out global interrupt                                            */
  OTG_HS_EP1_IN_IRQn        =  75,              /*!< 75 OTG_HS in global interrupt                                             */
  OTG_HS_WKUP_IRQn          =  76,              /*!< 76 OTG_HS wakeup interrupt                                                */
  OTG_HS_IRQn               =  77,              /*!< 77 OTG_HS global interrupt                                                */
  DCMI_IRQn                 =  78,              /*!< 78 DCMI global interrupt                                                  */
  CRYP_IRQn                 =  79,              /*!< 79 CRYP global interrupt                                                  */
  HASH_RNG_IRQn             =  80,              /*!< 80 HASH and RNG                                                           */
  FPU_IRQn                  =  81,              /*!< 81 Floating point unit interrupt                                          */
  UART7_IRQn                =  82,              /*!< 82 UART7 global interrupt                                                 */
  UART8_IRQn                =  83,              /*!< 83 UART8 global interrupt                                                 */
  SPI4_IRQn                 =  84,              /*!< 84 SPI4 global interrupt                                                  */
  SPI5_IRQn                 =  85,              /*!< 85 SPI5 global interrupt                                                  */
  SPI6_IRQn                 =  86,              /*!< 86 SPI6 global interrupt                                                  */
  SAI1_IRQn                 =  87,              /*!< 87 SAI1 global interrupt                                                  */
  LTDC_IRQn                 =  88,              /*!< 88 LCD-TFT global interrupt                                               */
  LTDC_ER_IRQn              =  89,              /*!< 89 LCD-TFT error interrupt                                                */
  DMA2D_IRQn                =  90,              /*!< 90 DMA2D global interrupt                                                 */
  SAI2_IRQn                 =  91,              /*!< 91 SAI2 global interrupt                                                  */
  QUADSPI_IRQn              =  92,              /*!< 92 QuadSPI global interrupt                                               */
  LPTIM1_IRQn               =  93,              /*!< 93 LPTIM1 global interrupt                                                */
  CEC_IRQn                  =  94,              /*!< 94 HDMI-CEC global interrupt                                              */
  I2C4_EV_IRQn              =  95,              /*!< 95 I2C4 event interrupt                                                   */
  I2C4_ER_IRQn              =  96,              /*!< 96 I2C4 error interrupt                                                   */
  SPDIF_IRQn                =  97,              /*!< 97 SPDIFRX global interrupt                                               */
  OTG_FS_EP1_OUT_IRQn       =  98,              /*!< 98 OTG_FS out global interrupt                                            */
  OTG_FS_EP1_IN_IRQn        =  99,              /*!< 99 OTG_FS in global interrupt                                             */
  OTG_FS_WKUP_IRQn          = 100,              /*!< 100  OTG_FS wakeup                                                        */
  OTG_FS_IRQn               = 101,              /*!< 101  OTG_FS global interrupt                                              */
  DMAMUX1_OV_IRQn           = 102,              /*!< 102  DMAMUX1 overrun interrupt                                            */
  HRTIM1_MST_IRQn           = 103,              /*!< 103  HRTIM1 master timer interrupt                                        */
  HRTIM1_TIMA_IRQn          = 104,              /*!< 104  HRTIM1 timer A interrupt                                             */
  HRTIM_TIMB_IRQn           = 105,              /*!< 105  HRTIM1 timer B interrupt                                             */
  HRTIM1_TIMC_IRQn          = 106,              /*!< 106  HRTIM1 timer C interrupt                                             */
  HRTIM1_TIMD_IRQn          = 107,              /*!< 107  HRTIM1 timer D interrupt                                             */
  HRTIM_TIME_IRQn           = 108,              /*!< 108  HRTIM1 timer E interrupt                                             */
  HRTIM1_FLT_IRQn           = 109,              /*!< 109  HRTIM1 fault interrupt                                               */
  DFSDM1_FLT0_IRQn          = 110,              /*!< 110  DFSDM1 filter 0 interrupt                                            */
  DFSDM1_FLT1_IRQn          = 111,              /*!< 111  DFSDM1 filter 1 interrupt                                            */
  DFSDM1_FLT2_IRQn          = 112,              /*!< 112  DFSDM1 filter 2 interrupt                                            */
  DFSDM1_FLT3_IRQn          = 113,              /*!< 113  DFSDM1 filter 3 interrupt                                            */
  SAI3_IRQn                 = 114,              /*!< 114  SAI3 global interrupt                                                */
  SWPMI1_IRQn               = 115,              /*!< 115  SWPMI global interrupt                                               */
  TIM15_IRQn                = 116,              /*!< 116  TIM15 global interrupt                                               */
  TIM16_IRQn                = 117,              /*!< 117  TIM16 global interrupt                                               */
  TIM17_IRQn                = 118,              /*!< 118  TIM17 global interrupt                                               */
  MDIOS_WKUP_IRQn           = 119,              /*!< 119  MDIOS wakeup                                                         */
  MDIOS_IRQn                = 120,              /*!< 120  MDIOS global interrupt                                               */
  JPEG_IRQn                 = 121,              /*!< 121  JPEG global interrupt                                                */
  MDMA_IRQn                 = 122,              /*!< 122  MDMA                                                                 */
  SDMMC_IRQn                = 124,              /*!< 124  SDMMC global interrupt                                               */
  HSEM0_IRQn                = 125,              /*!< 125  HSEM global interrupt 1                                              */
  ADC3_IRQn                 = 127,              /*!< 127  ADC3 global interrupt                                                */
  DMAMUX2_OVR_IRQn          = 128,              /*!< 128  DMAMUX2 overrun interrupt                                            */
  BDMA_CH1_IRQn             = 129,              /*!< 129  BDMA channel 1 interrupt                                             */
  BDMA_CH2_IRQn             = 130,              /*!< 130  BDMA channel 2 interrupt                                             */
  BDMA_CH3_IRQn             = 131,              /*!< 131  BDMA channel 3 interrupt                                             */
  BDMA_CH4_IRQn             = 132,              /*!< 132  BDMA channel 4 interrupt                                             */
  BDMA_CH5_IRQn             = 133,              /*!< 133  BDMA channel 5 interrupt                                             */
  BDMA_CH6_IRQn             = 134,              /*!< 134  BDMA channel 6 interrupt                                             */
  BDMA_CH7_IRQn             = 135,              /*!< 135  BDMA channel 7 interrupt                                             */
  BDMA_CH8_IRQn             = 136,              /*!< 136  BDMA channel 8 interrupt                                             */
  COMP_IRQn                 = 137,              /*!< 137  COMP1 and COMP2                                                      */
  LPTIM2_IRQn               = 138,              /*!< 138  LPTIM2 timer interrupt                                               */
  LPTIM3_IRQn               = 139,              /*!< 139  LPTIM2 timer interrupt                                               */
  LPTIM4_IRQn               = 140,              /*!< 140  LPTIM2 timer interrupt                                               */
  LPTIM5_IRQn               = 141,              /*!< 141  LPTIM2 timer interrupt                                               */
  LPUART_IRQn               = 142,              /*!< 142  LPUART global interrupt                                              */
  WWDG1_RST_IRQn            = 143,              /*!< 143  Window Watchdog interrupt                                            */
  CRS_IRQn                  = 144,              /*!< 144  Clock Recovery System globa                                          */
  SAI4_IRQn                 = 146,              /*!< 146  SAI4 global interrupt                                                */
  WKUP_IRQn                 = 149               /*!< 149  WKUP1 to WKUP6 pins                                                  */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M7 Processor and Core Peripherals  =========================== */
#define __CM7_REV                 0x0001U       /*!< CM7 Core Revision                                                         */
#define __NVIC_PRIO_BITS               4        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  1        /*!< FPU present                                                               */
#define __FPU_DP                       0        /*!< Double Precision FPU                                                      */
#define __ICACHE_PRESENT               0        /*!< Instruction Cache present                                                 */
#define __DCACHE_PRESENT               0        /*!< Data Cache present                                                        */
#define __ITCM_PRESENT                 0        /*!< Instruction TCM present                                                   */
#define __DTCM_PRESENT                 0        /*!< Data TCM present                                                          */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm7.h"                           /*!< ARM Cortex-M7 processor and core peripherals                              */
// #include "system_STM32H750x.h"                  /*!< STM32H750x System                                                         */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           COMP1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief COMP1 (COMP1)
  */

typedef struct {                                /*!< (@ 0x58003800) COMP1 Structure                                            */
  
  union {
    __IM  uint32_t COMP1_SR;                    /*!< (@ 0x00000000) Comparator status register                                 */
    
    struct {
      __IM  uint32_t C1VAL      : 1;            /*!< [0..0] COMP channel 1 output status bit                                   */
      __IM  uint32_t C2VAL      : 1;            /*!< [1..1] COMP channel 2 output status bit                                   */
            uint32_t            : 14;
      __IM  uint32_t C1IF       : 1;            /*!< [16..16] COMP channel 1 Interrupt Flag                                    */
      __IM  uint32_t C2IF       : 1;            /*!< [17..17] COMP channel 2 Interrupt Flag                                    */
            uint32_t            : 14;
    } COMP1_SR_b;
  } ;
  
  union {
    __OM  uint32_t COMP1_ICFR;                  /*!< (@ 0x00000004) Comparator interrupt clear flag register                   */
    
    struct {
            uint32_t            : 16;
      __OM  uint32_t CC1IF      : 1;            /*!< [16..16] Clear COMP channel 1 Interrupt Flag                              */
      __OM  uint32_t CC2IF      : 1;            /*!< [17..17] Clear COMP channel 2 Interrupt Flag                              */
            uint32_t            : 14;
    } COMP1_ICFR_b;
  } ;
  
  union {
    __IOM uint32_t COMP1_OR;                    /*!< (@ 0x00000008) Comparator option register                                 */
    
    struct {
      __IOM uint32_t AFOP       : 11;           /*!< [10..0] Selection of source for alternate function of output
                                                     ports                                                                     */
      __IOM uint32_t OR         : 21;           /*!< [31..11] Option Register                                                  */
    } COMP1_OR_b;
  } ;
  
  union {
    __IOM uint32_t COMP1_CFGR1;                 /*!< (@ 0x0000000C) Comparator configuration register 1                        */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] COMP channel 1 enable bit                                          */
      __IOM uint32_t BRGEN      : 1;            /*!< [1..1] Scaler bridge enable                                               */
      __IOM uint32_t SCALEN     : 1;            /*!< [2..2] Voltage scaler enable bit                                          */
      __IOM uint32_t POLARITY   : 1;            /*!< [3..3] COMP channel 1 polarity selection bit                              */
            uint32_t            : 2;
      __IOM uint32_t ITEN       : 1;            /*!< [6..6] COMP channel 1 interrupt enable                                    */
            uint32_t            : 1;
      __IOM uint32_t HYST       : 2;            /*!< [9..8] COMP channel 1 hysteresis selection bits                           */
            uint32_t            : 2;
      __IOM uint32_t PWRMODE    : 2;            /*!< [13..12] Power Mode of the COMP channel 1                                 */
            uint32_t            : 2;
      __IOM uint32_t INMSEL     : 3;            /*!< [18..16] COMP channel 1 inverting input selection field                   */
            uint32_t            : 1;
      __IOM uint32_t INPSEL     : 1;            /*!< [20..20] COMP channel 1 non-inverting input selection bit                 */
            uint32_t            : 3;
      __IOM uint32_t BLANKING   : 4;            /*!< [27..24] COMP channel 1 blanking source selection bits                    */
            uint32_t            : 3;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock bit                                                         */
    } COMP1_CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t COMP1_CFGR2;                 /*!< (@ 0x00000010) Comparator configuration register 2                        */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] COMP channel 1 enable bit                                          */
      __IOM uint32_t BRGEN      : 1;            /*!< [1..1] Scaler bridge enable                                               */
      __IOM uint32_t SCALEN     : 1;            /*!< [2..2] Voltage scaler enable bit                                          */
      __IOM uint32_t POLARITY   : 1;            /*!< [3..3] COMP channel 1 polarity selection bit                              */
      __IOM uint32_t WINMODE    : 1;            /*!< [4..4] Window comparator mode selection bit                               */
            uint32_t            : 1;
      __IOM uint32_t ITEN       : 1;            /*!< [6..6] COMP channel 1 interrupt enable                                    */
            uint32_t            : 1;
      __IOM uint32_t HYST       : 2;            /*!< [9..8] COMP channel 1 hysteresis selection bits                           */
            uint32_t            : 2;
      __IOM uint32_t PWRMODE    : 2;            /*!< [13..12] Power Mode of the COMP channel 1                                 */
            uint32_t            : 2;
      __IOM uint32_t INMSEL     : 3;            /*!< [18..16] COMP channel 1 inverting input selection field                   */
            uint32_t            : 1;
      __IOM uint32_t INPSEL     : 1;            /*!< [20..20] COMP channel 1 non-inverting input selection bit                 */
            uint32_t            : 3;
      __IOM uint32_t BLANKING   : 4;            /*!< [27..24] COMP channel 1 blanking source selection bits                    */
            uint32_t            : 3;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock bit                                                         */
    } COMP1_CFGR2_b;
  } ;
} COMP1_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            CRS                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief CRS (CRS)
  */

typedef struct {                                /*!< (@ 0x40008400) CRS Structure                                              */
  
  union {
    __IOM uint32_t CRS_CR;                      /*!< (@ 0x00000000) CRS control register                                       */
    
    struct {
      __IOM uint32_t SYNCOKIE   : 1;            /*!< [0..0] SYNC event OK interrupt enable                                     */
      __IOM uint32_t SYNCWARNIE : 1;            /*!< [1..1] SYNC warning interrupt enable                                      */
      __IOM uint32_t ERRIE      : 1;            /*!< [2..2] Synchronization or trimming error interrupt enable                 */
      __IOM uint32_t ESYNCIE    : 1;            /*!< [3..3] Expected SYNC interrupt enable                                     */
            uint32_t            : 1;
      __IOM uint32_t CEN        : 1;            /*!< [5..5] Frequency error counter enable This bit enables the oscillator
                                                     clock for the frequency error counter. When this bit is
                                                     set, the CRS_CFGR register is write-protected and cannot
                                                     be modified.                                                              */
      __IOM uint32_t AUTOTRIMEN : 1;            /*!< [6..6] Automatic trimming enable This bit enables the automatic
                                                     hardware adjustment of TRIM bits according to the measured
                                                     frequency error between two SYNC events. If this bit is
                                                     set, the TRIM bits are read-only. The TRIM value can be
                                                     adjusted by hardware by one or two steps at a time, depending
                                                     on the measured frequency error value. Refer to Section7.3.4:
                                                     Frequency error evaluation and automati                                   */
      __IM  uint32_t SWSYNC     : 1;            /*!< [7..7] Generate software SYNC event This bit is set by software
                                                     in order to generate a software SYNC event. It is automatically
                                                     cleared by hardware.                                                      */
      __IOM uint32_t TRIM       : 6;            /*!< [13..8] HSI48 oscillator smooth trimming These bits provide
                                                     a user-programmable trimming value to the HSI48 oscillator.
                                                     They can be programmed to adjust to variations in voltage
                                                     and temperature that influence the frequency of the HSI48.
                                                     The default value is 32, which corresponds to the middle
                                                     of the trimming interval. The trimming step is around 67
                                                     kHz between two consecutive TRIM steps. A higher TRIM                     */
            uint32_t            : 18;
    } CRS_CR_b;
  } ;
  
  union {
    __IOM uint32_t CRS_CFGR;                    /*!< (@ 0x00000004) This register can be written only when the frequency
                                                                    error counter is disabled (CEN bit is cleared
                                                                    in CRS_CR). When the counter is enabled,
                                                                    this register is write-protected.                          */
    
    struct {
      __IOM uint32_t RELOAD     : 16;           /*!< [15..0] Counter reload value RELOAD is the value to be loaded
                                                     in the frequency error counter with each SYNC event. Refer
                                                     to Section7.3.3: Frequency error measurement for more details
                                                     about counter behavior.                                                   */
      __IOM uint32_t FELIM      : 8;            /*!< [23..16] Frequency error limit FELIM contains the value to be
                                                     used to evaluate the captured frequency error value latched
                                                     in the FECAP[15:0] bits of the CRS_ISR register. Refer
                                                     to Section7.3.4: Frequency error evaluation and automatic
                                                     trimming for more details about FECAP evaluation.                         */
      __IOM uint32_t SYNCDIV    : 3;            /*!< [26..24] SYNC divider These bits are set and cleared by software
                                                     to control the division factor of the SYNC signal.                        */
            uint32_t            : 1;
      __IOM uint32_t SYNCSRC    : 2;            /*!< [29..28] SYNC signal source selection These bits are set and
                                                     cleared by software to select the SYNC signal source. Note:
                                                     When using USB LPM (Link Power Management) and the device
                                                     is in Sleep mode, the periodic USB SOF will not be generated
                                                     by the host. No SYNC signal will therefore be provided
                                                     to the CRS to calibrate the HSI48 on the run. To guarantee
                                                     the required clock precision after waking up from Sleep
                                                                                                                               */
            uint32_t            : 1;
      __IOM uint32_t SYNCPOL    : 1;            /*!< [31..31] SYNC polarity selection This bit is set and cleared
                                                     by software to select the input polarity for the SYNC signal
                                                     source.                                                                   */
    } CRS_CFGR_b;
  } ;
  
  union {
    __IM  uint32_t CRS_ISR;                     /*!< (@ 0x00000008) CRS interrupt and status register                          */
    
    struct {
      __IM  uint32_t SYNCOKF    : 1;            /*!< [0..0] SYNC event OK flag This flag is set by hardware when
                                                     the measured frequency error is smaller than FELIM * 3.
                                                     This means that either no adjustment of the TRIM value
                                                     is needed or that an adjustment by one trimming step is
                                                     enough to compensate the frequency error. An interrupt
                                                     is generated if the SYNCOKIE bit is set in the CRS_CR register.
                                                     It is cleared by software by setting the SYNCOKC bit in
                                                     the                                                                       */
      __IM  uint32_t SYNCWARNF  : 1;            /*!< [1..1] SYNC warning flag This flag is set by hardware when the
                                                     measured frequency error is greater than or equal to FELIM
                                                     * 3, but smaller than FELIM * 128. This means that to compensate
                                                     the frequency error, the TRIM value must be adjusted by
                                                     two steps or more. An interrupt is generated if the SYNCWARNIE
                                                     bit is set in the CRS_CR register. It is cleared by software
                                                     by setting the SYNCWARNC bit in the CRS_ICR                               */
      __IM  uint32_t ERRF       : 1;            /*!< [2..2] Error flag This flag is set by hardware in case of any
                                                     synchronization or trimming error. It is the logical OR
                                                     of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt
                                                     is generated if the ERRIE bit is set in the CRS_CR register.
                                                     It is cleared by software in reaction to setting the ERRC
                                                     bit in the CRS_ICR register, which clears the TRIMOVF,
                                                     SYNCMISS and SYNCERR bits.                                                */
      __IM  uint32_t ESYNCF     : 1;            /*!< [3..3] Expected SYNC flag This flag is set by hardware when
                                                     the frequency error counter reached a zero value. An interrupt
                                                     is generated if the ESYNCIE bit is set in the CRS_CR register.
                                                     It is cleared by software by setting the ESYNCC bit in
                                                     the CRS_ICR register.                                                     */
            uint32_t            : 4;
      __IM  uint32_t SYNCERR    : 1;            /*!< [8..8] SYNC error This flag is set by hardware when the SYNC
                                                     pulse arrives before the ESYNC event and the measured frequency
                                                     error is greater than or equal to FELIM * 128. This means
                                                     that the frequency error is too big (internal frequency
                                                     too low) to be compensated by adjusting the TRIM value,
                                                     and that some other action should be taken. An interrupt
                                                     is generated if the ERRIE bit is set in the CRS_CR                        */
      __IM  uint32_t SYNCMISS   : 1;            /*!< [9..9] SYNC missed This flag is set by hardware when the frequency
                                                     error counter reached value FELIM * 128 and no SYNC was
                                                     detected, meaning either that a SYNC pulse was missed or
                                                     that the frequency error is too big (internal frequency
                                                     too high) to be compensated by adjusting the TRIM value,
                                                     and that some other action should be taken. At this point,
                                                     the frequency error counter is stopped (waiting for a                     */
      __IM  uint32_t TRIMOVF    : 1;            /*!< [10..10] Trimming overflow or underflow This flag is set by
                                                     hardware when the automatic trimming tries to over- or
                                                     under-flow the TRIM value. An interrupt is generated if
                                                     the ERRIE bit is set in the CRS_CR register. It is cleared
                                                     by software by setting the ERRC bit in the CRS_ICR register.              */
            uint32_t            : 4;
      __IM  uint32_t FEDIR      : 1;            /*!< [15..15] Frequency error direction FEDIR is the counting direction
                                                     of the frequency error counter latched in the time of the
                                                     last SYNC event. It shows whether the actual frequency
                                                     is below or above the target.                                             */
      __IM  uint32_t FECAP      : 16;           /*!< [31..16] Frequency error capture FECAP is the frequency error
                                                     counter value latched in the time of the last SYNC event.
                                                     Refer to Section7.3.4: Frequency error evaluation and automatic
                                                     trimming for more details about FECAP usage.                              */
    } CRS_ISR_b;
  } ;
  
  union {
    __IOM uint32_t CRS_ICR;                     /*!< (@ 0x0000000C) CRS interrupt flag clear register                          */
    
    struct {
      __IOM uint32_t SYNCOKC    : 1;            /*!< [0..0] SYNC event OK clear flag Writing 1 to this bit clears
                                                     the SYNCOKF flag in the CRS_ISR register.                                 */
      __IOM uint32_t SYNCWARNC  : 1;            /*!< [1..1] SYNC warning clear flag Writing 1 to this bit clears
                                                     the SYNCWARNF flag in the CRS_ISR register.                               */
      __IOM uint32_t ERRC       : 1;            /*!< [2..2] Error clear flag Writing 1 to this bit clears TRIMOVF,
                                                     SYNCMISS and SYNCERR bits and consequently also the ERRF
                                                     flag in the CRS_ISR register.                                             */
      __IOM uint32_t ESYNCC     : 1;            /*!< [3..3] Expected SYNC clear flag Writing 1 to this bit clears
                                                     the ESYNCF flag in the CRS_ISR register.                                  */
            uint32_t            : 28;
    } CRS_ICR_b;
  } ;
} CRS_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            DAC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DAC (DAC)
  */

typedef struct {                                /*!< (@ 0x40007400) DAC Structure                                              */
  
  union {
    __IOM uint32_t DAC_CR;                      /*!< (@ 0x00000000) DAC control register                                       */
    
    struct {
      __IOM uint32_t EN1        : 1;            /*!< [0..0] DAC channel1 enable This bit is set and cleared by software
                                                     to enable/disable DAC channel1.                                           */
      __IOM uint32_t TEN1       : 1;            /*!< [1..1] DAC channel1 trigger enable                                        */
      __IOM uint32_t TSEL1      : 3;            /*!< [4..2] DAC channel1 trigger selection These bits select the
                                                     external event used to trigger DAC channel1. Note: Only
                                                     used if bit TEN1 = 1 (DAC channel1 trigger enabled).                      */
            uint32_t            : 1;
      __IOM uint32_t WAVE1      : 2;            /*!< [7..6] DAC channel1 noise/triangle wave generation enable These
                                                     bits are set and cleared by software. Note: Only used if
                                                     bit TEN1 = 1 (DAC channel1 trigger enabled).                              */
      __IOM uint32_t MAMP1      : 4;            /*!< [11..8] DAC channel1 mask/amplitude selector These bits are
                                                     written by software to select mask in wave generation mode
                                                     or amplitude in triangle generation mode. = 1011: Unmask
                                                     bits[11:0] of LFSR/ triangle amplitude equal to 4095                      */
      __IOM uint32_t DMAEN1     : 1;            /*!< [12..12] DAC channel1 DMA enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DMAUDRIE1  : 1;            /*!< [13..13] DAC channel1 DMA Underrun Interrupt enable This bit
                                                     is set and cleared by software.                                           */
      __IOM uint32_t CEN1       : 1;            /*!< [14..14] DAC Channel 1 calibration enable This bit is set and
                                                     cleared by software to enable/disable DAC channel 1 calibration,
                                                     it can be written only if bit EN1=0 into DAC_CR (the calibration
                                                     mode can be entered/exit only when the DAC channel is disabled)
                                                     Otherwise, the write operation is ignored.                                */
            uint32_t            : 1;
      __IOM uint32_t EN2        : 1;            /*!< [16..16] DAC channel2 enable This bit is set and cleared by
                                                     software to enable/disable DAC channel2.                                  */
      __IOM uint32_t TEN2       : 1;            /*!< [17..17] DAC channel2 trigger enable                                      */
      __IOM uint32_t TSEL2      : 3;            /*!< [20..18] DAC channel2 trigger selection These bits select the
                                                     external event used to trigger DAC channel2 Note: Only
                                                     used if bit TEN2 = 1 (DAC channel2 trigger enabled).                      */
            uint32_t            : 1;
      __IOM uint32_t WAVE2      : 2;            /*!< [23..22] DAC channel2 noise/triangle wave generation enable
                                                     These bits are set/reset by software. 1x: Triangle wave
                                                     generation enabled Note: Only used if bit TEN2 = 1 (DAC
                                                     channel2 trigger enabled)                                                 */
      __IOM uint32_t MAMP2      : 4;            /*!< [27..24] DAC channel2 mask/amplitude selector These bits are
                                                     written by software to select mask in wave generation mode
                                                     or amplitude in triangle generation mode. = 1011: Unmask
                                                     bits[11:0] of LFSR/ triangle amplitude equal to 4095                      */
      __IOM uint32_t DMAEN2     : 1;            /*!< [28..28] DAC channel2 DMA enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DMAUDRIE2  : 1;            /*!< [29..29] DAC channel2 DMA underrun interrupt enable This bit
                                                     is set and cleared by software.                                           */
      __IOM uint32_t CEN2       : 1;            /*!< [30..30] DAC Channel 2 calibration enable This bit is set and
                                                     cleared by software to enable/disable DAC channel 2 calibration,
                                                     it can be written only if bit EN2=0 into DAC_CR (the calibration
                                                     mode can be entered/exit only when the DAC channel is disabled)
                                                     Otherwise, the write operation is ignored.                                */
            uint32_t            : 1;
    } DAC_CR_b;
  } ;
  
  union {
    __OM  uint32_t DAC_SWTRGR;                  /*!< (@ 0x00000004) DAC software trigger register                              */
    
    struct {
      __OM  uint32_t SWTRIG1    : 1;            /*!< [0..0] DAC channel1 software trigger This bit is set by software
                                                     to trigger the DAC in software trigger mode. Note: This
                                                     bit is cleared by hardware (one APB1 clock cycle later)
                                                     once the DAC_DHR1 register value has been loaded into the
                                                     DAC_DOR1 register.                                                        */
      __OM  uint32_t SWTRIG2    : 1;            /*!< [1..1] DAC channel2 software trigger This bit is set by software
                                                     to trigger the DAC in software trigger mode. Note: This
                                                     bit is cleared by hardware (one APB1 clock cycle later)
                                                     once the DAC_DHR2 register value has been loaded into the
                                                     DAC_DOR2 register.                                                        */
            uint32_t            : 30;
    } DAC_SWTRGR_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12R1;                 /*!< (@ 0x00000008) DAC channel1 12-bit right-aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t DACC1DHR   : 12;           /*!< [11..0] DAC channel1 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32_t            : 20;
    } DAC_DHR12R1_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12L1;                 /*!< (@ 0x0000000C) DAC channel1 12-bit left aligned data holding
                                                                    register                                                   */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t DACC1DHR   : 12;           /*!< [15..4] DAC channel1 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32_t            : 16;
    } DAC_DHR12L1_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR8R1;                  /*!< (@ 0x00000010) DAC channel1 8-bit right aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t DACC1DHR   : 8;            /*!< [7..0] DAC channel1 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel1.                                                                 */
            uint32_t            : 24;
    } DAC_DHR8R1_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12R2;                 /*!< (@ 0x00000014) DAC channel2 12-bit right aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t DACC2DHR   : 12;           /*!< [11..0] DAC channel2 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
            uint32_t            : 20;
    } DAC_DHR12R2_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12L2;                 /*!< (@ 0x00000018) DAC channel2 12-bit left aligned data holding
                                                                    register                                                   */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t DACC2DHR   : 12;           /*!< [15..4] DAC channel2 12-bit left-aligned data These bits are
                                                     written by software which specify 12-bit data for DAC channel2.           */
            uint32_t            : 16;
    } DAC_DHR12L2_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR8R2;                  /*!< (@ 0x0000001C) DAC channel2 8-bit right-aligned data holding
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t DACC2DHR   : 8;            /*!< [7..0] DAC channel2 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel2.                                                                 */
            uint32_t            : 24;
    } DAC_DHR8R2_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12RD;                 /*!< (@ 0x00000020) Dual DAC 12-bit right-aligned data holding register        */
    
    struct {
      __IOM uint32_t DACC1DHR   : 12;           /*!< [11..0] DAC channel1 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32_t            : 4;
      __IOM uint32_t DACC2DHR   : 12;           /*!< [27..16] DAC channel2 12-bit right-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
            uint32_t            : 4;
    } DAC_DHR12RD_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR12LD;                 /*!< (@ 0x00000024) DUAL DAC 12-bit left aligned data holding register         */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t DACC1DHR   : 12;           /*!< [15..4] DAC channel1 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel1.                                                                 */
            uint32_t            : 4;
      __IOM uint32_t DACC2DHR   : 12;           /*!< [31..20] DAC channel2 12-bit left-aligned data These bits are
                                                     written by software which specifies 12-bit data for DAC
                                                     channel2.                                                                 */
    } DAC_DHR12LD_b;
  } ;
  
  union {
    __IOM uint32_t DAC_DHR8RD;                  /*!< (@ 0x00000028) DUAL DAC 8-bit right aligned data holding register         */
    
    struct {
      __IOM uint32_t DACC1DHR   : 8;            /*!< [7..0] DAC channel1 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel1.                                                                 */
      __IOM uint32_t DACC2DHR   : 8;            /*!< [15..8] DAC channel2 8-bit right-aligned data These bits are
                                                     written by software which specifies 8-bit data for DAC
                                                     channel2.                                                                 */
            uint32_t            : 16;
    } DAC_DHR8RD_b;
  } ;
  
  union {
    __IM  uint32_t DAC_DOR1;                    /*!< (@ 0x0000002C) DAC channel1 data output register                          */
    
    struct {
      __IM  uint32_t DACC1DOR   : 12;           /*!< [11..0] DAC channel1 data output These bits are read-only, they
                                                     contain data output for DAC channel1.                                     */
            uint32_t            : 20;
    } DAC_DOR1_b;
  } ;
  
  union {
    __IM  uint32_t DAC_DOR2;                    /*!< (@ 0x00000030) DAC channel2 data output register                          */
    
    struct {
      __IM  uint32_t DACC2DOR   : 12;           /*!< [11..0] DAC channel2 data output These bits are read-only, they
                                                     contain data output for DAC channel2.                                     */
            uint32_t            : 20;
    } DAC_DOR2_b;
  } ;
  
  union {
    __IOM uint32_t DAC_SR;                      /*!< (@ 0x00000034) DAC status register                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t DMAUDR1    : 1;            /*!< [13..13] DAC channel1 DMA underrun flag This bit is set by hardware
                                                     and cleared by software (by writing it to 1).                             */
      __IM  uint32_t CAL_FLAG1  : 1;            /*!< [14..14] DAC Channel 1 calibration offset status This bit is
                                                     set and cleared by hardware                                               */
      __IM  uint32_t BWST1      : 1;            /*!< [15..15] DAC Channel 1 busy writing sample time flag This bit
                                                     is systematically set just after Sample & Hold mode enable
                                                     and is set each time the software writes the register DAC_SHSR1,
                                                     It is cleared by hardware when the write operation of DAC_SHSR1
                                                     is complete. (It takes about 3LSI periods of synchronization).            */
            uint32_t            : 13;
      __IOM uint32_t DMAUDR2    : 1;            /*!< [29..29] DAC channel2 DMA underrun flag This bit is set by hardware
                                                     and cleared by software (by writing it to 1).                             */
      __IM  uint32_t CAL_FLAG2  : 1;            /*!< [30..30] DAC Channel 2 calibration offset status This bit is
                                                     set and cleared by hardware                                               */
      __IM  uint32_t BWST2      : 1;            /*!< [31..31] DAC Channel 2 busy writing sample time flag This bit
                                                     is systematically set just after Sample & Hold mode enable
                                                     and is set each time the software writes the register DAC_SHSR2,
                                                     It is cleared by hardware when the write operation of DAC_SHSR2
                                                     is complete. (It takes about 3 LSI periods of synchronization).           */
    } DAC_SR_b;
  } ;
  
  union {
    __IOM uint32_t DAC_CCR;                     /*!< (@ 0x00000038) DAC calibration control register                           */
    
    struct {
      __IOM uint32_t OTRIM1     : 5;            /*!< [4..0] DAC Channel 1 offset trimming value                                */
            uint32_t            : 11;
      __IOM uint32_t OTRIM2     : 5;            /*!< [20..16] DAC Channel 2 offset trimming value                              */
            uint32_t            : 11;
    } DAC_CCR_b;
  } ;
  
  union {
    __IOM uint32_t DAC_MCR;                     /*!< (@ 0x0000003C) DAC mode control register                                  */
    
    struct {
      __IOM uint32_t MODE1      : 3;            /*!< [2..0] DAC Channel 1 mode These bits can be written only when
                                                     the DAC is disabled and not in the calibration mode (when
                                                     bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1
                                                     or CEN1 =1 the write operation is ignored. They can be
                                                     set and cleared by software to select the DAC Channel 1
                                                     mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample
                                                     &amp; hold mode                                                           */
            uint32_t            : 13;
      __IOM uint32_t MODE2      : 3;            /*!< [18..16] DAC Channel 2 mode These bits can be written only when
                                                     the DAC is disabled and not in the calibration mode (when
                                                     bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1
                                                     or CEN2 =1 the write operation is ignored. They can be
                                                     set and cleared by software to select the DAC Channel 2
                                                     mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample
                                                     &amp; hold mode                                                           */
            uint32_t            : 13;
    } DAC_MCR_b;
  } ;
  
  union {
    __IOM uint32_t DAC_SHSR1;                   /*!< (@ 0x00000040) DAC Sample and Hold sample time register 1                 */
    
    struct {
      __IOM uint32_t TSAMPLE1   : 10;           /*!< [9..0] DAC Channel 1 sample Time (only valid in sample &amp;
                                                     hold mode) These bits can be written when the DAC channel1
                                                     is disabled or also during normal operation. in the latter
                                                     case, the write can be done only when BWSTx of DAC_SR register
                                                     is low, If BWSTx=1, the write operation is ignored.                       */
            uint32_t            : 22;
    } DAC_SHSR1_b;
  } ;
  
  union {
    __IOM uint32_t DAC_SHSR2;                   /*!< (@ 0x00000044) DAC Sample and Hold sample time register 2                 */
    
    struct {
      __IOM uint32_t TSAMPLE2   : 10;           /*!< [9..0] DAC Channel 2 sample Time (only valid in sample &amp;
                                                     hold mode) These bits can be written when the DAC channel2
                                                     is disabled or also during normal operation. in the latter
                                                     case, the write can be done only when BWSTx of DAC_SR register
                                                     is low, if BWSTx=1, the write operation is ignored.                       */
            uint32_t            : 22;
    } DAC_SHSR2_b;
  } ;
  
  union {
    __IOM uint32_t DAC_SHHR;                    /*!< (@ 0x00000048) DAC Sample and Hold hold time register                     */
    
    struct {
      __IOM uint32_t THOLD1     : 10;           /*!< [9..0] DAC Channel 1 hold Time (only valid in sample &amp; hold
                                                     mode) Hold time= (THOLD[9:0]) x T LSI                                     */
            uint32_t            : 6;
      __IOM uint32_t THOLD2     : 10;           /*!< [25..16] DAC Channel 2 hold time (only valid in sample &amp;
                                                     hold mode). Hold time= (THOLD[9:0]) x T LSI                               */
            uint32_t            : 6;
    } DAC_SHHR_b;
  } ;
  
  union {
    __IOM uint32_t DAC_SHRR;                    /*!< (@ 0x0000004C) DAC Sample and Hold refresh time register                  */
    
    struct {
      __IOM uint32_t TREFRESH1  : 8;            /*!< [7..0] DAC Channel 1 refresh Time (only valid in sample &amp;
                                                     hold mode) Refresh time= (TREFRESH[7:0]) x T LSI                          */
            uint32_t            : 8;
      __IOM uint32_t TREFRESH2  : 8;            /*!< [23..16] DAC Channel 2 refresh Time (only valid in sample &amp;
                                                     hold mode) Refresh time= (TREFRESH[7:0]) x T LSI                          */
            uint32_t            : 8;
    } DAC_SHRR_b;
  } ;
} DAC_Type;                                     /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                           BDMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief BDMA (BDMA)
  */

typedef struct {                                /*!< (@ 0x58025400) BDMA Structure                                             */
  
  union {
    __IM  uint32_t BDMA_ISR;                    /*!< (@ 0x00000000) DMA interrupt status register                              */
    
    struct {
      __IM  uint32_t GIF1       : 1;            /*!< [0..0] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TCIF1      : 1;            /*!< [1..1] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF1      : 1;            /*!< [2..2] Channel x half transfer flag (x = 1..8) This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCR register.                               */
      __IM  uint32_t TEIF1      : 1;            /*!< [3..3] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF2       : 1;            /*!< [4..4] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TCIF2      : 1;            /*!< [5..5] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF2      : 1;            /*!< [6..6] Channel x half transfer flag (x = 1..8) This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCR register.                               */
      __IM  uint32_t TEIF2      : 1;            /*!< [7..7] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF3       : 1;            /*!< [8..8] Channel x global interrupt flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TCIF3      : 1;            /*!< [9..9] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF3      : 1;            /*!< [10..10] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF3      : 1;            /*!< [11..11] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF4       : 1;            /*!< [12..12] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t TCIF4      : 1;            /*!< [13..13] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF4      : 1;            /*!< [14..14] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF4      : 1;            /*!< [15..15] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF5       : 1;            /*!< [16..16] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t TCIF5      : 1;            /*!< [17..17] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF5      : 1;            /*!< [18..18] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF5      : 1;            /*!< [19..19] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF6       : 1;            /*!< [20..20] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t TCIF6      : 1;            /*!< [21..21] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF6      : 1;            /*!< [22..22] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF6      : 1;            /*!< [23..23] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF7       : 1;            /*!< [24..24] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t TCIF7      : 1;            /*!< [25..25] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF7      : 1;            /*!< [26..26] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF7      : 1;            /*!< [27..27] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t GIF8       : 1;            /*!< [28..28] Channel x global interrupt flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t TCIF8      : 1;            /*!< [29..29] Channel x transfer complete flag (x = 1..8) This bit
                                                     is set by hardware. It is cleared by software writing 1
                                                     to the corresponding bit in the DMA_IFCR register.                        */
      __IM  uint32_t HTIF8      : 1;            /*!< [30..30] Channel x half transfer flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
      __IM  uint32_t TEIF8      : 1;            /*!< [31..31] Channel x transfer error flag (x = 1..8) This bit is
                                                     set by hardware. It is cleared by software writing 1 to
                                                     the corresponding bit in the DMA_IFCR register.                           */
    } BDMA_ISR_b;
  } ;
  
  union {
    __OM  uint32_t BDMA_IFCR;                   /*!< (@ 0x00000004) DMA interrupt flag clear register                          */
    
    struct {
      __OM  uint32_t CGIF1      : 1;            /*!< [0..0] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF1     : 1;            /*!< [1..1] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF1     : 1;            /*!< [2..2] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF1     : 1;            /*!< [3..3] Channel x transfer error clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CGIF2      : 1;            /*!< [4..4] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF2     : 1;            /*!< [5..5] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF2     : 1;            /*!< [6..6] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF2     : 1;            /*!< [7..7] Channel x transfer error clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CGIF3      : 1;            /*!< [8..8] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF3     : 1;            /*!< [9..9] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF3     : 1;            /*!< [10..10] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF3     : 1;            /*!< [11..11] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CGIF4      : 1;            /*!< [12..12] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF4     : 1;            /*!< [13..13] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF4     : 1;            /*!< [14..14] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF4     : 1;            /*!< [15..15] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CGIF5      : 1;            /*!< [16..16] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF5     : 1;            /*!< [17..17] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF5     : 1;            /*!< [18..18] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF5     : 1;            /*!< [19..19] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CGIF6      : 1;            /*!< [20..20] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF6     : 1;            /*!< [21..21] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF6     : 1;            /*!< [22..22] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF6     : 1;            /*!< [23..23] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CGIF7      : 1;            /*!< [24..24] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF7     : 1;            /*!< [25..25] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF7     : 1;            /*!< [26..26] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF7     : 1;            /*!< [27..27] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CGIF8      : 1;            /*!< [28..28] Channel x global interrupt clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CTCIF8     : 1;            /*!< [29..29] Channel x transfer complete clear This bit is set and
                                                     cleared by software.                                                      */
      __OM  uint32_t CHTIF8     : 1;            /*!< [30..30] Channel x half transfer clear This bit is set and cleared
                                                     by software.                                                              */
      __OM  uint32_t CTEIF8     : 1;            /*!< [31..31] Channel x transfer error clear This bit is set and
                                                     cleared by software.                                                      */
    } BDMA_IFCR_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CCR1;                   /*!< (@ 0x00000008) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR1_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR1;                 /*!< (@ 0x0000000C) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR1_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR1;                  /*!< (@ 0x00000010) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR1_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR1;                  /*!< (@ 0x00000014) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR1_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t BDMA_CCR2;                   /*!< (@ 0x0000001C) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR2_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR2;                 /*!< (@ 0x00000020) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR2_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR2;                  /*!< (@ 0x00000024) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR2_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR2;                  /*!< (@ 0x00000028) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR2_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t BDMA_CCR3;                   /*!< (@ 0x00000030) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR3_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR3;                 /*!< (@ 0x00000034) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR3_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR3;                  /*!< (@ 0x00000038) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR3_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR3;                  /*!< (@ 0x0000003C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR3_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t BDMA_CCR4;                   /*!< (@ 0x00000044) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR4_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR4;                 /*!< (@ 0x00000048) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR4_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR4;                  /*!< (@ 0x0000004C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR4_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR4;                  /*!< (@ 0x00000050) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR4_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t BDMA_CCR5;                   /*!< (@ 0x00000058) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR5_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR5;                 /*!< (@ 0x0000005C) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR5_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR5;                  /*!< (@ 0x00000060) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR5_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR5;                  /*!< (@ 0x00000064) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR5_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t BDMA_CCR6;                   /*!< (@ 0x0000006C) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR6_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR6;                 /*!< (@ 0x00000070) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR6_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR6;                  /*!< (@ 0x00000074) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR6_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR6;                  /*!< (@ 0x00000078) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR6_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t BDMA_CCR7;                   /*!< (@ 0x00000080) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR7_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR7;                 /*!< (@ 0x00000084) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR7_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR7;                  /*!< (@ 0x00000088) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR7_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR7;                  /*!< (@ 0x0000008C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR7_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t BDMA_CCR8;                   /*!< (@ 0x00000094) DMA channel x configuration register                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Channel enable This bit is set and cleared by software.            */
      __IOM uint32_t TCIE       : 1;            /*!< [1..1] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t HTIE       : 1;            /*!< [2..2] Half transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TEIE       : 1;            /*!< [3..3] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Data transfer direction This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t CIRC       : 1;            /*!< [5..5] Circular mode This bit is set and cleared by software.             */
      __IOM uint32_t PINC       : 1;            /*!< [6..6] Peripheral increment mode This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MINC       : 1;            /*!< [7..7] Memory increment mode This bit is set and cleared by
                                                     software.                                                                 */
      __IOM uint32_t PSIZE      : 2;            /*!< [9..8] Peripheral size These bits are set and cleared by software.        */
      __IOM uint32_t MSIZE      : 2;            /*!< [11..10] Memory size These bits are set and cleared by software.          */
      __IOM uint32_t PL         : 2;            /*!< [13..12] Channel priority level These bits are set and cleared
                                                     by software.                                                              */
      __IOM uint32_t MEM2MEM    : 1;            /*!< [14..14] Memory to memory mode This bit is set and cleared by
                                                     software.                                                                 */
            uint32_t            : 17;
    } BDMA_CCR8_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CNDTR8;                 /*!< (@ 0x00000098) DMA channel x number of data register                      */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data to transfer Number of data to be transferred
                                                     (0 up to 65535). This register can only be written when
                                                     the channel is disabled. Once the channel is enabled, this
                                                     register is read-only, indicating the remaining bytes to
                                                     be transmitted. This register decrements after each DMA
                                                     transfer. Once the transfer is completed, this register
                                                     can either stay at zero or be reloaded automati                           */
            uint32_t            : 16;
    } BDMA_CNDTR8_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CPAR8;                  /*!< (@ 0x0000009C) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address Base address of the peripheral data
                                                     register from/to which the data will be read/written. When
                                                     PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access
                                                     is automatically aligned to a half-word address. When PSIZE
                                                     is 10 (32-bit), PA[1:0] are ignored. Access is automatically
                                                     aligned to a word address.                                                */
    } BDMA_CPAR8_b;
  } ;
  
  union {
    __IOM uint32_t BDMA_CMAR8;                  /*!< (@ 0x000000A0) This register must not be written when the channel
                                                                    is enabled.                                                */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Base address of the memory area from/to
                                                     which the data will be read/written. When MSIZE is 01 (16-bit),
                                                     the MA[0] bit is ignored. Access is automatically aligned
                                                     to a half-word address. When MSIZE is 10 (32-bit), MA[1:0]
                                                     are ignored. Access is automatically aligned to a word
                                                     address.                                                                  */
    } BDMA_CMAR8_b;
  } ;
} BDMA_Type;                                    /*!< Size = 164 (0xa4)                                                         */



/* =========================================================================================================================== */
/* ================                                           DMA2D                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA2D (DMA2D)
  */

typedef struct {                                /*!< (@ 0x52001000) DMA2D Structure                                            */
  
  union {
    __IOM uint32_t DMA2D_CR;                    /*!< (@ 0x00000000) DMA2D control register                                     */
    
    struct {
      __IOM uint32_t START      : 1;            /*!< [0..0] Start This bit can be used to launch the DMA2D according
                                                     to the parameters loaded in the various configuration registers           */
      __IOM uint32_t SUSP       : 1;            /*!< [1..1] Suspend This bit can be used to suspend the current transfer.
                                                     This bit is set and reset by software. It is automatically
                                                     reset by hardware when the START bit is reset.                            */
      __IOM uint32_t ABORT      : 1;            /*!< [2..2] Abort This bit can be used to abort the current transfer.
                                                     This bit is set by software and is automatically reset
                                                     by hardware when the START bit is reset.                                  */
            uint32_t            : 5;
      __IOM uint32_t TEIE       : 1;            /*!< [8..8] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [9..9] Transfer complete interrupt enable This bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t TWIE       : 1;            /*!< [10..10] Transfer watermark interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t CAEIE      : 1;            /*!< [11..11] CLUT access error interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t CTCIE      : 1;            /*!< [12..12] CLUT transfer complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t CEIE       : 1;            /*!< [13..13] Configuration Error Interrupt Enable This bit is set
                                                     and cleared by software.                                                  */
            uint32_t            : 2;
      __IOM uint32_t MODE       : 2;            /*!< [17..16] DMA2D mode This bit is set and cleared by software.
                                                     It cannot be modified while a transfer is ongoing.                        */
            uint32_t            : 14;
    } DMA2D_CR_b;
  } ;
  
  union {
    __IM  uint32_t DMA2D_ISR;                   /*!< (@ 0x00000004) DMA2D Interrupt Status Register                            */
    
    struct {
      __IM  uint32_t TEIF       : 1;            /*!< [0..0] Transfer error interrupt flag This bit is set when an
                                                     error occurs during a DMA transfer (data transfer or automatic
                                                     CLUT loading).                                                            */
      __IM  uint32_t TCIF       : 1;            /*!< [1..1] Transfer complete interrupt flag This bit is set when
                                                     a DMA2D transfer operation is complete (data transfer only).              */
      __IM  uint32_t TWIF       : 1;            /*!< [2..2] Transfer watermark interrupt flag This bit is set when
                                                     the last pixel of the watermarked line has been transferred.              */
      __IM  uint32_t CAEIF      : 1;            /*!< [3..3] CLUT access error interrupt flag This bit is set when
                                                     the CPU accesses the CLUT while the CLUT is being automatically
                                                     copied from a system memory to the internal DMA2D.                        */
      __IM  uint32_t CTCIF      : 1;            /*!< [4..4] CLUT transfer complete interrupt flag This bit is set
                                                     when the CLUT copy from a system memory area to the internal
                                                     DMA2D memory is complete.                                                 */
      __IM  uint32_t CEIF       : 1;            /*!< [5..5] Configuration error interrupt flag This bit is set when
                                                     the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR
                                                     is set and a wrong configuration has been programmed.                     */
            uint32_t            : 26;
    } DMA2D_ISR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_IFCR;                  /*!< (@ 0x00000008) DMA2D interrupt flag clear register                        */
    
    struct {
      __IOM uint32_t CTEIF      : 1;            /*!< [0..0] Clear Transfer error interrupt flag Programming this
                                                     bit to 1 clears the TEIF flag in the DMA2D_ISR register                   */
      __IOM uint32_t CTCIF      : 1;            /*!< [1..1] Clear transfer complete interrupt flag Programming this
                                                     bit to 1 clears the TCIF flag in the DMA2D_ISR register                   */
      __IOM uint32_t CTWIF      : 1;            /*!< [2..2] Clear transfer watermark interrupt flag Programming this
                                                     bit to 1 clears the TWIF flag in the DMA2D_ISR register                   */
      __IOM uint32_t CAECIF     : 1;            /*!< [3..3] Clear CLUT access error interrupt flag Programming this
                                                     bit to 1 clears the CAEIF flag in the DMA2D_ISR register                  */
      __IOM uint32_t CCTCIF     : 1;            /*!< [4..4] Clear CLUT transfer complete interrupt flag Programming
                                                     this bit to 1 clears the CTCIF flag in the DMA2D_ISR register             */
      __IOM uint32_t CCEIF      : 1;            /*!< [5..5] Clear configuration error interrupt flag Programming
                                                     this bit to 1 clears the CEIF flag in the DMA2D_ISR register              */
            uint32_t            : 26;
    } DMA2D_IFCR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_FGMAR;                 /*!< (@ 0x0000000C) DMA2D foreground memory address register                   */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Address of the data used for the foreground
                                                     image. This register can only be written when data transfers
                                                     are disabled. Once the data transfer has started, this
                                                     register is read-only. The address alignment must match
                                                     the image format selected e.g. a 32-bit per pixel format
                                                     must be 32-bit aligned, a 16-bit per pixel format must
                                                     be 16-bit aligned and a 4-bit per pixel format must be
                                                                                                                               */
    } DMA2D_FGMAR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_FGOR;                  /*!< (@ 0x00000010) DMA2D foreground offset register                           */
    
    struct {
      __IOM uint32_t LO         : 14;           /*!< [13..0] Line offset Line offset used for the foreground expressed
                                                     in pixel. This value is used to generate the address. It
                                                     is added at the end of each line to determine the starting
                                                     address of the next line. These bits can only be written
                                                     when data transfers are disabled. Once a data transfer
                                                     has started, they become read-only. If the image format
                                                     is 4-bit per pixel, the line offset must be even.                         */
            uint32_t            : 18;
    } DMA2D_FGOR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_BGMAR;                 /*!< (@ 0x00000014) DMA2D background memory address register                   */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Address of the data used for the background
                                                     image. This register can only be written when data transfers
                                                     are disabled. Once a data transfer has started, this register
                                                     is read-only. The address alignment must match the image
                                                     format selected e.g. a 32-bit per pixel format must be
                                                     32-bit aligned, a 16-bit per pixel format must be 16-bit
                                                     aligned and a 4-bit per pixel format must be                              */
    } DMA2D_BGMAR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_BGOR;                  /*!< (@ 0x00000018) DMA2D background offset register                           */
    
    struct {
      __IOM uint32_t LO         : 14;           /*!< [13..0] Line offset Line offset used for the background image
                                                     (expressed in pixel). This value is used for the address
                                                     generation. It is added at the end of each line to determine
                                                     the starting address of the next line. These bits can only
                                                     be written when data transfers are disabled. Once data
                                                     transfer has started, they become read-only. If the image
                                                     format is 4-bit per pixel, the line offset must be                        */
            uint32_t            : 18;
    } DMA2D_BGOR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_FGPFCCR;               /*!< (@ 0x0000001C) DMA2D foreground PFC control register                      */
    
    struct {
      __IOM uint32_t CM         : 4;            /*!< [3..0] Color mode These bits defines the color format of the
                                                     foreground image. They can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.
                                                     others: meaningless                                                       */
      __IOM uint32_t CCM        : 1;            /*!< [4..4] CLUT color mode This bit defines the color format of
                                                     the CLUT. It can only be written when the transfer is disabled.
                                                     Once the CLUT transfer has started, this bit is read-only.                */
      __IOM uint32_t START      : 1;            /*!< [5..5] Start This bit can be set to start the automatic loading
                                                     of the CLUT. It is automatically reset: ** at the end of
                                                     the transfer ** when the transfer is aborted by the user
                                                     application by setting the ABORT bit in DMA2D_CR ** when
                                                     a transfer error occurs ** when the transfer has not started
                                                     due to a configuration error or another transfer operation
                                                     already ongoing (data transfer or automatic                               */
            uint32_t            : 2;
      __IOM uint32_t CS         : 8;            /*!< [15..8] CLUT size These bits define the size of the CLUT used
                                                     for the foreground image. Once the CLUT transfer has started,
                                                     this field is read-only. The number of CLUT entries is
                                                     equal to CS[7:0] + 1.                                                     */
      __IOM uint32_t AM         : 2;            /*!< [17..16] Alpha mode These bits select the alpha channel value
                                                     to be used for the foreground image. They can only be written
                                                     data the transfer are disabled. Once the transfer has started,
                                                     they become read-only. other configurations are meaningless               */
      __IOM uint32_t CSS        : 2;            /*!< [19..18] Chroma Sub-Sampling These bits define the chroma sub-sampling
                                                     mode for YCbCr color mode. Once the transfer has started,
                                                     these bits are read-only. others: meaningless                             */
      __IOM uint32_t AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32_t RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32_t            : 2;
      __IOM uint32_t ALPHA      : 8;            /*!< [31..24] Alpha value These bits define a fixed alpha channel
                                                     value which can replace the original alpha value or be
                                                     multiplied by the original alpha value according to the
                                                     alpha mode selected through the AM[1:0] bits. These bits
                                                     can only be written when data transfers are disabled. Once
                                                     a transfer has started, they become read-only.                            */
    } DMA2D_FGPFCCR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_FGCOLR;                /*!< (@ 0x00000020) DMA2D foreground color register                            */
    
    struct {
      __IOM uint32_t BLUE       : 8;            /*!< [7..0] Blue Value These bits defines the blue value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, They are read-only.                                          */
      __IOM uint32_t GREEN      : 8;            /*!< [15..8] Green Value These bits defines the green value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, They are read-only.                                          */
      __IOM uint32_t RED        : 8;            /*!< [23..16] Red Value These bits defines the red value for the
                                                     A4 or A8 mode of the foreground image. They can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only.                                          */
            uint32_t            : 8;
    } DMA2D_FGCOLR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_BGPFCCR;               /*!< (@ 0x00000024) DMA2D background PFC control register                      */
    
    struct {
      __IOM uint32_t CM         : 4;            /*!< [3..0] Color mode These bits define the color format of the
                                                     foreground image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only. others: meaningless                                   */
      __IOM uint32_t CCM        : 1;            /*!< [4..4] CLUT Color mode These bits define the color format of
                                                     the CLUT. This register can only be written when the transfer
                                                     is disabled. Once the CLUT transfer has started, this bit
                                                     is read-only.                                                             */
      __IOM uint32_t START      : 1;            /*!< [5..5] Start This bit is set to start the automatic loading
                                                     of the CLUT. This bit is automatically reset: ** at the
                                                     end of the transfer ** when the transfer is aborted by
                                                     the user application by setting the ABORT bit in the DMA2D_CR
                                                     ** when a transfer error occurs ** when the transfer has
                                                     not started due to a configuration error or another transfer
                                                     operation already on going (data transfer or au                           */
            uint32_t            : 2;
      __IOM uint32_t CS         : 8;            /*!< [15..8] CLUT size These bits define the size of the CLUT used
                                                     for the BG. Once the CLUT transfer has started, this field
                                                     is read-only. The number of CLUT entries is equal to CS[7:0]
                                                     + 1.                                                                      */
      __IOM uint32_t AM         : 2;            /*!< [17..16] Alpha mode These bits define which alpha channel value
                                                     to be used for the background image. These bits can only
                                                     be written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only. others: meaningless                      */
            uint32_t            : 2;
      __IOM uint32_t AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32_t RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32_t            : 2;
      __IOM uint32_t ALPHA      : 8;            /*!< [31..24] Alpha value These bits define a fixed alpha channel
                                                     value which can replace the original alpha value or be
                                                     multiplied with the original alpha value according to the
                                                     alpha mode selected with bits AM[1: 0]. These bits can
                                                     only be written when data transfers are disabled. Once
                                                     the transfer has started, they are read-only.                             */
    } DMA2D_BGPFCCR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_BGCOLR;                /*!< (@ 0x00000028) DMA2D background color register                            */
    
    struct {
      __IOM uint32_t BLUE       : 8;            /*!< [7..0] Blue Value These bits define the blue value for the A4
                                                     or A8 mode of the background. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
      __IOM uint32_t GREEN      : 8;            /*!< [15..8] Green Value These bits define the green value for the
                                                     A4 or A8 mode of the background. These bits can only be
                                                     written when data transfers are disabled. Once the transfer
                                                     has started, they are read-only.                                          */
      __IOM uint32_t RED        : 8;            /*!< [23..16] Red Value These bits define the red value for the A4
                                                     or A8 mode of the background. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
            uint32_t            : 8;
    } DMA2D_BGCOLR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_FGCMAR;                /*!< (@ 0x0000002C) DMA2D foreground CLUT memory address register              */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory Address Address of the data used for the CLUT
                                                     address dedicated to the foreground image. This register
                                                     can only be written when no transfer is ongoing. Once the
                                                     CLUT transfer has started, this register is read-only.
                                                     If the foreground CLUT format is 32-bit, the address must
                                                     be 32-bit aligned.                                                        */
    } DMA2D_FGCMAR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_BGCMAR;                /*!< (@ 0x00000030) DMA2D background CLUT memory address register              */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory address Address of the data used for the CLUT
                                                     address dedicated to the background image. This register
                                                     can only be written when no transfer is on going. Once
                                                     the CLUT transfer has started, this register is read-only.
                                                     If the background CLUT format is 32-bit, the address must
                                                     be 32-bit aligned.                                                        */
    } DMA2D_BGCMAR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_OPFCCR;                /*!< (@ 0x00000034) DMA2D output PFC control register                          */
    
    struct {
      __IOM uint32_t CM         : 3;            /*!< [2..0] Color mode These bits define the color format of the
                                                     output image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only. others: meaningless                                   */
            uint32_t            : 17;
      __IOM uint32_t AI         : 1;            /*!< [20..20] Alpha Inverted This bit inverts the alpha value. Once
                                                     the transfer has started, this bit is read-only.                          */
      __IOM uint32_t RBS        : 1;            /*!< [21..21] Red Blue Swap This bit allows to swap the R &amp; B
                                                     to support BGR or ABGR color formats. Once the transfer
                                                     has started, this bit is read-only.                                       */
            uint32_t            : 10;
    } DMA2D_OPFCCR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_OCOLR;                 /*!< (@ 0x00000038) DMA2D output color register                                */
    
    struct {
      __IOM uint32_t BLUE       : 8;            /*!< [7..0] Blue Value These bits define the blue value of the output
                                                     image. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.          */
      __IOM uint32_t GREEN      : 8;            /*!< [15..8] Green Value These bits define the green value of the
                                                     output image. These bits can only be written when data
                                                     transfers are disabled. Once the transfer has started,
                                                     they are read-only.                                                       */
      __IOM uint32_t RED        : 8;            /*!< [23..16] Red Value These bits define the red value of the output
                                                     image. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.          */
      __IOM uint32_t ALPHA      : 8;            /*!< [31..24] Alpha Channel Value These bits define the alpha channel
                                                     of the output color. These bits can only be written when
                                                     data transfers are disabled. Once the transfer has started,
                                                     they are read-only.                                                       */
    } DMA2D_OCOLR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_OMAR;                  /*!< (@ 0x0000003C) DMA2D output memory address register                       */
    
    struct {
      __IOM uint32_t MA         : 32;           /*!< [31..0] Memory Address Address of the data used for the output
                                                     FIFO. These bits can only be written when data transfers
                                                     are disabled. Once the transfer has started, they are read-only.
                                                     The address alignment must match the image format selected
                                                     e.g. a 32-bit per pixel format must be 32-bit aligned and
                                                     a 16-bit per pixel format must be 16-bit aligned.                         */
    } DMA2D_OMAR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_OOR;                   /*!< (@ 0x00000040) DMA2D output offset register                               */
    
    struct {
      __IOM uint32_t LO         : 14;           /*!< [13..0] Line Offset Line offset used for the output (expressed
                                                     in pixels). This value is used for the address generation.
                                                     It is added at the end of each line to determine the starting
                                                     address of the next line. These bits can only be written
                                                     when data transfers are disabled. Once the transfer has
                                                     started, they are read-only.                                              */
            uint32_t            : 18;
    } DMA2D_OOR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_NLR;                   /*!< (@ 0x00000044) DMA2D number of line register                              */
    
    struct {
      __IOM uint32_t NL         : 16;           /*!< [15..0] Number of lines Number of lines of the area to be transferred.
                                                     These bits can only be written when data transfers are
                                                     disabled. Once the transfer has started, they are read-only.              */
      __IOM uint32_t PL         : 14;           /*!< [29..16] Pixel per lines Number of pixels per lines of the area
                                                     to be transferred. These bits can only be written when
                                                     data transfers are disabled. Once the transfer has started,
                                                     they are read-only. If any of the input image format is
                                                     4-bit per pixel, pixel per lines must be even.                            */
            uint32_t            : 2;
    } DMA2D_NLR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_LWR;                   /*!< (@ 0x00000048) DMA2D line watermark register                              */
    
    struct {
      __IOM uint32_t LW         : 16;           /*!< [15..0] Line watermark These bits allow to configure the line
                                                     watermark for interrupt generation. An interrupt is raised
                                                     when the last pixel of the watermarked line has been transferred.
                                                     These bits can only be written when data transfers are
                                                     disabled. Once the transfer has started, they are read-only.              */
            uint32_t            : 16;
    } DMA2D_LWR_b;
  } ;
  
  union {
    __IOM uint32_t DMA2D_AMTCR;                 /*!< (@ 0x0000004C) DMA2D AXI master timer configuration register              */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable Enables the dead time functionality.                        */
            uint32_t            : 7;
      __IOM uint32_t DT         : 8;            /*!< [15..8] Dead Time Dead time value in the AXI clock cycle inserted
                                                     between two consecutive accesses on the AXI master port.
                                                     These bits represent the minimum guaranteed number of cycles
                                                     between two consecutive AXI accesses.                                     */
            uint32_t            : 16;
    } DMA2D_AMTCR_b;
  } ;
} DMA2D_Type;                                   /*!< Size = 80 (0x50)                                                          */



/* =========================================================================================================================== */
/* ================                                          DMAMUX2                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DMAMUX (DMAMUX2)
  */

typedef struct {                                /*!< (@ 0x58025800) DMAMUX2 Structure                                          */
  
  union {
    __IOM uint32_t DMAMUX2_C0CR;                /*!< (@ 0x00000000) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C0CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C1CR;                /*!< (@ 0x00000004) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C1CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C2CR;                /*!< (@ 0x00000008) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C2CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C3CR;                /*!< (@ 0x0000000C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C3CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C4CR;                /*!< (@ 0x00000010) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C4CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C5CR;                /*!< (@ 0x00000014) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C5CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C6CR;                /*!< (@ 0x00000018) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C6CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_C7CR;                /*!< (@ 0x0000001C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX2_C7CR_b;
  } ;
  __IM  uint32_t  RESERVED[24];
  
  union {
    __IM  uint32_t DMAMUX2_CSR;                 /*!< (@ 0x00000080) DMAMUX request line multiplexer interrupt channel
                                                                    status register                                            */
    
    struct {
      __IM  uint32_t SOF        : 16;           /*!< [15..0] Synchronization overrun event flag                                */
            uint32_t            : 16;
    } DMAMUX2_CSR_b;
  } ;
  
  union {
    __OM  uint32_t DMAMUX2_CFR;                 /*!< (@ 0x00000084) DMAMUX request line multiplexer interrupt clear
                                                                    flag register                                              */
    
    struct {
      __OM  uint32_t CSOF       : 16;           /*!< [15..0] Clear synchronization overrun event flag                          */
            uint32_t            : 16;
    } DMAMUX2_CFR_b;
  } ;
  __IM  uint32_t  RESERVED1[30];
  
  union {
    __IOM uint32_t DMAMUX2_RG0CR;               /*!< (@ 0x00000100) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG0CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG1CR;               /*!< (@ 0x00000104) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG1CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG2CR;               /*!< (@ 0x00000108) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG2CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG3CR;               /*!< (@ 0x0000010C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG3CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG4CR;               /*!< (@ 0x00000110) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG4CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG5CR;               /*!< (@ 0x00000114) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG5CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG6CR;               /*!< (@ 0x00000118) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG6CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX2_RG7CR;               /*!< (@ 0x0000011C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX2_RG7CR_b;
  } ;
  __IM  uint32_t  RESERVED2[8];
  
  union {
    __IM  uint32_t DMAMUX2_RGSR;                /*!< (@ 0x00000140) DMAMux - DMA request generator status register             */
    
    struct {
      __IM  uint32_t OF         : 8;            /*!< [7..0] Trigger event overrun flag The flag is set when a trigger
                                                     event occurs on DMA request generator channel x, while
                                                     the DMA request generator counter value is lower than GNBREQ.
                                                     The flag is cleared by writing 1 to the corresponding COFx
                                                     bit in DMAMUX_RGCFR register.                                             */
            uint32_t            : 24;
    } DMAMUX2_RGSR_b;
  } ;
  
  union {
    __OM  uint32_t DMAMUX2_RGCFR;               /*!< (@ 0x00000144) DMAMux - DMA request generator clear flag register         */
    
    struct {
      __OM  uint32_t COF        : 8;            /*!< [7..0] Clear trigger event overrun flag Upon setting, this bit
                                                     clears the corresponding overrun flag OFx in the DMAMUX_RGCSR
                                                     register.                                                                 */
            uint32_t            : 24;
    } DMAMUX2_RGCFR_b;
  } ;
} DMAMUX2_Type;                                 /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                            FMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FMC (FMC)
  */

typedef struct {                                /*!< (@ 0x52004000) FMC Structure                                              */
  
  union {
    __IOM uint32_t FMC_BCR1;                    /*!< (@ 0x00000000) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32_t MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32_t MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32_t MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32_t FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32_t            : 1;
      __IOM uint32_t BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32_t WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32_t            : 1;
      __IOM uint32_t WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32_t WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32_t WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32_t EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the defa                                                                  */
      __IOM uint32_t ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32_t CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32_t CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32_t CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32_t WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32_t            : 2;
      __IOM uint32_t BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32_t            : 5;
      __IOM uint32_t FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } FMC_BCR1_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BTR1;                    /*!< (@ 0x00000004) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mini                */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In synchr                                 */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a different           */
      __IOM uint32_t CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32_t DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32_t            : 2;
    } FMC_BTR1_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BCR2;                    /*!< (@ 0x00000008) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32_t MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32_t MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32_t MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32_t FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32_t            : 1;
      __IOM uint32_t BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32_t WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32_t            : 1;
      __IOM uint32_t WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32_t WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32_t WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32_t EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the defa                                                                  */
      __IOM uint32_t ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32_t CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32_t CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32_t CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32_t WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32_t            : 2;
      __IOM uint32_t BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32_t            : 5;
      __IOM uint32_t FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } FMC_BCR2_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BTR2;                    /*!< (@ 0x0000000C) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mini                */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In synchr                                 */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a different           */
      __IOM uint32_t CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32_t DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32_t            : 2;
    } FMC_BTR2_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BCR3;                    /*!< (@ 0x00000010) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32_t MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32_t MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32_t MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32_t FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32_t            : 1;
      __IOM uint32_t BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32_t WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32_t            : 1;
      __IOM uint32_t WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32_t WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32_t WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32_t EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the defa                                                                  */
      __IOM uint32_t ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32_t CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32_t CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32_t CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32_t WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32_t            : 2;
      __IOM uint32_t BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32_t            : 5;
      __IOM uint32_t FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } FMC_BCR3_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BTR3;                    /*!< (@ 0x00000014) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mini                */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In synchr                                 */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a different           */
      __IOM uint32_t CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32_t DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32_t            : 2;
    } FMC_BTR3_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BCR4;                    /*!< (@ 0x00000018) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.                                    */
    
    struct {
      __IOM uint32_t MBKEN      : 1;            /*!< [0..0] Memory bank enable bit This bit enables the memory bank.
                                                     After reset Bank1 is enabled, all others are disabled.
                                                     Accessing a disabled bank causes an ERROR on AXI bus.                     */
      __IOM uint32_t MUXEN      : 1;            /*!< [1..1] Address/data multiplexing enable bit When this bit is
                                                     set, the address and data values are multiplexed on the
                                                     data bus, valid only with NOR and PSRAM memories:                         */
      __IOM uint32_t MTYP       : 2;            /*!< [3..2] Memory type These bits define the type of external memory
                                                     attached to the corresponding memory bank:                                */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width Defines the external memory device
                                                     width, valid for all type of memories.                                    */
      __IOM uint32_t FACCEN     : 1;            /*!< [6..6] Flash access enable This bit enables NOR Flash memory
                                                     access operations.                                                        */
            uint32_t            : 1;
      __IOM uint32_t BURSTEN    : 1;            /*!< [8..8] Burst enable bit This bit enables/disables synchronous
                                                     accesses during read operations. It is valid only for synchronous
                                                     memories operating in Burst mode:                                         */
      __IOM uint32_t WAITPOL    : 1;            /*!< [9..9] Wait signal polarity bit This bit defines the polarity
                                                     of the wait signal from memory used for either in synchronous
                                                     or asynchronous mode:                                                     */
            uint32_t            : 1;
      __IOM uint32_t WAITCFG    : 1;            /*!< [11..11] Wait timing configuration The NWAIT signal indicates
                                                     whether the data from the memory are valid or if a wait
                                                     state must be inserted when accessing the memory in synchronous
                                                     mode. This configuration bit determines if NWAIT is asserted
                                                     by the memory one clock cycle before the wait state or
                                                     during the wait state:                                                    */
      __IOM uint32_t WREN       : 1;            /*!< [12..12] Write enable bit This bit indicates whether write operations
                                                     are enabled/disabled in the bank by the FMC:                              */
      __IOM uint32_t WAITEN     : 1;            /*!< [13..13] Wait enable bit This bit enables/disables wait-state
                                                     insertion via the NWAIT signal when accessing the memory
                                                     in synchronous mode.                                                      */
      __IOM uint32_t EXTMOD     : 1;            /*!< [14..14] Extended mode enable. This bit enables the FMC to program
                                                     the write timings for asynchronous accesses inside the
                                                     FMC_BWTR register, thus resulting in different timings
                                                     for read and write operations. Note: When the extended
                                                     mode is disabled, the FMC can operate in Mode1 or Mode2
                                                     as follows: ** Mode 1 is the default mode when the SRAM/PSRAM
                                                     memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is
                                                     the defa                                                                  */
      __IOM uint32_t ASYNCWAIT  : 1;            /*!< [15..15] Wait signal during asynchronous transfers This bit
                                                     enables/disables the FMC to use the wait signal even during
                                                     an asynchronous protocol.                                                 */
      __IOM uint32_t CPSIZE     : 3;            /*!< [18..16] CRAM Page Size These are used for Cellular RAM 1.5
                                                     which does not allow burst access to cross the address
                                                     boundaries between pages. When these bits are configured,
                                                     the FMC controller splits automatically the burst access
                                                     when the memory page size is reached (refer to memory datasheet
                                                     for page size). Other configuration: reserved.                            */
      __IOM uint32_t CBURSTRW   : 1;            /*!< [19..19] Write burst enable For PSRAM (CRAM) operating in Burst
                                                     mode, the bit enables synchronous accesses during write
                                                     operations. The enable bit for synchronous read accesses
                                                     is the BURSTEN bit in the FMC_BCRx register.                              */
      __IOM uint32_t CCLKEN     : 1;            /*!< [20..20] Continuous Clock Enable This bit enables the FMC_CLK
                                                     clock output to external memory devices. Note: The CCLKEN
                                                     bit of the FMC_BCR2..4 registers is dont care. It is only
                                                     enabled through the FMC_BCR1 register. Bank 1 must be configured
                                                     in synchronous mode to generate the FMC_CLK continuous
                                                     clock. If CCLKEN bit is set, the FMC_CLK clock ratio is
                                                     specified by CLKDIV value in the FMC_BTR1 register.                       */
      __IOM uint32_t WFDIS      : 1;            /*!< [21..21] Write FIFO Disable This bit disables the Write FIFO
                                                     used by the FMC controller. Note: The WFDIS bit of the
                                                     FMC_BCR2..4 registers is dont care. It is only enabled
                                                     through the FMC_BCR1 register.                                            */
            uint32_t            : 2;
      __IOM uint32_t BMAP       : 2;            /*!< [25..24] FMC bank mapping These bits allows different to remap
                                                     SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer
                                                     to Table 10 for Note: The BMAP bits of the FMC_BCR2..4
                                                     registers are dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
            uint32_t            : 5;
      __IOM uint32_t FMCEN      : 1;            /*!< [31..31] FMC controller Enable This bit enables/disables the
                                                     FMC controller. Note: The FMCEN bit of the FMC_BCR2..4
                                                     registers is dont care. It is only enabled through the
                                                     FMC_BCR1 register.                                                        */
    } FMC_BCR4_b;
  } ;
  
  union {
    __IOM uint32_t FMC_BTR4;                    /*!< (@ 0x0000001C) This register contains the control information
                                                                    of each memory bank, used for SRAMs, PSRAM
                                                                    and NOR Flash memories.If the EXTMOD bit
                                                                    is set in the FMC_BCRx register, then this
                                                                    register is partitioned for write and read
                                                                    access, that is, 2 registers are available:
                                                                    one to configure read accesses (this register)
                                                                    and one to configure write accesses (FMC_BWTRx
                                                                    registers).                                                */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration These bits are written by
                                                     software to define the duration of the address setup phase
                                                     (refer to Figure81 to Figure93), used in SRAMs, ROMs and
                                                     asynchronous NOR Flash: For each access mode address setup
                                                     phase duration, please refer to the respective figure (refer
                                                     to Figure81 to Figure93). Note: In synchronous accesses,
                                                     this value is dont care. In Muxed mode or Mode D, the mini                */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in mode D or multiplexed
                                                     accesses: For each access mode address-hold phase duration,
                                                     please refer to the respective figure (Figure81 to Figure93).
                                                     Note: In synchronous accesses, this value is not used,
                                                     the address hold phase is always 1 memory clock                           */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous accesses: For each memory
                                                     type and access mode data-phase duration, please refer
                                                     to the respective figure (Figure81 to Figure93). Example:
                                                     Mode1, write access, DATAST=1: Data-phase duration= DATAST+1
                                                     = 2 KCK_FMC clock cycles. Note: In synchr                                 */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write-to-read
                                                     or read-to write transaction. The programmed bus turnaround
                                                     delay is inserted between an asynchronous read (in muxed
                                                     or mode D) or write transaction and any other asynchronous
                                                     /synchronous read/write from/to a static bank. If a read
                                                     operation is performed, the bank can be the same or a different           */
      __IOM uint32_t CLKDIV     : 4;            /*!< [23..20] Clock divide ratio (for FMC_CLK signal) These bits
                                                     define the period of FMC_CLK clock output signal, expressed
                                                     in number of KCK_FMC cycles: In asynchronous NOR Flash,
                                                     SRAM or PSRAM accesses, this value is dont care. Note:
                                                     Refer to Section20.6.5: Synchronous transactions for FMC_CLK
                                                     divider ratio formula)                                                    */
      __IOM uint32_t DATLAT     : 4;            /*!< [27..24] Data latency for synchronous memory For synchronous
                                                     access with read write burst mode enabled these bits define
                                                     the number of memory clock cycles                                         */
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode These bits specify the asynchronous access
                                                     modes as shown in the timing diagrams. They are taken into
                                                     account only when the EXTMOD bit in the FMC_BCRx register
                                                     is 1.                                                                     */
            uint32_t            : 2;
    } FMC_BTR4_b;
  } ;
  __IM  uint32_t  RESERVED[24];
  
  union {
    __IOM uint32_t FMC_PCR;                     /*!< (@ 0x00000080) NAND Flash control registers                               */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t PWAITEN    : 1;            /*!< [1..1] Wait feature enable bit. This bit enables the Wait feature
                                                     for the NAND Flash memory bank:                                           */
      __IOM uint32_t PBKEN      : 1;            /*!< [2..2] NAND Flash memory bank enable bit. This bit enables the
                                                     memory bank. Accessing a disabled memory bank causes an
                                                     ERROR on AXI bus                                                          */
            uint32_t            : 1;
      __IOM uint32_t PWID       : 2;            /*!< [5..4] Data bus width. These bits define the external memory
                                                     device width.                                                             */
      __IOM uint32_t ECCEN      : 1;            /*!< [6..6] ECC computation logic enable bit                                   */
            uint32_t            : 2;
      __IOM uint32_t TCLR       : 4;            /*!< [12..9] CLE to RE delay. These bits set time from CLE low to
                                                     RE low in number of KCK_FMC clock cycles. The time is give
                                                     by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC
                                                     where TKCK_FMC is the KCK_FMC clock period Note: Set is
                                                     MEMSET or ATTSET according to the addressed space.                        */
      __IOM uint32_t TAR        : 4;            /*!< [16..13] ALE to RE delay. These bits set time from ALE low to
                                                     RE low in number of KCK_FMC clock cycles. Time is: t_ar
                                                     = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock
                                                     period Note: Set is MEMSET or ATTSET according to the addressed
                                                     space.                                                                    */
      __IOM uint32_t ECCPS      : 3;            /*!< [19..17] ECC page size. These bits define the page size for
                                                     the extended ECC:                                                         */
            uint32_t            : 12;
    } FMC_PCR_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SR;                      /*!< (@ 0x00000084) This register contains information about the
                                                                    FIFO status and interrupt. The FMC features
                                                                    a FIFO that is used when writing to memories
                                                                    to transfer up to 16 words of data.This
                                                                    is used to quickly write to the FIFO and
                                                                    free the AXI bus for transactions to peripherals
                                                                    other than the FMC, while the FMC is draining
                                                                    its FIFO into the memory. One of these register
                                                                    bits indicates the status of the FIFO, for
                                                                    ECC purposes.The E                                         */
    
    struct {
      __IOM uint32_t IRS        : 1;            /*!< [0..0] Interrupt rising edge status The flag is set by hardware
                                                     and reset by software. Note: If this bit is written by
                                                     software to 1 it will be set.                                             */
      __IOM uint32_t ILS        : 1;            /*!< [1..1] Interrupt high-level status The flag is set by hardware
                                                     and reset by software.                                                    */
      __IOM uint32_t IFS        : 1;            /*!< [2..2] Interrupt falling edge status The flag is set by hardware
                                                     and reset by software. Note: If this bit is written by
                                                     software to 1 it will be set.                                             */
      __IOM uint32_t IREN       : 1;            /*!< [3..3] Interrupt rising edge detection enable bit                         */
      __IOM uint32_t ILEN       : 1;            /*!< [4..4] Interrupt high-level detection enable bit                          */
      __IOM uint32_t IFEN       : 1;            /*!< [5..5] Interrupt falling edge detection enable bit                        */
      __IM  uint32_t FEMPT      : 1;            /*!< [6..6] FIFO empty. Read-only bit that provides the status of
                                                     the FIFO                                                                  */
            uint32_t            : 25;
    } FMC_SR_b;
  } ;
  
  union {
    __IOM uint32_t FMC_PMEM;                    /*!< (@ 0x00000088) The FMC_PMEM read/write register contains the
                                                                    timing information for NAND Flash memory
                                                                    bank. This information is used to access
                                                                    either the common memory space of the NAND
                                                                    Flash for command, address write access
                                                                    and data read/write access.                                */
    
    struct {
      __IOM uint32_t MEMSET     : 8;            /*!< [7..0] Common memory x setup time These bits define the number
                                                     of KCK_FMC (+1) clock cycles to set up the address before
                                                     the command assertion (NWE, NOE), for NAND Flash read or
                                                     write access to common memory space:                                      */
      __IOM uint32_t MEMWAIT    : 8;            /*!< [15..8] Common memory wait time These bits define the minimum
                                                     number of KCK_FMC (+1) clock cycles to assert the command
                                                     (NWE, NOE), for NAND Flash read or write access to common
                                                     memory space. The duration of command assertion is extended
                                                     if the wait signal (NWAIT) is active (low) at the end of
                                                     the programmed value of KCK_FMC:                                          */
      __IOM uint32_t MEMHOLD    : 8;            /*!< [23..16] Common memory hold time These bits define the number
                                                     of KCK_FMC clock cycles for write accesses and KCK_FMC+1
                                                     clock cycles for read accesses during which the address
                                                     is held (and data for write accesses) after the command
                                                     is de-asserted (NWE, NOE), for NAND Flash read or write
                                                     access to common memory space:                                            */
      __IOM uint32_t MEMHIZ     : 8;            /*!< [31..24] Common memory x data bus Hi-Z time These bits define
                                                     the number of KCK_FMC clock cycles during which the data
                                                     bus is kept Hi-Z after the start of a NAND Flash write
                                                     access to common memory space. This is only valid for write
                                                     transactions:                                                             */
    } FMC_PMEM_b;
  } ;
  
  union {
    __IOM uint32_t FMC_PATT;                    /*!< (@ 0x0000008C) The FMC_PATT read/write register contains the
                                                                    timing information for NAND Flash memory
                                                                    bank. It is used for 8-bit accesses to the
                                                                    attribute memory space of the NAND Flash
                                                                    for the last address write access if the
                                                                    timing must differ from that of previous
                                                                    accesses (for Ready/Busy management, refer
                                                                    to Section20.8.5: NAND Flash prewait feature).             */
    
    struct {
      __IOM uint32_t ATTSET     : 8;            /*!< [7..0] Attribute memory setup time These bits define the number
                                                     of KCK_FMC (+1) clock cycles to set up address before the
                                                     command assertion (NWE, NOE), for NAND Flash read or write
                                                     access to attribute memory space:                                         */
      __IOM uint32_t ATTWAIT    : 8;            /*!< [15..8] Attribute memory wait time These bits define the minimum
                                                     number of x KCK_FMC (+1) clock cycles to assert the command
                                                     (NWE, NOE), for NAND Flash read or write access to attribute
                                                     memory space. The duration for command assertion is extended
                                                     if the wait signal (NWAIT) is active (low) at the end of
                                                     the programmed value of KCK_FMC:                                          */
      __IOM uint32_t ATTHOLD    : 8;            /*!< [23..16] Attribute memory hold time These bits define the number
                                                     of KCK_FMC clock cycles during which the address is held
                                                     (and data for write access) after the command de-assertion
                                                     (NWE, NOE), for NAND Flash read or write access to attribute
                                                     memory space:                                                             */
      __IOM uint32_t ATTHIZ     : 8;            /*!< [31..24] Attribute memory data bus Hi-Z time These bits define
                                                     the number of KCK_FMC clock cycles during which the data
                                                     bus is kept in Hi-Z after the start of a NAND Flash write
                                                     access to attribute memory space on socket. Only valid
                                                     for writ transaction:                                                     */
    } FMC_PATT_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t FMC_ECCR;                    /*!< (@ 0x00000094) This register contain the current error correction
                                                                    code value computed by the ECC computation
                                                                    modules of the FMC NAND controller. When
                                                                    the CPU reads/writes the data from a NAND
                                                                    Flash memory page at the correct address
                                                                    (refer to Section20.8.6: Computation of
                                                                    the error correction code (ECC) in NAND
                                                                    Flash memory), the data read/written from/to
                                                                    the NAND Flash memory are processed automatically
                                                                    by the ECC computation mod                                 */
    
    struct {
      __IM  uint32_t ECC        : 32;           /*!< [31..0] ECC result This field contains the value computed by
                                                     the ECC computation logic. Table167 describes the contents
                                                     of these bit fields.                                                      */
    } FMC_ECCR_b;
  } ;
  __IM  uint32_t  RESERVED2[27];
  
  union {
    __IOM uint32_t FMC_BWTR1;                   /*!< (@ 0x00000104) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32_t            : 8;
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32_t            : 2;
    } FMC_BWTR1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t FMC_BWTR2;                   /*!< (@ 0x0000010C) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32_t            : 8;
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32_t            : 2;
    } FMC_BWTR2_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t FMC_BWTR3;                   /*!< (@ 0x00000114) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32_t            : 8;
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32_t            : 2;
    } FMC_BWTR3_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t FMC_BWTR4;                   /*!< (@ 0x0000011C) This register contains the control information
                                                                    of each memory bank. It is used for SRAMs,
                                                                    PSRAMs and NOR Flash memories. When the
                                                                    EXTMOD bit is set in the FMC_BCRx register,
                                                                    then this register is active for write access.             */
    
    struct {
      __IOM uint32_t ADDSET     : 4;            /*!< [3..0] Address setup phase duration. These bits are written
                                                     by software to define the duration of the address setup
                                                     phase in KCK_FMC cycles (refer to Figure81 to Figure93),
                                                     used in asynchronous accesses: ... Note: In synchronous
                                                     accesses, this value is not used, the address setup phase
                                                     is always 1 Flash clock period duration. In muxed mode,
                                                     the minimum ADDSET value is 1.                                            */
      __IOM uint32_t ADDHLD     : 4;            /*!< [7..4] Address-hold phase duration. These bits are written by
                                                     software to define the duration of the address hold phase
                                                     (refer to Figure81 to Figure93), used in asynchronous multiplexed
                                                     accesses: ... Note: In synchronous NOR Flash accesses,
                                                     this value is not used, the address hold phase is always
                                                     1 Flash clock period duration.                                            */
      __IOM uint32_t DATAST     : 8;            /*!< [15..8] Data-phase duration. These bits are written by software
                                                     to define the duration of the data phase (refer to Figure81
                                                     to Figure93), used in asynchronous SRAM, PSRAM and NOR
                                                     Flash memory accesses:                                                    */
      __IOM uint32_t BUSTURN    : 4;            /*!< [19..16] Bus turnaround phase duration These bits are written
                                                     by software to add a delay at the end of a write transaction
                                                     to match the minimum time between consecutive transactions
                                                     (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC
                                                     period &#8805; tEHELmin. The programmed bus turnaround
                                                     delay is inserted between a an asynchronous write transfer
                                                     and any other asynchronous /synchronous read or write                     */
            uint32_t            : 8;
      __IOM uint32_t ACCMOD     : 2;            /*!< [29..28] Access mode. These bits specify the asynchronous access
                                                     modes as shown in the next timing diagrams.These bits are
                                                     taken into account only when the EXTMOD bit in the FMC_BCRx
                                                     register is 1.                                                            */
            uint32_t            : 2;
    } FMC_BWTR4_b;
  } ;
  __IM  uint32_t  RESERVED6[8];
  
  union {
    __IOM uint32_t FMC_SDCR1;                   /*!< (@ 0x00000140) This register contains the control parameters
                                                                    for each SDRAM memory bank                                 */
    
    struct {
      __IOM uint32_t NC         : 2;            /*!< [1..0] Number of column address bits These bits define the number
                                                     of bits of a column address.                                              */
      __IOM uint32_t NR         : 2;            /*!< [3..2] Number of row address bits These bits define the number
                                                     of bits of a row address.                                                 */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width. These bits define the memory device
                                                     width.                                                                    */
      __IOM uint32_t NB         : 1;            /*!< [6..6] Number of internal banks This bit sets the number of
                                                     internal banks.                                                           */
      __IOM uint32_t CAS        : 2;            /*!< [8..7] CAS Latency This bits sets the SDRAM CAS latency in number
                                                     of memory clock cycles                                                    */
      __IOM uint32_t WP         : 1;            /*!< [9..9] Write protection This bit enables write mode access to
                                                     the SDRAM bank.                                                           */
      __IOM uint32_t SDCLK      : 2;            /*!< [11..10] SDRAM clock configuration These bits define the SDRAM
                                                     clock period for both SDRAM banks and allow disabling the
                                                     clock before changing the frequency. In this case the SDRAM
                                                     must be re-initialized. Note: The corresponding bits in
                                                     the FMC_SDCR2 register is read only.                                      */
      __IOM uint32_t RBURST     : 1;            /*!< [12..12] Burst read This bit enables burst read mode. The SDRAM
                                                     controller anticipates the next read commands during the
                                                     CAS latency and stores data in the Read FIFO. Note: The
                                                     corresponding bit in the FMC_SDCR2 register is read only.                 */
      __IOM uint32_t RPIPE      : 2;            /*!< [14..13] Read pipe These bits define the delay, in KCK_FMC clock
                                                     cycles, for reading data after CAS latency. Note: The corresponding
                                                     bits in the FMC_SDCR2 register is read only.                              */
            uint32_t            : 17;
    } FMC_SDCR1_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SDCR2;                   /*!< (@ 0x00000144) This register contains the control parameters
                                                                    for each SDRAM memory bank                                 */
    
    struct {
      __IOM uint32_t NC         : 2;            /*!< [1..0] Number of column address bits These bits define the number
                                                     of bits of a column address.                                              */
      __IOM uint32_t NR         : 2;            /*!< [3..2] Number of row address bits These bits define the number
                                                     of bits of a row address.                                                 */
      __IOM uint32_t MWID       : 2;            /*!< [5..4] Memory data bus width. These bits define the memory device
                                                     width.                                                                    */
      __IOM uint32_t NB         : 1;            /*!< [6..6] Number of internal banks This bit sets the number of
                                                     internal banks.                                                           */
      __IOM uint32_t CAS        : 2;            /*!< [8..7] CAS Latency This bits sets the SDRAM CAS latency in number
                                                     of memory clock cycles                                                    */
      __IOM uint32_t WP         : 1;            /*!< [9..9] Write protection This bit enables write mode access to
                                                     the SDRAM bank.                                                           */
      __IOM uint32_t SDCLK      : 2;            /*!< [11..10] SDRAM clock configuration These bits define the SDRAM
                                                     clock period for both SDRAM banks and allow disabling the
                                                     clock before changing the frequency. In this case the SDRAM
                                                     must be re-initialized. Note: The corresponding bits in
                                                     the FMC_SDCR2 register is read only.                                      */
      __IOM uint32_t RBURST     : 1;            /*!< [12..12] Burst read This bit enables burst read mode. The SDRAM
                                                     controller anticipates the next read commands during the
                                                     CAS latency and stores data in the Read FIFO. Note: The
                                                     corresponding bit in the FMC_SDCR2 register is read only.                 */
      __IOM uint32_t RPIPE      : 2;            /*!< [14..13] Read pipe These bits define the delay, in KCK_FMC clock
                                                     cycles, for reading data after CAS latency. Note: The corresponding
                                                     bits in the FMC_SDCR2 register is read only.                              */
            uint32_t            : 17;
    } FMC_SDCR2_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SDTR1;                   /*!< (@ 0x00000148) This register contains the timing parameters
                                                                    of each SDRAM bank                                         */
    
    struct {
      __IOM uint32_t TMRD       : 4;            /*!< [3..0] Load Mode Register to Active These bits define the delay
                                                     between a Load Mode Register command and an Active or Refresh
                                                     command in number of memory clock cycles. ....                            */
      __IOM uint32_t TXSR       : 4;            /*!< [7..4] Exit Self-refresh delay These bits define the delay from
                                                     releasing the Self-refresh command to issuing the Activate
                                                     command in number of memory clock cycles. .... Note: If
                                                     two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2
                                                     must be programmed with the same TXSR timing corresponding
                                                     to the slowest SDRAM device.                                              */
      __IOM uint32_t TRAS       : 4;            /*!< [11..8] Self refresh time These bits define the minimum Self-refresh
                                                     period in number of memory clock cycles. ....                             */
      __IOM uint32_t TRC        : 4;            /*!< [15..12] Row cycle delay These bits define the delay between
                                                     the Refresh command and the Activate command, as well as
                                                     the delay between two consecutive Refresh commands. It
                                                     is expressed in number of memory clock cycles. The TRC
                                                     timing is only configured in the FMC_SDTR1 register. If
                                                     two SDRAM devices are used, the TRC must be programmed
                                                     with the timings of the slowest device. .... Note: TRC
                                                     must match the TRC                                                        */
      __IOM uint32_t TWR        : 4;            /*!< [19..16] Recovery delay These bits define the delay between
                                                     a Write and a Precharge command in number of memory clock
                                                     cycles. .... Note: TWR must be programmed to match the
                                                     write recovery time (tWR) defined in the SDRAM datasheet,
                                                     and to guarantee that: TWR &#8805; TRAS - TRCD and TWR
                                                     &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD=
                                                     2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed
                                                     to                                                                        */
      __IOM uint32_t TRP        : 4;            /*!< [23..20] Row precharge delay These bits define the delay between
                                                     a Precharge command and another command in number of memory
                                                     clock cycles. The TRP timing is only configured in the
                                                     FMC_SDTR1 register. If two SDRAM devices are used, the
                                                     TRP must be programmed with the timing of the slowest device.
                                                     .... Note: The corresponding bits in the FMC_SDTR2 register
                                                     are dont care.                                                            */
      __IOM uint32_t TRCD       : 4;            /*!< [27..24] Row to column delay These bits define the delay between
                                                     the Activate command and a Read/Write command in number
                                                     of memory clock cycles. ....                                              */
            uint32_t            : 4;
    } FMC_SDTR1_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SDTR2;                   /*!< (@ 0x0000014C) This register contains the timing parameters
                                                                    of each SDRAM bank                                         */
    
    struct {
      __IOM uint32_t TMRD       : 4;            /*!< [3..0] Load Mode Register to Active These bits define the delay
                                                     between a Load Mode Register command and an Active or Refresh
                                                     command in number of memory clock cycles. ....                            */
      __IOM uint32_t TXSR       : 4;            /*!< [7..4] Exit Self-refresh delay These bits define the delay from
                                                     releasing the Self-refresh command to issuing the Activate
                                                     command in number of memory clock cycles. .... Note: If
                                                     two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2
                                                     must be programmed with the same TXSR timing corresponding
                                                     to the slowest SDRAM device.                                              */
      __IOM uint32_t TRAS       : 4;            /*!< [11..8] Self refresh time These bits define the minimum Self-refresh
                                                     period in number of memory clock cycles. ....                             */
      __IOM uint32_t TRC        : 4;            /*!< [15..12] Row cycle delay These bits define the delay between
                                                     the Refresh command and the Activate command, as well as
                                                     the delay between two consecutive Refresh commands. It
                                                     is expressed in number of memory clock cycles. The TRC
                                                     timing is only configured in the FMC_SDTR1 register. If
                                                     two SDRAM devices are used, the TRC must be programmed
                                                     with the timings of the slowest device. .... Note: TRC
                                                     must match the TRC                                                        */
      __IOM uint32_t TWR        : 4;            /*!< [19..16] Recovery delay These bits define the delay between
                                                     a Write and a Precharge command in number of memory clock
                                                     cycles. .... Note: TWR must be programmed to match the
                                                     write recovery time (tWR) defined in the SDRAM datasheet,
                                                     and to guarantee that: TWR &#8805; TRAS - TRCD and TWR
                                                     &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD=
                                                     2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed
                                                     to                                                                        */
      __IOM uint32_t TRP        : 4;            /*!< [23..20] Row precharge delay These bits define the delay between
                                                     a Precharge command and another command in number of memory
                                                     clock cycles. The TRP timing is only configured in the
                                                     FMC_SDTR1 register. If two SDRAM devices are used, the
                                                     TRP must be programmed with the timing of the slowest device.
                                                     .... Note: The corresponding bits in the FMC_SDTR2 register
                                                     are dont care.                                                            */
      __IOM uint32_t TRCD       : 4;            /*!< [27..24] Row to column delay These bits define the delay between
                                                     the Activate command and a Read/Write command in number
                                                     of memory clock cycles. ....                                              */
            uint32_t            : 4;
    } FMC_SDTR2_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SDCMR;                   /*!< (@ 0x00000150) This register contains the command issued when
                                                                    the SDRAM device is accessed. This register
                                                                    is used to initialize the SDRAM device,
                                                                    and to activate the Self-refresh and the
                                                                    Power-down modes. As soon as the MODE field
                                                                    is written, the command will be issued only
                                                                    to one or to both SDRAM banks according
                                                                    to CTB1 and CTB2 command bits. This register
                                                                    is the same for both SDRAM banks.                          */
    
    struct {
      __IOM uint32_t MODE       : 3;            /*!< [2..0] Command mode These bits define the command issued to
                                                     the SDRAM device. Note: When a command is issued, at least
                                                     one Command Target Bank bit ( CTB1 or CTB2) must be set
                                                     otherwise the command will be ignored. Note: If two SDRAM
                                                     banks are used, the Auto-refresh and PALL command must
                                                     be issued simultaneously to the two devices with CTB1 and
                                                     CTB2 bits set otherwise the command will be ignored. Note:
                                                                                                                               */
      __IOM uint32_t CTB2       : 1;            /*!< [3..3] Command Target Bank 2 This bit indicates whether the
                                                     command will be issued to SDRAM Bank 2 or not.                            */
      __IOM uint32_t CTB1       : 1;            /*!< [4..4] Command Target Bank 1 This bit indicates whether the
                                                     command will be issued to SDRAM Bank 1 or not.                            */
      __IOM uint32_t NRFS       : 4;            /*!< [8..5] Number of Auto-refresh These bits define the number of
                                                     consecutive Auto-refresh commands issued when MODE = 011.
                                                     ....                                                                      */
      __IOM uint32_t MRD        : 14;           /*!< [22..9] Mode Register definition This 14-bit field defines the
                                                     SDRAM Mode Register content. The Mode Register is programmed
                                                     using the Load Mode Register command. The MRD[13:0] bits
                                                     are also used to program the extended mode register for
                                                     mobile SDRAM.                                                             */
            uint32_t            : 9;
    } FMC_SDCMR_b;
  } ;
  
  union {
    __IOM uint32_t FMC_SDRTR;                   /*!< (@ 0x00000154) This register sets the refresh rate in number
                                                                    of SDCLK clock cycles between the refresh
                                                                    cycles by configuring the Refresh Timer
                                                                    Count value.Examplewhere 64 ms is the SDRAM
                                                                    refresh period.The refresh rate must be
                                                                    increased by 20 SDRAM clock cycles (as in
                                                                    the above example) to obtain a safe margin
                                                                    if an internal refresh request occurs when
                                                                    a read request has been accepted. It corresponds
                                                                    to a COUNT value of 0000111000                             */
    
    struct {
      __OM  uint32_t CRE        : 1;            /*!< [0..0] Clear Refresh error flag This bit is used to clear the
                                                     Refresh Error Flag (RE) in the Status Register.                           */
      __IOM uint32_t COUNT      : 13;           /*!< [13..1] Refresh Timer Count This 13-bit field defines the refresh
                                                     rate of the SDRAM device. It is expressed in number of
                                                     memory clock cycles. It must be set at least to 41 SDRAM
                                                     clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM
                                                     frequency clock COUNT = (SDRAM refresh period / Number
                                                     of rows) - 20                                                             */
      __IOM uint32_t REIE       : 1;            /*!< [14..14] RES Interrupt Enable                                             */
            uint32_t            : 17;
    } FMC_SDRTR_b;
  } ;
  
  union {
    __IM  uint32_t FMC_SDSR;                    /*!< (@ 0x00000158) SDRAM Status register                                      */
    
    struct {
      __IM  uint32_t RE         : 1;            /*!< [0..0] Refresh error flag An interrupt is generated if REIE
                                                     = 1 and RE = 1                                                            */
      __IM  uint32_t MODES1     : 2;            /*!< [2..1] Status Mode for Bank 1 These bits define the Status Mode
                                                     of SDRAM Bank 1.                                                          */
      __IM  uint32_t MODES2     : 2;            /*!< [4..3] Status Mode for Bank 2 These bits define the Status Mode
                                                     of SDRAM Bank 2.                                                          */
            uint32_t            : 27;
    } FMC_SDSR_b;
  } ;
} FMC_Type;                                     /*!< Size = 348 (0x15c)                                                        */



/* =========================================================================================================================== */
/* ================                                            CEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief CEC (CEC)
  */

typedef struct {                                /*!< (@ 0x40006C00) CEC Structure                                              */
  
  union {
    __IOM uint32_t CEC_CR;                      /*!< (@ 0x00000000) CEC control register                                       */
    
    struct {
      __IOM uint32_t CECEN      : 1;            /*!< [0..0] CEC Enable The CECEN bit is set and cleared by software.
                                                     CECEN=1 starts message reception and enables the TXSOM
                                                     control. CECEN=0 disables the CEC peripheral, clears all
                                                     bits of CEC_CR register and aborts any on-going reception
                                                     or transmission.                                                          */
      __IOM uint32_t TXSOM      : 1;            /*!< [1..1] Tx Start Of Message TXSOM is set by software to command
                                                     transmission of the first byte of a CEC message. If the
                                                     CEC message consists of only one byte, TXEOM must be set
                                                     before of TXSOM. Start-Bit is effectively started on the
                                                     CEC line after SFT is counted. If TXSOM is set while a
                                                     message reception is ongoing, transmission will start after
                                                     the end of reception. TXSOM is cleared by hardware                        */
      __IOM uint32_t TXEOM      : 1;            /*!< [2..2] Tx End Of Message The TXEOM bit is set by software to
                                                     command transmission of the last byte of a CEC message.
                                                     TXEOM is cleared by hardware at the same time and under
                                                     the same conditions as for TXSOM. Note: TXEOM must be set
                                                     when CECEN=1 TXEOM must be set before writing transmission
                                                     data to TXDR If TXEOM is set when TXSOM=0, transmitted
                                                     message will consist of 1 byte (HEADER) only (PING message)               */
            uint32_t            : 29;
    } CEC_CR_b;
  } ;
  
  union {
    __IOM uint32_t CEC_CFGR;                    /*!< (@ 0x00000004) This register is used to configure the HDMI-CEC
                                                                    controller. It is mandatory to write CEC_CFGR
                                                                    only when CECEN=0.                                         */
    
    struct {
      __IOM uint32_t SFT        : 3;            /*!< [2..0] Signal Free Time SFT bits are set by software. In the
                                                     SFT=0x0 configuration the number of nominal data bit periods
                                                     waited before transmission is ruled by hardware according
                                                     to the transmission history. In all the other configurations
                                                     the SFT number is determined by software. * 0x0 ** 2.5
                                                     Data-Bit periods if CEC is the last bus initiator with
                                                     unsuccessful transmission (ARBLST=1, TXERR=1, T                           */
      __IOM uint32_t RXTOL      : 1;            /*!< [3..3] Rx-Tolerance The RXTOL bit is set and cleared by software.
                                                     ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit:
                                                     +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s
                                                     rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500
                                                     s fall                                                                    */
      __IOM uint32_t BRESTP     : 1;            /*!< [4..4] Rx-Stop on Bit Rising Error The BRESTP bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t BREGEN     : 1;            /*!< [5..5] Generate Error-Bit on Bit Rising Error The BREGEN bit
                                                     is set and cleared by software. Note: If BRDNOGEN=0, an
                                                     Error-bit is generated upon BRE detection with BRESTP=1
                                                     in broadcast even if BREGEN=0                                             */
      __IOM uint32_t LBPEGEN    : 1;            /*!< [6..6] Generate Error-Bit on Long Bit Period Error The LBPEGEN
                                                     bit is set and cleared by software. Note: If BRDNOGEN=0,
                                                     an Error-bit is generated upon LBPE detection in broadcast
                                                     even if LBPEGEN=0                                                         */
      __IOM uint32_t BRDNOGEN   : 1;            /*!< [7..7] Avoid Error-Bit Generation in Broadcast The BRDNOGEN
                                                     bit is set and cleared by software.                                       */
      __IOM uint32_t SFTOPT     : 1;            /*!< [8..8] SFT Option Bit The SFTOPT bit is set and cleared by software.      */
            uint32_t            : 7;
      __IOM uint32_t OAR        : 15;           /*!< [30..16] Own addresses configuration The OAR bits are set by
                                                     software to select which destination logical addresses
                                                     has to be considered in receive mode. Each bit, when set,
                                                     enables the CEC logical address identified by the given
                                                     bit position. At the end of HEADER reception, the received
                                                     destination address is compared with the enabled addresses.
                                                     In case of matching address, the incoming message is                      */
      __IOM uint32_t LSTN       : 1;            /*!< [31..31] Listen mode LSTN bit is set and cleared by software.             */
    } CEC_CFGR_b;
  } ;
  
  union {
    __OM  uint32_t CEC_TXDR;                    /*!< (@ 0x00000008) CEC Tx data register                                       */
    
    struct {
      __OM  uint32_t TXD        : 8;            /*!< [7..0] Tx Data register. TXD is a write-only register containing
                                                     the data byte to be transmitted. Note: TXD must be written
                                                     when TXSTART=1                                                            */
            uint32_t            : 24;
    } CEC_TXDR_b;
  } ;
  
  union {
    __IM  uint32_t CEC_RXDR;                    /*!< (@ 0x0000000C) CEC Rx Data Register                                       */
    
    struct {
      __IM  uint32_t RXD        : 8;            /*!< [7..0] Rx Data register. RXD is read-only and contains the last
                                                     data byte which has been received from the CEC line.                      */
            uint32_t            : 24;
    } CEC_RXDR_b;
  } ;
  
  union {
    __IOM uint32_t CEC_ISR;                     /*!< (@ 0x00000010) CEC Interrupt and Status Register                          */
    
    struct {
      __IOM uint32_t RXBR       : 1;            /*!< [0..0] Rx-Byte Received The RXBR bit is set by hardware to inform
                                                     application that a new byte has been received from the
                                                     CEC line and stored into the RXD buffer. RXBR is cleared
                                                     by software write at 1.                                                   */
      __IOM uint32_t RXEND      : 1;            /*!< [1..1] End Of Reception RXEND is set by hardware to inform application
                                                     that the last byte of a CEC message is received from the
                                                     CEC line and stored into the RXD buffer. RXEND is set at
                                                     the same time of RXBR. RXEND is cleared by software write
                                                     at 1.                                                                     */
      __IOM uint32_t RXOVR      : 1;            /*!< [2..2] Rx-Overrun RXOVR is set by hardware if RXBR is not yet
                                                     cleared at the time a new byte is received on the CEC line
                                                     and stored into RXD. RXOVR assertion stops message reception
                                                     so that no acknowledge is sent. In case of broadcast, a
                                                     negative acknowledge is sent. RXOVR is cleared by software
                                                     write at 1.                                                               */
      __IOM uint32_t BRE        : 1;            /*!< [3..3] Rx-Bit Rising Error BRE is set by hardware in case a
                                                     Data-Bit waveform is detected with Bit Rising Error. BRE
                                                     is set either at the time the misplaced rising edge occurs,
                                                     or at the end of the maximum BRE tolerance allowed by RXTOL,
                                                     in case rising edge is still longing. BRE stops message
                                                     reception if BRESTP=1. BRE generates an Error-Bit on the
                                                     CEC line if BREGEN=1. BRE is cleared by software                          */
      __IOM uint32_t SBPE       : 1;            /*!< [4..4] Rx-Short Bit Period Error SBPE is set by hardware in
                                                     case a Data-Bit waveform is detected with Short Bit Period
                                                     Error. SBPE is set at the time the anticipated falling
                                                     edge occurs. SBPE generates an Error-Bit on the CEC line.
                                                     SBPE is cleared by software write at 1.                                   */
      __IOM uint32_t LBPE       : 1;            /*!< [5..5] Rx-Long Bit Period Error LBPE is set by hardware in case
                                                     a Data-Bit waveform is detected with Long Bit Period Error.
                                                     LBPE is set at the end of the maximum bit-extension tolerance
                                                     allowed by RXTOL, in case falling edge is still longing.
                                                     LBPE always stops reception of the CEC message. LBPE generates
                                                     an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast,
                                                     Error-Bit is generated even in case of                                    */
      __IOM uint32_t RXACKE     : 1;            /*!< [6..6] Rx-Missing Acknowledge In receive mode, RXACKE is set
                                                     by hardware to inform application that no acknowledge was
                                                     seen on the CEC line. RXACKE applies only for broadcast
                                                     messages and in listen mode also for not directly addressed
                                                     messages (destination address not enabled in OAR). RXACKE
                                                     aborts message reception. RXACKE is cleared by software
                                                     write at 1.                                                               */
      __IOM uint32_t ARBLST     : 1;            /*!< [7..7] Arbitration Lost ARBLST is set by hardware to inform
                                                     application that CEC device is switching to reception due
                                                     to arbitration lost event following the TXSOM command.
                                                     ARBLST can be due either to a contending CEC device starting
                                                     earlier or starting at the same time but with higher HEADER
                                                     priority. After ARBLST assertion TXSOM bit keeps pending
                                                     for next transmission attempt. ARBLST is cleare                           */
      __IOM uint32_t TXBR       : 1;            /*!< [8..8] Tx-Byte Request TXBR is set by hardware to inform application
                                                     that the next transmission data has to be written to TXDR.
                                                     TXBR is set when the 4th bit of currently transmitted byte
                                                     is sent. Application must write the next byte to TXDR within
                                                     6 nominal data-bit periods before transmission underrun
                                                     error occurs (TXUDR). TXBR is cleared by software write
                                                     at 1.                                                                     */
      __IOM uint32_t TXEND      : 1;            /*!< [9..9] End of Transmission TXEND is set by hardware to inform
                                                     application that the last byte of the CEC message has been
                                                     successfully transmitted. TXEND clears the TXSOM and TXEOM
                                                     control bits. TXEND is cleared by software write at 1.                    */
      __IOM uint32_t TXUDR      : 1;            /*!< [10..10] Tx-Buffer Underrun In transmission mode, TXUDR is set
                                                     by hardware if application was not in time to load TXDR
                                                     before of next byte transmission. TXUDR aborts message
                                                     transmission and clears TXSOM and TXEOM control bits. TXUDR
                                                     is cleared by software write at 1                                         */
      __IOM uint32_t TXERR      : 1;            /*!< [11..11] Tx-Error In transmission mode, TXERR is set by hardware
                                                     if the CEC initiator detects low impedance on the CEC line
                                                     while it is released. TXERR aborts message transmission
                                                     and clears TXSOM and TXEOM controls. TXERR is cleared by
                                                     software write at 1.                                                      */
      __IOM uint32_t TXACKE     : 1;            /*!< [12..12] Tx-Missing Acknowledge Error In transmission mode,
                                                     TXACKE is set by hardware to inform application that no
                                                     acknowledge was received. In case of broadcast transmission,
                                                     TXACKE informs application that a negative acknowledge
                                                     was received. TXACKE aborts message transmission and clears
                                                     TXSOM and TXEOM controls. TXACKE is cleared by software
                                                     write at 1.                                                               */
            uint32_t            : 19;
    } CEC_ISR_b;
  } ;
  
  union {
    __IOM uint32_t CEC_IER;                     /*!< (@ 0x00000014) CEC interrupt enable register                              */
    
    struct {
      __IOM uint32_t RXBRIE     : 1;            /*!< [0..0] Rx-Byte Received Interrupt Enable The RXBRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t RXENDIE    : 1;            /*!< [1..1] End Of Reception Interrupt Enable The RXENDIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t RXOVRIE    : 1;            /*!< [2..2] Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BREIE      : 1;            /*!< [3..3] Bit Rising Error Interrupt Enable The BREIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t SBPEIE     : 1;            /*!< [4..4] Short Bit Period Error Interrupt Enable The SBPEIE bit
                                                     is set and cleared by software.                                           */
      __IOM uint32_t LBPEIE     : 1;            /*!< [5..5] Long Bit Period Error Interrupt Enable The LBPEIE bit
                                                     is set and cleared by software.                                           */
      __IOM uint32_t RXACKIE    : 1;            /*!< [6..6] Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE
                                                     bit is set and cleared by software.                                       */
      __IOM uint32_t ARBLSTIE   : 1;            /*!< [7..7] Arbitration Lost Interrupt Enable The ARBLSTIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t TXBRIE     : 1;            /*!< [8..8] Tx-Byte Request Interrupt Enable The TXBRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t TXENDIE    : 1;            /*!< [9..9] Tx-End Of Message Interrupt Enable The TXENDIE bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t TXUDRIE    : 1;            /*!< [10..10] Tx-Underrun Interrupt Enable The TXUDRIE bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t TXERRIE    : 1;            /*!< [11..11] Tx-Error Interrupt Enable The TXERRIE bit is set and
                                                     cleared by software.                                                      */
      __IOM uint32_t TXACKIE    : 1;            /*!< [12..12] Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE
                                                     bit is set and cleared by software.                                       */
            uint32_t            : 19;
    } CEC_IER_b;
  } ;
} CEC_Type;                                     /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           HSEM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief HSEM (HSEM)
  */

typedef struct {                                /*!< (@ 0x58026400) HSEM Structure                                             */
  
  union {
    __IOM uint32_t HSEM_R0;                     /*!< (@ 0x00000000) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R0_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R1;                     /*!< (@ 0x00000004) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R1_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R2;                     /*!< (@ 0x00000008) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R2_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R3;                     /*!< (@ 0x0000000C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R3_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R4;                     /*!< (@ 0x00000010) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R4_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R5;                     /*!< (@ 0x00000014) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R5_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R6;                     /*!< (@ 0x00000018) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R6_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R7;                     /*!< (@ 0x0000001C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R7_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R8;                     /*!< (@ 0x00000020) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R8_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R9;                     /*!< (@ 0x00000024) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R9_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R10;                    /*!< (@ 0x00000028) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R10_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R11;                    /*!< (@ 0x0000002C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R11_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R12;                    /*!< (@ 0x00000030) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R12_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R13;                    /*!< (@ 0x00000034) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R13_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R14;                    /*!< (@ 0x00000038) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R14_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R15;                    /*!< (@ 0x0000003C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R15_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R16;                    /*!< (@ 0x00000040) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R16_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R17;                    /*!< (@ 0x00000044) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R17_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R18;                    /*!< (@ 0x00000048) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R18_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R19;                    /*!< (@ 0x0000004C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R19_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R20;                    /*!< (@ 0x00000050) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R20_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R21;                    /*!< (@ 0x00000054) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R21_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R22;                    /*!< (@ 0x00000058) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R22_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R23;                    /*!< (@ 0x0000005C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R23_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R24;                    /*!< (@ 0x00000060) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R24_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R25;                    /*!< (@ 0x00000064) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R25_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R26;                    /*!< (@ 0x00000068) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R26_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R27;                    /*!< (@ 0x0000006C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R27_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R28;                    /*!< (@ 0x00000070) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R28_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R29;                    /*!< (@ 0x00000074) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R29_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R30;                    /*!< (@ 0x00000078) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R30_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_R31;                    /*!< (@ 0x0000007C) HSEM register HSEM_R0 HSEM_R31                             */
    
    struct {
      __IOM uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IOM uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_R31_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR0;                   /*!< (@ 0x00000080) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR0_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR1;                   /*!< (@ 0x00000084) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR1_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR2;                   /*!< (@ 0x00000088) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR2_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR3;                   /*!< (@ 0x0000008C) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR3_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR4;                   /*!< (@ 0x00000090) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR4_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR5;                   /*!< (@ 0x00000094) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR5_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR6;                   /*!< (@ 0x00000098) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR6_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR7;                   /*!< (@ 0x0000009C) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR7_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR8;                   /*!< (@ 0x000000A0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR8_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR9;                   /*!< (@ 0x000000A4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR9_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR10;                  /*!< (@ 0x000000A8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR10_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR11;                  /*!< (@ 0x000000AC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR11_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR12;                  /*!< (@ 0x000000B0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR12_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR13;                  /*!< (@ 0x000000B4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR13_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR14;                  /*!< (@ 0x000000B8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR14_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR15;                  /*!< (@ 0x000000BC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR15_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR16;                  /*!< (@ 0x000000C0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR16_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR17;                  /*!< (@ 0x000000C4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR17_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR18;                  /*!< (@ 0x000000C8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR18_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR19;                  /*!< (@ 0x000000CC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR19_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR20;                  /*!< (@ 0x000000D0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR20_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR21;                  /*!< (@ 0x000000D4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR21_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR22;                  /*!< (@ 0x000000D8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR22_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR23;                  /*!< (@ 0x000000DC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR23_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR24;                  /*!< (@ 0x000000E0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR24_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR25;                  /*!< (@ 0x000000E4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR25_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR26;                  /*!< (@ 0x000000E8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR26_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR27;                  /*!< (@ 0x000000EC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR27_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR28;                  /*!< (@ 0x000000F0) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR28_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR29;                  /*!< (@ 0x000000F4) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR29_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR30;                  /*!< (@ 0x000000F8) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR30_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_RLR31;                  /*!< (@ 0x000000FC) HSEM Read lock register                                    */
    
    struct {
      __IM  uint32_t PROCID     : 8;            /*!< [7..0] Semaphore ProcessID                                                */
      __IM  uint32_t MASTERID   : 8;            /*!< [15..8] Semaphore MasterID                                                */
            uint32_t            : 15;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] Lock indication                                                  */
    } HSEM_RLR31_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_IER;                    /*!< (@ 0x00000100) HSEM Interrupt enable register                             */
    
    struct {
      __IOM uint32_t ISEM0      : 1;            /*!< [0..0] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM1      : 1;            /*!< [1..1] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM2      : 1;            /*!< [2..2] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM3      : 1;            /*!< [3..3] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM4      : 1;            /*!< [4..4] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM5      : 1;            /*!< [5..5] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM6      : 1;            /*!< [6..6] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM7      : 1;            /*!< [7..7] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM8      : 1;            /*!< [8..8] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM9      : 1;            /*!< [9..9] Interrupt semaphore n enable bit                                   */
      __IOM uint32_t ISEM10     : 1;            /*!< [10..10] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM11     : 1;            /*!< [11..11] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM12     : 1;            /*!< [12..12] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM13     : 1;            /*!< [13..13] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM14     : 1;            /*!< [14..14] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM15     : 1;            /*!< [15..15] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM16     : 1;            /*!< [16..16] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM17     : 1;            /*!< [17..17] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM18     : 1;            /*!< [18..18] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM19     : 1;            /*!< [19..19] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM20     : 1;            /*!< [20..20] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM21     : 1;            /*!< [21..21] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM22     : 1;            /*!< [22..22] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM23     : 1;            /*!< [23..23] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM24     : 1;            /*!< [24..24] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM25     : 1;            /*!< [25..25] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM26     : 1;            /*!< [26..26] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM27     : 1;            /*!< [27..27] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM28     : 1;            /*!< [28..28] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM29     : 1;            /*!< [29..29] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM30     : 1;            /*!< [30..30] Interrupt semaphore n enable bit                                 */
      __IOM uint32_t ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n enable bit.                             */
    } HSEM_IER_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_ICR;                    /*!< (@ 0x00000104) HSEM Interrupt clear register                              */
    
    struct {
      __IM  uint32_t ISEM0      : 1;            /*!< [0..0] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM1      : 1;            /*!< [1..1] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM2      : 1;            /*!< [2..2] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM3      : 1;            /*!< [3..3] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM4      : 1;            /*!< [4..4] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM5      : 1;            /*!< [5..5] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM6      : 1;            /*!< [6..6] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM7      : 1;            /*!< [7..7] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM8      : 1;            /*!< [8..8] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM9      : 1;            /*!< [9..9] Interrupt(N) semaphore n clear bit                                 */
      __IM  uint32_t ISEM10     : 1;            /*!< [10..10] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM11     : 1;            /*!< [11..11] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM12     : 1;            /*!< [12..12] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM13     : 1;            /*!< [13..13] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM14     : 1;            /*!< [14..14] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM15     : 1;            /*!< [15..15] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM16     : 1;            /*!< [16..16] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM17     : 1;            /*!< [17..17] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM18     : 1;            /*!< [18..18] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM19     : 1;            /*!< [19..19] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM20     : 1;            /*!< [20..20] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM21     : 1;            /*!< [21..21] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM22     : 1;            /*!< [22..22] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM23     : 1;            /*!< [23..23] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM24     : 1;            /*!< [24..24] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM25     : 1;            /*!< [25..25] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM26     : 1;            /*!< [26..26] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM27     : 1;            /*!< [27..27] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM28     : 1;            /*!< [28..28] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM29     : 1;            /*!< [29..29] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM30     : 1;            /*!< [30..30] Interrupt(N) semaphore n clear bit                               */
      __IM  uint32_t ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n clear bit                               */
    } HSEM_ICR_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_ISR;                    /*!< (@ 0x00000108) HSEM Interrupt status register                             */
    
    struct {
      __IM  uint32_t ISEM0      : 1;            /*!< [0..0] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM1      : 1;            /*!< [1..1] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM2      : 1;            /*!< [2..2] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM3      : 1;            /*!< [3..3] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM4      : 1;            /*!< [4..4] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM5      : 1;            /*!< [5..5] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM6      : 1;            /*!< [6..6] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM7      : 1;            /*!< [7..7] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM8      : 1;            /*!< [8..8] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM9      : 1;            /*!< [9..9] Interrupt(N) semaphore n status bit before enable (mask)           */
      __IM  uint32_t ISEM10     : 1;            /*!< [10..10] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM11     : 1;            /*!< [11..11] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM12     : 1;            /*!< [12..12] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM13     : 1;            /*!< [13..13] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM14     : 1;            /*!< [14..14] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM15     : 1;            /*!< [15..15] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM16     : 1;            /*!< [16..16] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM17     : 1;            /*!< [17..17] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM18     : 1;            /*!< [18..18] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM19     : 1;            /*!< [19..19] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM20     : 1;            /*!< [20..20] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM21     : 1;            /*!< [21..21] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM22     : 1;            /*!< [22..22] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM23     : 1;            /*!< [23..23] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM24     : 1;            /*!< [24..24] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM25     : 1;            /*!< [25..25] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM26     : 1;            /*!< [26..26] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM27     : 1;            /*!< [27..27] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM28     : 1;            /*!< [28..28] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM29     : 1;            /*!< [29..29] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM30     : 1;            /*!< [30..30] Interrupt(N) semaphore n status bit before enable (mask)         */
      __IM  uint32_t ISEM31     : 1;            /*!< [31..31] Interrupt(N) semaphore n status bit before enable (mask)         */
    } HSEM_ISR_b;
  } ;
  
  union {
    __IM  uint32_t HSEM_MISR;                   /*!< (@ 0x0000010C) HSEM Masked interrupt status register                      */
    
    struct {
      __IM  uint32_t ISEM0      : 1;            /*!< [0..0] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM1      : 1;            /*!< [1..1] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM2      : 1;            /*!< [2..2] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM3      : 1;            /*!< [3..3] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM4      : 1;            /*!< [4..4] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM5      : 1;            /*!< [5..5] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM6      : 1;            /*!< [6..6] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM7      : 1;            /*!< [7..7] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM8      : 1;            /*!< [8..8] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM9      : 1;            /*!< [9..9] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM10     : 1;            /*!< [10..10] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM11     : 1;            /*!< [11..11] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM12     : 1;            /*!< [12..12] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM13     : 1;            /*!< [13..13] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM14     : 1;            /*!< [14..14] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM15     : 1;            /*!< [15..15] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM16     : 1;            /*!< [16..16] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM17     : 1;            /*!< [17..17] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM18     : 1;            /*!< [18..18] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM19     : 1;            /*!< [19..19] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM20     : 1;            /*!< [20..20] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM21     : 1;            /*!< [21..21] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM22     : 1;            /*!< [22..22] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM23     : 1;            /*!< [23..23] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM24     : 1;            /*!< [24..24] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM25     : 1;            /*!< [25..25] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM26     : 1;            /*!< [26..26] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM27     : 1;            /*!< [27..27] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM28     : 1;            /*!< [28..28] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM29     : 1;            /*!< [29..29] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM30     : 1;            /*!< [30..30] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
      __IM  uint32_t ISEM31     : 1;            /*!< [31..31] masked interrupt(N) semaphore n status bit after enable
                                                     (mask)                                                                    */
    } HSEM_MISR_b;
  } ;
  __IM  uint32_t  RESERVED[12];
  
  union {
    __IOM uint32_t HSEM_CR;                     /*!< (@ 0x00000140) HSEM Clear register                                        */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t MASTERID   : 8;            /*!< [15..8] MasterID of semaphores to be cleared                              */
      __IOM uint32_t KEY        : 16;           /*!< [31..16] Semaphore clear Key                                              */
    } HSEM_CR_b;
  } ;
  
  union {
    __IOM uint32_t HSEM_KEYR;                   /*!< (@ 0x00000144) HSEM Interrupt clear register                              */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t KEY        : 16;           /*!< [31..16] Semaphore Clear Key                                              */
    } HSEM_KEYR_b;
  } ;
} HSEM_Type;                                    /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2C1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C (I2C1)
  */

typedef struct {                                /*!< (@ 0x40005400) I2C1 Structure                                             */
  
  union {
    __IOM uint32_t I2C_CR1;                     /*!< (@ 0x00000000) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32_t PE         : 1;            /*!< [0..0] Peripheral enable Note: When PE=0, the I2C SCL and SDA
                                                     lines are released. Internal state machines and status
                                                     bits are put back to their reset value. When cleared, PE
                                                     must be kept low for at least 3 APB clock cycles.                         */
      __IOM uint32_t TXIE       : 1;            /*!< [1..1] TX Interrupt enable                                                */
      __IOM uint32_t RXIE       : 1;            /*!< [2..2] RX Interrupt enable                                                */
      __IOM uint32_t ADDRIE     : 1;            /*!< [3..3] Address match Interrupt enable (slave only)                        */
      __IOM uint32_t NACKIE     : 1;            /*!< [4..4] Not acknowledge received Interrupt enable                          */
      __IOM uint32_t STOPIE     : 1;            /*!< [5..5] STOP detection Interrupt enable                                    */
      __IOM uint32_t TCIE       : 1;            /*!< [6..6] Transfer Complete interrupt enable Note: Any of these
                                                     events will generate an interrupt: Transfer Complete (TC)
                                                     Transfer Complete Reload (TCR)                                            */
      __IOM uint32_t ERRIE      : 1;            /*!< [7..7] Error interrupts enable Note: Any of these errors generate
                                                     an interrupt: Arbitration Loss (ARLO) Bus Error detection
                                                     (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT)
                                                     PEC error detection (PECERR) Alert pin event detection
                                                     (ALERT)                                                                   */
      __IOM uint32_t DNF        : 4;            /*!< [11..8] Digital noise filter These bits are used to configure
                                                     the digital noise filter on SDA and SCL input. The digital
                                                     filter will filter spikes with a length of up to DNF[3:0]
                                                     * tI2CCLK ... Note: If the analog filter is also enabled,
                                                     the digital filter is added to the analog filter. This
                                                     filter can only be programmed when the I2C is disabled
                                                     (PE = 0).                                                                 */
      __IOM uint32_t ANFOFF     : 1;            /*!< [12..12] Analog noise filter OFF Note: This bit can only be
                                                     programmed when the I2C is disabled (PE = 0).                             */
            uint32_t            : 1;
      __IOM uint32_t TXDMAEN    : 1;            /*!< [14..14] DMA transmission requests enable                                 */
      __IOM uint32_t RXDMAEN    : 1;            /*!< [15..15] DMA reception requests enable                                    */
      __IOM uint32_t SBC        : 1;            /*!< [16..16] Slave byte control This bit is used to enable hardware
                                                     byte control in slave mode.                                               */
      __IOM uint32_t NOSTRETCH  : 1;            /*!< [17..17] Clock stretching disable This bit is used to disable
                                                     clock stretching in slave mode. It must be kept cleared
                                                     in master mode. Note: This bit can only be programmed when
                                                     the I2C is disabled (PE = 0).                                             */
      __IOM uint32_t WUPEN      : 1;            /*!< [18..18] Wakeup from Stop mode enable Note: If the Wakeup from
                                                     Stop mode feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C implementation. Note: WUPEN can be set only when DNF
                                                     = 0000                                                                    */
      __IOM uint32_t GCEN       : 1;            /*!< [19..19] General call enable                                              */
      __IOM uint32_t SMBHEN     : 1;            /*!< [20..20] SMBus Host address enable Note: If the SMBus feature
                                                     is not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementation.                    */
      __IOM uint32_t SMBDEN     : 1;            /*!< [21..21] SMBus Device Default address enable Note: If the SMBus
                                                     feature is not supported, this bit is reserved and forced
                                                     by hardware to 0. Please refer to Section25.3: I2C implementation.        */
      __IOM uint32_t ALERTEN    : 1;            /*!< [22..22] SMBus alert enable Device mode (SMBHEN=0): Host mode
                                                     (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used
                                                     as a standard GPIO. If the SMBus feature is not supported,
                                                     this bit is reserved and forced by hardware to 0. Please
                                                     refer to Section25.3: I2C implementation.                                 */
      __IOM uint32_t PECEN      : 1;            /*!< [23..23] PEC enable Note: If the SMBus feature is not supported,
                                                     this bit is reserved and forced by hardware to 0. Please
                                                     refer to Section25.3: I2C implementation.                                 */
            uint32_t            : 8;
    } I2C_CR1_b;
  } ;
  
  union {
    __IOM uint32_t I2C_CR2;                     /*!< (@ 0x00000004) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32_t SADD0      : 1;            /*!< [0..0] Slave address bit 0 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): This bit is dont care In 10-bit addressing
                                                     mode (ADD10 = 1): This bit should be written with bit 0
                                                     of the slave address to be sent Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD1      : 1;            /*!< [1..1] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD2      : 1;            /*!< [2..2] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD3      : 1;            /*!< [3..3] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD4      : 1;            /*!< [4..4] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD5      : 1;            /*!< [5..5] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD6      : 1;            /*!< [6..6] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD7      : 1;            /*!< [7..7] Slave address bit 7:1 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits should be written with the
                                                     7-bit slave address to be sent In 10-bit addressing mode
                                                     (ADD10 = 1): These bits should be written with bits 7:1
                                                     of the slave address to be sent. Note: Changing these bits
                                                     when the START bit is set is not allowed.                                 */
      __IOM uint32_t SADD8      : 1;            /*!< [8..8] Slave address bit 9:8 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits are dont care In 10-bit addressing
                                                     mode (ADD10 = 1): These bits should be written with bits
                                                     9:8 of the slave address to be sent Note: Changing these
                                                     bits when the START bit is set is not allowed.                            */
      __IOM uint32_t SADD9      : 1;            /*!< [9..9] Slave address bit 9:8 (master mode) In 7-bit addressing
                                                     mode (ADD10 = 0): These bits are dont care In 10-bit addressing
                                                     mode (ADD10 = 1): These bits should be written with bits
                                                     9:8 of the slave address to be sent Note: Changing these
                                                     bits when the START bit is set is not allowed.                            */
      __IOM uint32_t RD_WRN     : 1;            /*!< [10..10] Transfer direction (master mode) Note: Changing this
                                                     bit when the START bit is set is not allowed.                             */
      __IOM uint32_t ADD10      : 1;            /*!< [11..11] 10-bit addressing mode (master mode) Note: Changing
                                                     this bit when the START bit is set is not allowed.                        */
      __IOM uint32_t HEAD10R    : 1;            /*!< [12..12] 10-bit address header only read direction (master receiver
                                                     mode) Note: Changing this bit when the START bit is set
                                                     is not allowed.                                                           */
      __IOM uint32_t START      : 1;            /*!< [13..13] Start generation This bit is set by software, and cleared
                                                     by hardware after the Start followed by the address sequence
                                                     is sent, by an arbitration loss, by a timeout error detection,
                                                     or when PE = 0. It can also be cleared by software by writing
                                                     1 to the ADDRCF bit in the I2C_ICR register. If the I2C
                                                     is already in master mode with AUTOEND = 0, setting this
                                                     bit generates a Repeated Start con                                        */
      __IOM uint32_t STOP       : 1;            /*!< [14..14] Stop generation (master mode) The bit is set by software,
                                                     cleared by hardware when a Stop condition is detected,
                                                     or when PE = 0. In Master Mode: Note: Writing 0 to this
                                                     bit has no effect.                                                        */
      __IOM uint32_t NACK       : 1;            /*!< [15..15] NACK generation (slave mode) The bit is set by software,
                                                     cleared by hardware when the NACK is sent, or when a STOP
                                                     condition or an Address matched is received, or when PE=0.
                                                     Note: Writing 0 to this bit has no effect. This bit is
                                                     used in slave mode only: in master receiver mode, NACK
                                                     is automatically generated after last byte preceding STOP
                                                     or RESTART condition, whatever the NACK bit value. When
                                                     an                                                                        */
      __IOM uint32_t NBYTES     : 8;            /*!< [23..16] Number of bytes The number of bytes to be transmitted/received
                                                     is programmed there. This field is dont care in slave mode
                                                     with SBC=0. Note: Changing these bits when the START bit
                                                     is set is not allowed.                                                    */
      __IOM uint32_t RELOAD     : 1;            /*!< [24..24] NBYTES reload mode This bit is set and cleared by software.      */
      __IOM uint32_t AUTOEND    : 1;            /*!< [25..25] Automatic end mode (master mode) This bit is set and
                                                     cleared by software. Note: This bit has no effect in slave
                                                     mode or when the RELOAD bit is set.                                       */
      __IOM uint32_t PECBYTE    : 1;            /*!< [26..26] Packet error checking byte This bit is set by software,
                                                     and cleared by hardware when the PEC is transferred, or
                                                     when a STOP condition or an Address matched is received,
                                                     also when PE=0. Note: Writing 0 to this bit has no effect.
                                                     This bit has no effect when RELOAD is set. This bit has
                                                     no effect is slave mode when SBC=0. If the SMBus feature
                                                     is not supported, this bit is reserved and forced by                      */
            uint32_t            : 5;
    } I2C_CR2_b;
  } ;
  
  union {
    __IOM uint32_t I2C_OAR1;                    /*!< (@ 0x00000008) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32_t OA1        : 10;           /*!< [9..0] Interface address 7-bit addressing mode: dont care 10-bit
                                                     addressing mode: bits 9:8 of address Note: These bits can
                                                     be written only when OA1EN=0. OA1[7:1]: Interface address
                                                     Bits 7:1 of address Note: These bits can be written only
                                                     when OA1EN=0. OA1[0]: Interface address 7-bit addressing
                                                     mode: dont care 10-bit addressing mode: bit 0 of address
                                                     Note: This bit can be written only when OA1EN=0.                          */
      __IOM uint32_t OA1MODE    : 1;            /*!< [10..10] Own Address 1 10-bit mode Note: This bit can be written
                                                     only when OA1EN=0.                                                        */
            uint32_t            : 4;
      __IOM uint32_t OA1EN      : 1;            /*!< [15..15] Own Address 1 enable                                             */
            uint32_t            : 16;
    } I2C_OAR1_b;
  } ;
  
  union {
    __IOM uint32_t I2C_OAR2;                    /*!< (@ 0x0000000C) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t OA2        : 7;            /*!< [7..1] Interface address bits 7:1 of address Note: These bits
                                                     can be written only when OA2EN=0.                                         */
      __IOM uint32_t OA2MSK     : 3;            /*!< [10..8] Own Address 2 masks Note: These bits can be written
                                                     only when OA2EN=0. As soon as OA2MSK is not equal to 0,
                                                     the reserved I2C addresses (0b0000xxx and 0b1111xxx) are
                                                     not acknowledged even if the comparison matches.                          */
            uint32_t            : 4;
      __IOM uint32_t OA2EN      : 1;            /*!< [15..15] Own Address 2 enable                                             */
            uint32_t            : 16;
    } I2C_OAR2_b;
  } ;
  
  union {
    __IOM uint32_t I2C_TIMINGR;                 /*!< (@ 0x00000010) Access: No wait states                                     */
    
    struct {
      __IOM uint32_t SCLL       : 8;            /*!< [7..0] SCL low period (master mode) This field is used to generate
                                                     the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC
                                                     Note: SCLL is also used to generate tBUF and tSU:STA timings.             */
      __IOM uint32_t SCLH       : 8;            /*!< [15..8] SCL high period (master mode) This field is used to
                                                     generate the SCL high period in master mode. tSCLH = (SCLH+1)
                                                     x tPRESC Note: SCLH is also used to generate tSU:STO and
                                                     tHD:STA timing.                                                           */
      __IOM uint32_t SDADEL     : 4;            /*!< [19..16] Data hold time This field is used to generate the delay
                                                     tSDADEL between SCL falling edge and SDA edge. In master
                                                     mode and in slave mode with NOSTRETCH = 0, the SCL line
                                                     is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC
                                                     Note: SDADEL is used to generate tHD:DAT timing.                          */
      __IOM uint32_t SCLDEL     : 4;            /*!< [23..20] Data setup time This field is used to generate a delay
                                                     tSCLDEL between SDA edge and SCL rising edge. In master
                                                     mode and in slave mode with NOSTRETCH = 0, the SCL line
                                                     is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x
                                                     tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.                  */
            uint32_t            : 4;
      __IOM uint32_t PRESC      : 4;            /*!< [31..28] Timing prescaler This field is used to prescale I2CCLK
                                                     in order to generate the clock period tPRESC used for data
                                                     setup and hold counters (refer to I2C timings on page9)
                                                     and for SCL high and low level counters (refer to I2C master
                                                     initialization on page24). tPRESC = (PRESC+1) x tI2CCLK                   */
    } I2C_TIMINGR_b;
  } ;
  
  union {
    __IOM uint32_t I2C_TIMEOUTR;                /*!< (@ 0x00000014) Access: No wait states, except if a write access
                                                                    occurs while a write access to this register
                                                                    is ongoing. In this case, wait states are
                                                                    inserted in the second write access until
                                                                    the previous one is completed. The latency
                                                                    of the second write access can be up to
                                                                    2 x PCLK1 + 6 x I2CCLK.                                    */
    
    struct {
      __IOM uint32_t TIMEOUTA   : 12;           /*!< [11..0] Bus Timeout A This field is used to configure: The SCL
                                                     low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1)
                                                     x 2048 x tI2CCLK The bus idle condition (both SCL and SDA
                                                     high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note:
                                                     These bits can be written only when TIMOUTEN=0.                           */
      __IOM uint32_t TIDLE      : 1;            /*!< [12..12] Idle clock timeout detection Note: This bit can be
                                                     written only when TIMOUTEN=0.                                             */
            uint32_t            : 2;
      __IOM uint32_t TIMOUTEN   : 1;            /*!< [15..15] Clock timeout enable                                             */
      __IOM uint32_t TIMEOUTB   : 12;           /*!< [27..16] Bus timeout B This field is used to configure the cumulative
                                                     clock extension timeout: In master mode, the master cumulative
                                                     clock low extend time (tLOW:MEXT) is detected In slave
                                                     mode, the slave cumulative clock low extend time (tLOW:SEXT)
                                                     is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note:
                                                     These bits can be written only when TEXTEN=0.                             */
            uint32_t            : 3;
      __IOM uint32_t TEXTEN     : 1;            /*!< [31..31] Extended clock timeout enable                                    */
    } I2C_TIMEOUTR_b;
  } ;
  
  union {
    __IOM uint32_t I2C_ISR;                     /*!< (@ 0x00000018) Access: No wait states                                     */
    
    struct {
      __IOM uint32_t TXE        : 1;            /*!< [0..0] Transmit data register empty (transmitters) This bit
                                                     is set by hardware when the I2C_TXDR register is empty.
                                                     It is cleared when the next data to be sent is written
                                                     in the I2C_TXDR register. This bit can be written to 1
                                                     by software in order to flush the transmit data register
                                                     I2C_TXDR. Note: This bit is set by hardware when PE=0.                    */
      __IOM uint32_t TXIS       : 1;            /*!< [1..1] Transmit interrupt status (transmitters) This bit is
                                                     set by hardware when the I2C_TXDR register is empty and
                                                     the data to be transmitted must be written in the I2C_TXDR
                                                     register. It is cleared when the next data to be sent is
                                                     written in the I2C_TXDR register. This bit can be written
                                                     to 1 by software when NOSTRETCH=1 only, in order to generate
                                                     a TXIS event (interrupt if TXIE=1 or DMA request if                       */
      __IM  uint32_t RXNE       : 1;            /*!< [2..2] Receive data register not empty (receivers) This bit
                                                     is set by hardware when the received data is copied into
                                                     the I2C_RXDR register, and is ready to be read. It is cleared
                                                     when I2C_RXDR is read. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32_t ADDR       : 1;            /*!< [3..3] Address matched (slave mode) This bit is set by hardware
                                                     as soon as the received slave address matched with one
                                                     of the enabled slave addresses. It is cleared by software
                                                     by setting ADDRCF bit. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32_t NACKF      : 1;            /*!< [4..4] Not Acknowledge received flag This flag is set by hardware
                                                     when a NACK is received after a byte transmission. It is
                                                     cleared by software by setting the NACKCF bit. Note: This
                                                     bit is cleared by hardware when PE=0.                                     */
      __IM  uint32_t STOPF      : 1;            /*!< [5..5] Stop detection flag This flag is set by hardware when
                                                     a Stop condition is detected on the bus and the peripheral
                                                     is involved in this transfer: either as a master, provided
                                                     that the STOP condition is generated by the peripheral.
                                                     or as a slave, provided that the peripheral has been addressed
                                                     previously during this transfer. It is cleared by software
                                                     by setting the STOPCF bit. Note: This bit is                              */
      __IM  uint32_t TC         : 1;            /*!< [6..6] Transfer Complete (master mode) This flag is set by hardware
                                                     when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred.
                                                     It is cleared by software when START bit or STOP bit is
                                                     set. Note: This bit is cleared by hardware when PE=0.                     */
      __IM  uint32_t TCR        : 1;            /*!< [7..7] Transfer Complete Reload This flag is set by hardware
                                                     when RELOAD=1 and NBYTES data have been transferred. It
                                                     is cleared by software when NBYTES is written to a non-zero
                                                     value. Note: This bit is cleared by hardware when PE=0.
                                                     This flag is only for master mode, or for slave mode when
                                                     the SBC bit is set.                                                       */
      __IM  uint32_t BERR       : 1;            /*!< [8..8] Bus error This flag is set by hardware when a misplaced
                                                     Start or Stop condition is detected whereas the peripheral
                                                     is involved in the transfer. The flag is not set during
                                                     the address phase in slave mode. It is cleared by software
                                                     by setting BERRCF bit. Note: This bit is cleared by hardware
                                                     when PE=0.                                                                */
      __IM  uint32_t ARLO       : 1;            /*!< [9..9] Arbitration lost This flag is set by hardware in case
                                                     of arbitration loss. It is cleared by software by setting
                                                     the ARLOCF bit. Note: This bit is cleared by hardware when
                                                     PE=0.                                                                     */
      __IM  uint32_t OVR        : 1;            /*!< [10..10] Overrun/Underrun (slave mode) This flag is set by hardware
                                                     in slave mode with NOSTRETCH=1, when an overrun/underrun
                                                     error occurs. It is cleared by software by setting the
                                                     OVRCF bit. Note: This bit is cleared by hardware when PE=0.               */
      __IM  uint32_t PECERR     : 1;            /*!< [11..11] PEC Error in reception This flag is set by hardware
                                                     when the received PEC does not match with the PEC register
                                                     content. A NACK is automatically sent after the wrong PEC
                                                     reception. It is cleared by software by setting the PECCF
                                                     bit. Note: This bit is cleared by hardware when PE=0. If
                                                     the SMBus feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C                                                                       */
      __IM  uint32_t TIMEOUT    : 1;            /*!< [12..12] Timeout or tLOW detection flag This flag is set by
                                                     hardware when a timeout or extended clock timeout occurred.
                                                     It is cleared by software by setting the TIMEOUTCF bit.
                                                     Note: This bit is cleared by hardware when PE=0. If the
                                                     SMBus feature is not supported, this bit is reserved and
                                                     forced by hardware to 0. Please refer to Section25.3: I2C
                                                     implementation.                                                           */
      __IM  uint32_t ALERT      : 1;            /*!< [13..13] SMBus alert This flag is set by hardware when SMBHEN=1
                                                     (SMBus host configuration), ALERTEN=1 and a SMBALERT event
                                                     (falling edge) is detected on SMBA pin. It is cleared by
                                                     software by setting the ALERTCF bit. Note: This bit is
                                                     cleared by hardware when PE=0. If the SMBus feature is
                                                     not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementati                       */
            uint32_t            : 1;
      __IM  uint32_t BUSY       : 1;            /*!< [15..15] Bus busy This flag indicates that a communication is
                                                     in progress on the bus. It is set by hardware when a START
                                                     condition is detected. It is cleared by hardware when a
                                                     Stop condition is detected, or when PE=0.                                 */
      __IM  uint32_t DIR        : 1;            /*!< [16..16] Transfer direction (Slave mode) This flag is updated
                                                     when an address match event occurs (ADDR=1).                              */
      __IM  uint32_t ADDCODE    : 7;            /*!< [23..17] Address match code (Slave mode) These bits are updated
                                                     with the received address when an address match event occurs
                                                     (ADDR = 1). In the case of a 10-bit address, ADDCODE provides
                                                     the 10-bit header followed by the 2 MSBs of the address.                  */
            uint32_t            : 8;
    } I2C_ISR_b;
  } ;
  
  union {
    __OM  uint32_t I2C_ICR;                     /*!< (@ 0x0000001C) Access: No wait states                                     */
    
    struct {
            uint32_t            : 3;
      __OM  uint32_t ADDRCF     : 1;            /*!< [3..3] Address matched flag clear Writing 1 to this bit clears
                                                     the ADDR flag in the I2C_ISR register. Writing 1 to this
                                                     bit also clears the START bit in the I2C_CR2 register.                    */
      __OM  uint32_t NACKCF     : 1;            /*!< [4..4] Not Acknowledge flag clear Writing 1 to this bit clears
                                                     the ACKF flag in I2C_ISR register.                                        */
      __OM  uint32_t STOPCF     : 1;            /*!< [5..5] Stop detection flag clear Writing 1 to this bit clears
                                                     the STOPF flag in the I2C_ISR register.                                   */
            uint32_t            : 2;
      __OM  uint32_t BERRCF     : 1;            /*!< [8..8] Bus error flag clear Writing 1 to this bit clears the
                                                     BERRF flag in the I2C_ISR register.                                       */
      __OM  uint32_t ARLOCF     : 1;            /*!< [9..9] Arbitration Lost flag clear Writing 1 to this bit clears
                                                     the ARLO flag in the I2C_ISR register.                                    */
      __OM  uint32_t OVRCF      : 1;            /*!< [10..10] Overrun/Underrun flag clear Writing 1 to this bit clears
                                                     the OVR flag in the I2C_ISR register.                                     */
      __OM  uint32_t PECCF      : 1;            /*!< [11..11] PEC Error flag clear Writing 1 to this bit clears the
                                                     PECERR flag in the I2C_ISR register. Note: If the SMBus
                                                     feature is not supported, this bit is reserved and forced
                                                     by hardware to 0. Please refer to Section25.3: I2C implementation.        */
      __OM  uint32_t TIMOUTCF   : 1;            /*!< [12..12] Timeout detection flag clear Writing 1 to this bit
                                                     clears the TIMEOUT flag in the I2C_ISR register. Note:
                                                     If the SMBus feature is not supported, this bit is reserved
                                                     and forced by hardware to 0. Please refer to Section25.3:
                                                     I2C implementation.                                                       */
      __OM  uint32_t ALERTCF    : 1;            /*!< [13..13] Alert flag clear Writing 1 to this bit clears the ALERT
                                                     flag in the I2C_ISR register. Note: If the SMBus feature
                                                     is not supported, this bit is reserved and forced by hardware
                                                     to 0. Please refer to Section25.3: I2C implementation.                    */
            uint32_t            : 18;
    } I2C_ICR_b;
  } ;
  
  union {
    __IM  uint32_t I2C_PECR;                    /*!< (@ 0x00000020) Access: No wait states                                     */
    
    struct {
      __IM  uint32_t PEC        : 8;            /*!< [7..0] Packet error checking register This field contains the
                                                     internal PEC when PECEN=1. The PEC is cleared by hardware
                                                     when PE=0.                                                                */
            uint32_t            : 24;
    } I2C_PECR_b;
  } ;
  
  union {
    __IM  uint32_t I2C_RXDR;                    /*!< (@ 0x00000024) Access: No wait states                                     */
    
    struct {
      __IM  uint32_t RXDATA     : 8;            /*!< [7..0] 8-bit receive data Data byte received from the I2C bus.            */
            uint32_t            : 24;
    } I2C_RXDR_b;
  } ;
  
  union {
    __IOM uint32_t I2C_TXDR;                    /*!< (@ 0x00000028) Access: No wait states                                     */
    
    struct {
      __IOM uint32_t TXDATA     : 8;            /*!< [7..0] 8-bit transmit data Data byte to be transmitted to the
                                                     I2C bus. Note: These bits can be written only when TXE=1.                 */
            uint32_t            : 24;
    } I2C_TXDR_b;
  } ;
} I2C1_Type;                                    /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                           GPIOA                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO (GPIOA)
  */

typedef struct {                                /*!< (@ 0x58020000) GPIOA Structure                                            */
  
  union {
    __IOM uint32_t GPIO_MODER;                  /*!< (@ 0x00000000) GPIO port mode register                                    */
    
    struct {
      __IOM uint32_t MODE0      : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O mode.                        */
      __IOM uint32_t MODE1      : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O mode.                        */
      __IOM uint32_t MODE2      : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O mode.                        */
      __IOM uint32_t MODE3      : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O mode.                        */
      __IOM uint32_t MODE4      : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O mode.                        */
      __IOM uint32_t MODE5      : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE6      : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE7      : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE8      : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE9      : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE10     : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE11     : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE12     : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE13     : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE14     : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
      __IOM uint32_t MODE15     : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O mode.                   */
    } GPIO_MODER_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_OTYPER;                 /*!< (@ 0x00000004) GPIO port output type register                             */
    
    struct {
      __IOM uint32_t OT0        : 1;            /*!< [0..0] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT1        : 1;            /*!< [1..1] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT2        : 1;            /*!< [2..2] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT3        : 1;            /*!< [3..3] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT4        : 1;            /*!< [4..4] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT5        : 1;            /*!< [5..5] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT6        : 1;            /*!< [6..6] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT7        : 1;            /*!< [7..7] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT8        : 1;            /*!< [8..8] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT9        : 1;            /*!< [9..9] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT10       : 1;            /*!< [10..10] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT11       : 1;            /*!< [11..11] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT12       : 1;            /*!< [12..12] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT13       : 1;            /*!< [13..13] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT14       : 1;            /*!< [14..14] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
      __IOM uint32_t OT15       : 1;            /*!< [15..15] Port x configuration bits (y = 0..15) These bits are
                                                     written by software to configure the I/O output type.                     */
            uint32_t            : 16;
    } GPIO_OTYPER_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_OSPEEDR;                /*!< (@ 0x00000008) GPIO port output speed register                            */
    
    struct {
      __IOM uint32_t OSPEED0    : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O output speed.
                                                     Note: Refer to the device datasheet for the frequency specifications
                                                     and the power supply and load conditions for each speed.                  */
      __IOM uint32_t OSPEED1    : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O output speed.
                                                     Note: Refer to the device datasheet for the frequency specifications
                                                     and the power supply and load conditions for each speed.                  */
      __IOM uint32_t OSPEED2    : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O output speed.
                                                     Note: Refer to the device datasheet for the frequency specifications
                                                     and the power supply and load conditions for each speed.                  */
      __IOM uint32_t OSPEED3    : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O output speed.
                                                     Note: Refer to the device datasheet for the frequency specifications
                                                     and the power supply and load conditions for each speed.                  */
      __IOM uint32_t OSPEED4    : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O output speed.
                                                     Note: Refer to the device datasheet for the frequency specifications
                                                     and the power supply and load conditions for each speed.                  */
      __IOM uint32_t OSPEED5    : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED6    : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED7    : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED8    : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED9    : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED10   : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED11   : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED12   : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED13   : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED14   : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
      __IOM uint32_t OSPEED15   : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O output
                                                     speed. Note: Refer to the device datasheet for the frequency
                                                     specifications and the power supply and load conditions
                                                     for each speed.                                                           */
    } GPIO_OSPEEDR_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_PUPDR;                  /*!< (@ 0x0000000C) GPIO port pull-up/pull-down register                       */
    
    struct {
      __IOM uint32_t PUPD0      : 2;            /*!< [1..0] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O pull-up or
                                                     pull-down                                                                 */
      __IOM uint32_t PUPD1      : 2;            /*!< [3..2] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O pull-up or
                                                     pull-down                                                                 */
      __IOM uint32_t PUPD2      : 2;            /*!< [5..4] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O pull-up or
                                                     pull-down                                                                 */
      __IOM uint32_t PUPD3      : 2;            /*!< [7..6] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O pull-up or
                                                     pull-down                                                                 */
      __IOM uint32_t PUPD4      : 2;            /*!< [9..8] [1:0]: Port x configuration bits (y = 0..15) These bits
                                                     are written by software to configure the I/O pull-up or
                                                     pull-down                                                                 */
      __IOM uint32_t PUPD5      : 2;            /*!< [11..10] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD6      : 2;            /*!< [13..12] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD7      : 2;            /*!< [15..14] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD8      : 2;            /*!< [17..16] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD9      : 2;            /*!< [19..18] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD10     : 2;            /*!< [21..20] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD11     : 2;            /*!< [23..22] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD12     : 2;            /*!< [25..24] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD13     : 2;            /*!< [27..26] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD14     : 2;            /*!< [29..28] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
      __IOM uint32_t PUPD15     : 2;            /*!< [31..30] [1:0]: Port x configuration bits (y = 0..15) These
                                                     bits are written by software to configure the I/O pull-up
                                                     or pull-down                                                              */
    } GPIO_PUPDR_b;
  } ;
  
  union {
    __IM  uint32_t GPIO_IDR;                    /*!< (@ 0x00000010) GPIO port input data register                              */
    
    struct {
      __IM  uint32_t ID0        : 1;            /*!< [0..0] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID1        : 1;            /*!< [1..1] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID2        : 1;            /*!< [2..2] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID3        : 1;            /*!< [3..3] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID4        : 1;            /*!< [4..4] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID5        : 1;            /*!< [5..5] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID6        : 1;            /*!< [6..6] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID7        : 1;            /*!< [7..7] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID8        : 1;            /*!< [8..8] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID9        : 1;            /*!< [9..9] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID10       : 1;            /*!< [10..10] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID11       : 1;            /*!< [11..11] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID12       : 1;            /*!< [12..12] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID13       : 1;            /*!< [13..13] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID14       : 1;            /*!< [14..14] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
      __IM  uint32_t ID15       : 1;            /*!< [15..15] Port input data bit (y = 0..15) These bits are read-only.
                                                     They contain the input value of the corresponding I/O port.               */
            uint32_t            : 16;
    } GPIO_IDR_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_ODR;                    /*!< (@ 0x00000014) GPIO port output data register                             */
    
    struct {
      __IOM uint32_t OD0        : 1;            /*!< [0..0] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD1        : 1;            /*!< [1..1] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD2        : 1;            /*!< [2..2] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD3        : 1;            /*!< [3..3] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD4        : 1;            /*!< [4..4] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD5        : 1;            /*!< [5..5] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD6        : 1;            /*!< [6..6] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD7        : 1;            /*!< [7..7] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD8        : 1;            /*!< [8..8] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD9        : 1;            /*!< [9..9] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD10       : 1;            /*!< [10..10] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD11       : 1;            /*!< [11..11] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD12       : 1;            /*!< [12..12] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD13       : 1;            /*!< [13..13] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD14       : 1;            /*!< [14..14] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
      __IOM uint32_t OD15       : 1;            /*!< [15..15] Port output data bit These bits can be read and written
                                                     by software. Note: For atomic bit set/reset, the OD bits
                                                     can be individually set and/or reset by writing to the
                                                     GPIOx_BSRR or GPIOx_BRR registers (x = A..F).                             */
            uint32_t            : 16;
    } GPIO_ODR_b;
  } ;
  
  union {
    __OM  uint32_t GPIO_BSRR;                   /*!< (@ 0x00000018) GPIO port bit set/reset register                           */
    
    struct {
      __OM  uint32_t BS0        : 1;            /*!< [0..0] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS1        : 1;            /*!< [1..1] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS2        : 1;            /*!< [2..2] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS3        : 1;            /*!< [3..3] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS4        : 1;            /*!< [4..4] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS5        : 1;            /*!< [5..5] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS6        : 1;            /*!< [6..6] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS7        : 1;            /*!< [7..7] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS8        : 1;            /*!< [8..8] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS9        : 1;            /*!< [9..9] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS10       : 1;            /*!< [10..10] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS11       : 1;            /*!< [11..11] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS12       : 1;            /*!< [12..12] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS13       : 1;            /*!< [13..13] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS14       : 1;            /*!< [14..14] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BS15       : 1;            /*!< [15..15] Port x set bit y (y= 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000.                            */
      __OM  uint32_t BR0        : 1;            /*!< [16..16] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR1        : 1;            /*!< [17..17] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR2        : 1;            /*!< [18..18] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR3        : 1;            /*!< [19..19] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR4        : 1;            /*!< [20..20] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR5        : 1;            /*!< [21..21] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR6        : 1;            /*!< [22..22] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR7        : 1;            /*!< [23..23] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR8        : 1;            /*!< [24..24] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR9        : 1;            /*!< [25..25] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR10       : 1;            /*!< [26..26] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR11       : 1;            /*!< [27..27] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR12       : 1;            /*!< [28..28] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR13       : 1;            /*!< [29..29] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR14       : 1;            /*!< [30..30] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
      __OM  uint32_t BR15       : 1;            /*!< [31..31] Port x reset bit y (y = 0..15) These bits are write-only.
                                                     A read to these bits returns the value 0x0000. Note: If
                                                     both BSx and BRx are set, BSx has priority.                               */
    } GPIO_BSRR_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_LCKR;                   /*!< (@ 0x0000001C) This register is used to lock the configuration
                                                                    of the port bits when a correct write sequence
                                                                    is applied to bit 16 (LCKK). The value of
                                                                    bits [15:0] is used to lock the configuration
                                                                    of the GPIO. During the write sequence,
                                                                    the value of LCKR[15:0] must not change.
                                                                    When the LOCK sequence has been applied
                                                                    on a port bit, the value of this port bit
                                                                    can no longer be modified until the next
                                                                    MCU reset or peripheral reset.A                            */
    
    struct {
      __IOM uint32_t LCK0       : 1;            /*!< [0..0] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK1       : 1;            /*!< [1..1] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK2       : 1;            /*!< [2..2] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK3       : 1;            /*!< [3..3] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK4       : 1;            /*!< [4..4] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK5       : 1;            /*!< [5..5] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK6       : 1;            /*!< [6..6] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK7       : 1;            /*!< [7..7] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK8       : 1;            /*!< [8..8] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK9       : 1;            /*!< [9..9] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK10      : 1;            /*!< [10..10] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK11      : 1;            /*!< [11..11] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK12      : 1;            /*!< [12..12] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK13      : 1;            /*!< [13..13] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK14      : 1;            /*!< [14..14] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCK15      : 1;            /*!< [15..15] Port x lock bit y (y= 0..15) These bits are read/write
                                                     but can only be written when the LCKK bit is 0.                           */
      __IOM uint32_t LCKK       : 1;            /*!< [16..16] Lock key This bit can be read any time. It can only
                                                     be modified using the lock key write sequence. LOCK key
                                                     write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16]
                                                     = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD
                                                     LCKR[16] = 1 (this read operation is optional but it confirms
                                                     that the lock is active) Note: During the LOCK key write
                                                     sequence, the value of LCK[15:0] must not change. Any error
                                                     in                                                                        */
            uint32_t            : 15;
    } GPIO_LCKR_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_AFRL;                   /*!< (@ 0x00000020) GPIO alternate function low register                       */
    
    struct {
      __IOM uint32_t AFSEL0     : 4;            /*!< [3..0] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL1     : 4;            /*!< [7..4] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL2     : 4;            /*!< [11..8] [3:0]: Alternate function selection for port x pin y
                                                     (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL3     : 4;            /*!< [15..12] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL4     : 4;            /*!< [19..16] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL5     : 4;            /*!< [23..20] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL6     : 4;            /*!< [27..24] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
      __IOM uint32_t AFSEL7     : 4;            /*!< [31..28] [3:0]: Alternate function selection for port x pin
                                                     y (y = 0..7) These bits are written by software to configure
                                                     alternate function I/Os AFSELy selection:                                 */
    } GPIO_AFRL_b;
  } ;
  
  union {
    __IOM uint32_t GPIO_AFRH;                   /*!< (@ 0x00000024) GPIO alternate function high register                      */
    
    struct {
      __IOM uint32_t AFSEL8     : 4;            /*!< [3..0] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL9     : 4;            /*!< [7..4] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL10    : 4;            /*!< [11..8] [3:0]: Alternate function selection for port x pin y
                                                     (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL11    : 4;            /*!< [15..12] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL12    : 4;            /*!< [19..16] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL13    : 4;            /*!< [23..20] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL14    : 4;            /*!< [27..24] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
      __IOM uint32_t AFSEL15    : 4;            /*!< [31..28] [3:0]: Alternate function selection for port x pin
                                                     y (y = 8..15) These bits are written by software to configure
                                                     alternate function I/Os                                                   */
    } GPIO_AFRH_b;
  } ;
} GPIOA_Type;                                   /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                           JPEG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief JPEG (JPEG)
  */

typedef struct {                                /*!< (@ 0x52003000) JPEG Structure                                             */
  
  union {
    __OM  uint32_t JPEG_CONFR0;                 /*!< (@ 0x00000000) JPEG codec control register                                */
    
    struct {
      __OM  uint32_t START      : 1;            /*!< [0..0] Start This bit start or stop the encoding or decoding
                                                     process. Read this register always return 0.                              */
            uint32_t            : 31;
    } JPEG_CONFR0_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFR1;                 /*!< (@ 0x00000004) JPEG codec configuration register 1                        */
    
    struct {
      __IOM uint32_t NF         : 2;            /*!< [1..0] Number of color components This field defines the number
                                                     of color components minus 1.                                              */
            uint32_t            : 1;
      __IOM uint32_t DE         : 1;            /*!< [3..3] Decoding Enable This bit selects the coding or decoding
                                                     process                                                                   */
      __IOM uint32_t COLORSPACE : 2;            /*!< [5..4] Color Space This filed defines the number of quantization
                                                     tables minus 1 to insert in the output stream.                            */
      __IOM uint32_t NS         : 2;            /*!< [7..6] Number of components for Scan This field defines the
                                                     number of components minus 1 for scan header marker segment.              */
      __IOM uint32_t HDR        : 1;            /*!< [8..8] Header Processing This bit enable the header processing
                                                     (generation/parsing).                                                     */
            uint32_t            : 7;
      __IOM uint32_t YSIZE      : 16;           /*!< [31..16] Y Size This field defines the number of lines in source
                                                     image.                                                                    */
    } JPEG_CONFR1_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFR2;                 /*!< (@ 0x00000008) JPEG codec configuration register 2                        */
    
    struct {
      __IOM uint32_t NMCU       : 26;           /*!< [25..0] Number of MCU For encoding: this field defines the number
                                                     of MCU units minus 1 to encode. For decoding: this field
                                                     indicates the number of complete MCU units minus 1 to be
                                                     decoded (this field is updated after the JPEG header parsing).
                                                     If the decoded image size has not a X or Y size multiple
                                                     of 8 or 16 (depending on the sub-sampling process), the
                                                     resulting incomplete or empty MCU must be added to                        */
            uint32_t            : 6;
    } JPEG_CONFR2_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFR3;                 /*!< (@ 0x0000000C) JPEG codec configuration register 3                        */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t XSIZE      : 16;           /*!< [31..16] X size This field defines the number of pixels per
                                                     line.                                                                     */
    } JPEG_CONFR3_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFRN1;                /*!< (@ 0x00000010) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32_t HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32_t HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32_t QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32_t NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32_t VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32_t HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32_t            : 16;
    } JPEG_CONFRN1_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFRN2;                /*!< (@ 0x00000014) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32_t HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32_t HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32_t QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32_t NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32_t VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32_t HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32_t            : 16;
    } JPEG_CONFRN2_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFRN3;                /*!< (@ 0x00000018) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32_t HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32_t HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32_t QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32_t NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32_t VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32_t HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32_t            : 16;
    } JPEG_CONFRN3_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CONFRN4;                /*!< (@ 0x0000001C) JPEG codec configuration register 4-7                      */
    
    struct {
      __IOM uint32_t HD         : 1;            /*!< [0..0] Huffman DC Selects the Huffman table for encoding the
                                                     DC coefficients.                                                          */
      __IOM uint32_t HA         : 1;            /*!< [1..1] Huffman AC Selects the Huffman table for encoding the
                                                     AC coefficients.                                                          */
      __IOM uint32_t QT         : 2;            /*!< [3..2] Quantization Table Selects quantization table associated
                                                     with a color component.                                                   */
      __IOM uint32_t NB         : 4;            /*!< [7..4] Number of Block Number of data units minus 1 that belong
                                                     to a particular color in the MCU.                                         */
      __IOM uint32_t VSF        : 4;            /*!< [11..8] Vertical Sampling Factor Vertical sampling factor for
                                                     component i.                                                              */
      __IOM uint32_t HSF        : 4;            /*!< [15..12] Horizontal Sampling Factor Horizontal sampling factor
                                                     for component i.                                                          */
            uint32_t            : 16;
    } JPEG_CONFRN4_b;
  } ;
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t JPEG_CR;                     /*!< (@ 0x00000030) JPEG control register                                      */
    
    struct {
      __IOM uint32_t JCEN       : 1;            /*!< [0..0] JPEG Core Enable Enable the JPEG codec Core.                       */
      __IOM uint32_t IFTIE      : 1;            /*!< [1..1] Input FIFO Threshold Interrupt Enable This bit enables
                                                     the interrupt generation when input FIFO reach the threshold.             */
      __IOM uint32_t IFNFIE     : 1;            /*!< [2..2] Input FIFO Not Full Interrupt Enable This bit enables
                                                     the interrupt generation when input FIFO is not empty.                    */
      __IOM uint32_t OFTIE      : 1;            /*!< [3..3] Output FIFO Threshold Interrupt Enable This bit enables
                                                     the interrupt generation when output FIFO reach the threshold.            */
      __IOM uint32_t OFNEIE     : 1;            /*!< [4..4] Output FIFO Not Empty Interrupt Enable This bit enables
                                                     the interrupt generation when output FIFO is not empty.                   */
      __IOM uint32_t EOCIE      : 1;            /*!< [5..5] End of Conversion Interrupt Enable This bit enables the
                                                     interrupt generation on the end of conversion.                            */
      __IOM uint32_t HPDIE      : 1;            /*!< [6..6] Header Parsing Done Interrupt Enable This bit enables
                                                     the interrupt generation on the Header Parsing Operation.                 */
            uint32_t            : 4;
      __IOM uint32_t IDMAEN     : 1;            /*!< [11..11] Input DMA Enable Enable the DMA request generation
                                                     for the input FIFO.                                                       */
      __IOM uint32_t ODMAEN     : 1;            /*!< [12..12] Output DMA Enable Enable the DMA request generation
                                                     for the output FIFO.                                                      */
      __IOM uint32_t IFF        : 1;            /*!< [13..13] Input FIFO Flush This bit flush the input FIFO. This
                                                     bit is always read as 0.                                                  */
      __IOM uint32_t OFF        : 1;            /*!< [14..14] Output FIFO Flush This bit flush the output FIFO. This
                                                     bit is always read as 0.                                                  */
            uint32_t            : 17;
    } JPEG_CR_b;
  } ;
  
  union {
    __IM  uint32_t JPEG_SR;                     /*!< (@ 0x00000034) JPEG status register                                       */
    
    struct {
            uint32_t            : 1;
      __IM  uint32_t IFTF       : 1;            /*!< [1..1] Input FIFO Threshold Flag This bit is set when the input
                                                     FIFO is not full and is bellow its threshold.                             */
      __IM  uint32_t IFNFF      : 1;            /*!< [2..2] Input FIFO Not Full Flag This bit is set when the input
                                                     FIFO is not full (a data can be written).                                 */
      __IM  uint32_t OFTF       : 1;            /*!< [3..3] Output FIFO Threshold Flag This bit is set when the output
                                                     FIFO is not empty and has reach its threshold.                            */
      __IM  uint32_t OFNEF      : 1;            /*!< [4..4] Output FIFO Not Empty Flag This bit is set when the output
                                                     FIFO is not empty (a data is available).                                  */
      __IM  uint32_t EOCF       : 1;            /*!< [5..5] End of Conversion Flag This bit is set when the JPEG
                                                     codec core has finished the encoding or the decoding process
                                                     and than last data has been sent to the output FIFO.                      */
      __IM  uint32_t HPDF       : 1;            /*!< [6..6] Header Parsing Done Flag This bit is set in decode mode
                                                     when the JPEG codec has finished the parsing of the headers
                                                     and the internal registers have been updated.                             */
      __IM  uint32_t COF        : 1;            /*!< [7..7] Codec Operation Flag This bit is set when when a JPEG
                                                     codec operation is on going (encoding or decoding).                       */
            uint32_t            : 24;
    } JPEG_SR_b;
  } ;
  
  union {
    __IOM uint32_t JPEG_CFR;                    /*!< (@ 0x00000038) JPEG clear flag register                                   */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t CEOCF      : 1;            /*!< [5..5] Clear End of Conversion Flag Writing 1 clears the End
                                                     of Conversion Flag of the JPEG Status Register.                           */
      __IOM uint32_t CHPDF      : 1;            /*!< [6..6] Clear Header Parsing Done Flag Writing 1 clears the Header
                                                     Parsing Done Flag of the JPEG Status Register.                            */
            uint32_t            : 25;
    } JPEG_CFR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __OM  uint32_t JPEG_DIR;                    /*!< (@ 0x00000040) JPEG data input register                                   */
    
    struct {
      __OM  uint32_t DATAIN     : 32;           /*!< [31..0] Data Input FIFO Input FIFO data register.                         */
    } JPEG_DIR_b;
  } ;
  
  union {
    __IM  uint32_t JPEG_DOR;                    /*!< (@ 0x00000044) JPEG data output register                                  */
    
    struct {
      __IM  uint32_t DATAOUT    : 32;           /*!< [31..0] Data Output FIFO Output FIFO data register.                       */
    } JPEG_DOR_b;
  } ;
} JPEG_Type;                                    /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                           MDMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief MDMA (MDMA)
  */

typedef struct {                                /*!< (@ 0x52000000) MDMA Structure                                             */
  
  union {
    __IM  uint32_t MDMA_GISR0;                  /*!< (@ 0x00000000) MDMA Global Interrupt/Status Register                      */
    
    struct {
      __IM  uint32_t GIF0       : 1;            /*!< [0..0] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF1       : 1;            /*!< [1..1] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF2       : 1;            /*!< [2..2] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF3       : 1;            /*!< [3..3] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF4       : 1;            /*!< [4..4] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF5       : 1;            /*!< [5..5] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF6       : 1;            /*!< [6..6] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF7       : 1;            /*!< [7..7] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF8       : 1;            /*!< [8..8] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF9       : 1;            /*!< [9..9] Channel x global interrupt flag (x=...) This bit is set
                                                     and reset by hardware. It is a logical OR of all the Channel
                                                     x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which
                                                     are enabled in the interrupt mask register (CTCIEx, BTIEx,
                                                     BRTIEx, TEIEx)                                                            */
      __IM  uint32_t GIF10      : 1;            /*!< [10..10] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32_t GIF11      : 1;            /*!< [11..11] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32_t GIF12      : 1;            /*!< [12..12] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32_t GIF13      : 1;            /*!< [13..13] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32_t GIF14      : 1;            /*!< [14..14] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
      __IM  uint32_t GIF15      : 1;            /*!< [15..15] Channel x global interrupt flag (x=...) This bit is
                                                     set and reset by hardware. It is a logical OR of all the
                                                     Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx)
                                                     which are enabled in the interrupt mask register (CTCIEx,
                                                     BTIEx, BRTIEx, TEIEx)                                                     */
            uint32_t            : 16;
    } MDMA_GISR0_b;
  } ;
  __IM  uint32_t  RESERVED[15];
  
  union {
    __IM  uint32_t MDMA_C0ISR;                  /*!< (@ 0x00000040) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF0      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF0     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF0     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF0      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF0      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA0      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C0ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C0IFCR;                 /*!< (@ 0x00000044) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF0     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF0    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF0    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF0     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF0    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C0IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C0ESR;                  /*!< (@ 0x00000048) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C0ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0CR;                   /*!< (@ 0x0000004C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C0CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0TCR;                  /*!< (@ 0x00000050) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C0TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0BNDTR;                /*!< (@ 0x00000054) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C0BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0SAR;                  /*!< (@ 0x00000058) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C0SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0DAR;                  /*!< (@ 0x0000005C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C0DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0BRUR;                 /*!< (@ 0x00000060) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C0BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0LAR;                  /*!< (@ 0x00000064) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C0LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0TBR;                  /*!< (@ 0x00000068) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C0TBR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t MDMA_C0MAR;                  /*!< (@ 0x00000070) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C0MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C0MDR;                  /*!< (@ 0x00000074) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C0MDR_b;
  } ;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IM  uint32_t MDMA_C1ISR;                  /*!< (@ 0x00000080) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF1      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF1     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF1     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF1      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF1      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA1      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C1ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C1IFCR;                 /*!< (@ 0x00000084) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF1     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF1    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF1    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF1     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF1    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C1IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C1ESR;                  /*!< (@ 0x00000088) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C1ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1CR;                   /*!< (@ 0x0000008C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C1CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1TCR;                  /*!< (@ 0x00000090) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C1TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1BNDTR;                /*!< (@ 0x00000094) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C1BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1SAR;                  /*!< (@ 0x00000098) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C1SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1DAR;                  /*!< (@ 0x0000009C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C1DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1BRUR;                 /*!< (@ 0x000000A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C1BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1LAR;                  /*!< (@ 0x000000A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C1LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1TBR;                  /*!< (@ 0x000000A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C1TBR_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t MDMA_C1MAR;                  /*!< (@ 0x000000B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C1MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C1MDR;                  /*!< (@ 0x000000B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C1MDR_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IM  uint32_t MDMA_C2ISR;                  /*!< (@ 0x000000C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF2      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF2     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF2     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF2      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF2      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA2      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C2ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C2IFCR;                 /*!< (@ 0x000000C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF2     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF2    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF2    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF2     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF2    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C2IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C2ESR;                  /*!< (@ 0x000000C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C2ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2CR;                   /*!< (@ 0x000000CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C2CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2TCR;                  /*!< (@ 0x000000D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C2TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2BNDTR;                /*!< (@ 0x000000D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C2BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2SAR;                  /*!< (@ 0x000000D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C2SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2DAR;                  /*!< (@ 0x000000DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C2DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2BRUR;                 /*!< (@ 0x000000E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C2BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2LAR;                  /*!< (@ 0x000000E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C2LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2TBR;                  /*!< (@ 0x000000E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C2TBR_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t MDMA_C2MAR;                  /*!< (@ 0x000000F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C2MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C2MDR;                  /*!< (@ 0x000000F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C2MDR_b;
  } ;
  __IM  uint32_t  RESERVED6[2];
  
  union {
    __IM  uint32_t MDMA_C3ISR;                  /*!< (@ 0x00000100) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF3      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF3     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF3     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF3      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF3      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA3      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C3ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C3IFCR;                 /*!< (@ 0x00000104) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF3     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF3    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF3    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF3     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF3    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C3IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C3ESR;                  /*!< (@ 0x00000108) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C3ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3CR;                   /*!< (@ 0x0000010C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C3CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3TCR;                  /*!< (@ 0x00000110) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C3TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3BNDTR;                /*!< (@ 0x00000114) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C3BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3SAR;                  /*!< (@ 0x00000118) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C3SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3DAR;                  /*!< (@ 0x0000011C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C3DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3BRUR;                 /*!< (@ 0x00000120) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C3BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3LAR;                  /*!< (@ 0x00000124) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C3LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3TBR;                  /*!< (@ 0x00000128) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C3TBR_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t MDMA_C3MAR;                  /*!< (@ 0x00000130) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C3MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C3MDR;                  /*!< (@ 0x00000134) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C3MDR_b;
  } ;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IM  uint32_t MDMA_C4ISR;                  /*!< (@ 0x00000140) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF4      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF4     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF4     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF4      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF4      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA4      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C4ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C4IFCR;                 /*!< (@ 0x00000144) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF4     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF4    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF4    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF4     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF4    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C4IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C4ESR;                  /*!< (@ 0x00000148) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C4ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4CR;                   /*!< (@ 0x0000014C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C4CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4TCR;                  /*!< (@ 0x00000150) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C4TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4BNDTR;                /*!< (@ 0x00000154) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C4BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4SAR;                  /*!< (@ 0x00000158) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C4SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4DAR;                  /*!< (@ 0x0000015C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C4DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4BRUR;                 /*!< (@ 0x00000160) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C4BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4LAR;                  /*!< (@ 0x00000164) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C4LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4TBR;                  /*!< (@ 0x00000168) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C4TBR_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t MDMA_C4MAR;                  /*!< (@ 0x00000170) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C4MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C4MDR;                  /*!< (@ 0x00000174) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C4MDR_b;
  } ;
  __IM  uint32_t  RESERVED10[2];
  
  union {
    __IM  uint32_t MDMA_C5ISR;                  /*!< (@ 0x00000180) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF5      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF5     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF5     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF5      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF5      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA5      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C5ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C5IFCR;                 /*!< (@ 0x00000184) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF5     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF5    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF5    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF5     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF5    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C5IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C5ESR;                  /*!< (@ 0x00000188) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C5ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5CR;                   /*!< (@ 0x0000018C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C5CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5TCR;                  /*!< (@ 0x00000190) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C5TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5BNDTR;                /*!< (@ 0x00000194) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C5BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5SAR;                  /*!< (@ 0x00000198) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C5SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5DAR;                  /*!< (@ 0x0000019C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C5DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5BRUR;                 /*!< (@ 0x000001A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C5BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5LAR;                  /*!< (@ 0x000001A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C5LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5TBR;                  /*!< (@ 0x000001A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C5TBR_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t MDMA_C5MAR;                  /*!< (@ 0x000001B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C5MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C5MDR;                  /*!< (@ 0x000001B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C5MDR_b;
  } ;
  __IM  uint32_t  RESERVED12[2];
  
  union {
    __IM  uint32_t MDMA_C6ISR;                  /*!< (@ 0x000001C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF6      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF6     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF6     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF6      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF6      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA6      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C6ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C6IFCR;                 /*!< (@ 0x000001C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF6     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF6    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF6    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF6     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF6    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C6IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C6ESR;                  /*!< (@ 0x000001C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C6ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6CR;                   /*!< (@ 0x000001CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C6CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6TCR;                  /*!< (@ 0x000001D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C6TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6BNDTR;                /*!< (@ 0x000001D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C6BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6SAR;                  /*!< (@ 0x000001D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C6SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6DAR;                  /*!< (@ 0x000001DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C6DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6BRUR;                 /*!< (@ 0x000001E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C6BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6LAR;                  /*!< (@ 0x000001E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C6LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6TBR;                  /*!< (@ 0x000001E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C6TBR_b;
  } ;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t MDMA_C6MAR;                  /*!< (@ 0x000001F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C6MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C6MDR;                  /*!< (@ 0x000001F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C6MDR_b;
  } ;
  __IM  uint32_t  RESERVED14[2];
  
  union {
    __IM  uint32_t MDMA_C7ISR;                  /*!< (@ 0x00000200) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF7      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF7     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF7     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF7      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF7      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA7      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C7ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C7IFCR;                 /*!< (@ 0x00000204) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF7     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF7    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF7    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF7     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF7    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C7IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C7ESR;                  /*!< (@ 0x00000208) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C7ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7CR;                   /*!< (@ 0x0000020C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C7CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7TCR;                  /*!< (@ 0x00000210) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C7TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7BNDTR;                /*!< (@ 0x00000214) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C7BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7SAR;                  /*!< (@ 0x00000218) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C7SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7DAR;                  /*!< (@ 0x0000021C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C7DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7BRUR;                 /*!< (@ 0x00000220) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C7BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7LAR;                  /*!< (@ 0x00000224) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C7LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7TBR;                  /*!< (@ 0x00000228) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C7TBR_b;
  } ;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t MDMA_C7MAR;                  /*!< (@ 0x00000230) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C7MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C7MDR;                  /*!< (@ 0x00000234) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C7MDR_b;
  } ;
  __IM  uint32_t  RESERVED16[2];
  
  union {
    __IM  uint32_t MDMA_C8ISR;                  /*!< (@ 0x00000240) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF8      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF8     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF8     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF8      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF8      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA8      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C8ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C8IFCR;                 /*!< (@ 0x00000244) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF8     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF8    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF8    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF8     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF8    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C8IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C8ESR;                  /*!< (@ 0x00000248) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C8ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8CR;                   /*!< (@ 0x0000024C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C8CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8TCR;                  /*!< (@ 0x00000250) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C8TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8BNDTR;                /*!< (@ 0x00000254) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C8BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8SAR;                  /*!< (@ 0x00000258) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C8SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8DAR;                  /*!< (@ 0x0000025C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C8DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8BRUR;                 /*!< (@ 0x00000260) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C8BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8LAR;                  /*!< (@ 0x00000264) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C8LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8TBR;                  /*!< (@ 0x00000268) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C8TBR_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t MDMA_C8MAR;                  /*!< (@ 0x00000270) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C8MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C8MDR;                  /*!< (@ 0x00000274) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C8MDR_b;
  } ;
  __IM  uint32_t  RESERVED18[2];
  
  union {
    __IM  uint32_t MDMA_C9ISR;                  /*!< (@ 0x00000280) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF9      : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF9     : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF9     : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF9      : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF9      : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA9      : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C9ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C9IFCR;                 /*!< (@ 0x00000284) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF9     : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF9    : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF9    : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF9     : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF9    : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C9IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C9ESR;                  /*!< (@ 0x00000288) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C9ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9CR;                   /*!< (@ 0x0000028C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C9CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9TCR;                  /*!< (@ 0x00000290) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C9TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9BNDTR;                /*!< (@ 0x00000294) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C9BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9SAR;                  /*!< (@ 0x00000298) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C9SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9DAR;                  /*!< (@ 0x0000029C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C9DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9BRUR;                 /*!< (@ 0x000002A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C9BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9LAR;                  /*!< (@ 0x000002A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C9LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9TBR;                  /*!< (@ 0x000002A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C9TBR_b;
  } ;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IOM uint32_t MDMA_C9MAR;                  /*!< (@ 0x000002B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C9MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C9MDR;                  /*!< (@ 0x000002B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C9MDR_b;
  } ;
  __IM  uint32_t  RESERVED20[2];
  
  union {
    __IM  uint32_t MDMA_C10ISR;                 /*!< (@ 0x000002C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF10     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF10    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF10    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF10     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF10     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA10     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C10ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C10IFCR;                /*!< (@ 0x000002C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF10    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF10   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF10   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF10    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF10   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C10IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C10ESR;                 /*!< (@ 0x000002C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C10ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10CR;                  /*!< (@ 0x000002CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C10CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10TCR;                 /*!< (@ 0x000002D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C10TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10BNDTR;               /*!< (@ 0x000002D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C10BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10SAR;                 /*!< (@ 0x000002D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C10SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10DAR;                 /*!< (@ 0x000002DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C10DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10BRUR;                /*!< (@ 0x000002E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C10BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10LAR;                 /*!< (@ 0x000002E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C10LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10TBR;                 /*!< (@ 0x000002E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C10TBR_b;
  } ;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint32_t MDMA_C10MAR;                 /*!< (@ 0x000002F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C10MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C10MDR;                 /*!< (@ 0x000002F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C10MDR_b;
  } ;
  __IM  uint32_t  RESERVED22[2];
  
  union {
    __IM  uint32_t MDMA_C11ISR;                 /*!< (@ 0x00000300) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF11     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF11    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF11    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF11     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF11     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA11     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C11ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C11IFCR;                /*!< (@ 0x00000304) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF11    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF11   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF11   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF11    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF11   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C11IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C11ESR;                 /*!< (@ 0x00000308) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C11ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11CR;                  /*!< (@ 0x0000030C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C11CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11TCR;                 /*!< (@ 0x00000310) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C11TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11BNDTR;               /*!< (@ 0x00000314) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C11BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11SAR;                 /*!< (@ 0x00000318) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C11SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11DAR;                 /*!< (@ 0x0000031C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C11DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11BRUR;                /*!< (@ 0x00000320) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C11BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11LAR;                 /*!< (@ 0x00000324) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C11LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11TBR;                 /*!< (@ 0x00000328) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C11TBR_b;
  } ;
  __IM  uint32_t  RESERVED23;
  
  union {
    __IOM uint32_t MDMA_C11MAR;                 /*!< (@ 0x00000330) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C11MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C11MDR;                 /*!< (@ 0x00000334) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C11MDR_b;
  } ;
  __IM  uint32_t  RESERVED24[2];
  
  union {
    __IM  uint32_t MDMA_C12ISR;                 /*!< (@ 0x00000340) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF12     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF12    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF12    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF12     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF12     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA12     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C12ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C12IFCR;                /*!< (@ 0x00000344) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF12    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF12   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF12   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF12    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF12   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C12IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C12ESR;                 /*!< (@ 0x00000348) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C12ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12CR;                  /*!< (@ 0x0000034C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C12CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12TCR;                 /*!< (@ 0x00000350) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C12TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12BNDTR;               /*!< (@ 0x00000354) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C12BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12SAR;                 /*!< (@ 0x00000358) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C12SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12DAR;                 /*!< (@ 0x0000035C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C12DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12BRUR;                /*!< (@ 0x00000360) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C12BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12LAR;                 /*!< (@ 0x00000364) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C12LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12TBR;                 /*!< (@ 0x00000368) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C12TBR_b;
  } ;
  __IM  uint32_t  RESERVED25;
  
  union {
    __IOM uint32_t MDMA_C12MAR;                 /*!< (@ 0x00000370) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C12MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C12MDR;                 /*!< (@ 0x00000374) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C12MDR_b;
  } ;
  __IM  uint32_t  RESERVED26[2];
  
  union {
    __IM  uint32_t MDMA_C13ISR;                 /*!< (@ 0x00000380) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF13     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF13    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF13    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF13     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF13     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA13     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C13ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C13IFCR;                /*!< (@ 0x00000384) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF13    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF13   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF13   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF13    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF13   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C13IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C13ESR;                 /*!< (@ 0x00000388) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C13ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13CR;                  /*!< (@ 0x0000038C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C13CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13TCR;                 /*!< (@ 0x00000390) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C13TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13BNDTR;               /*!< (@ 0x00000394) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C13BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13SAR;                 /*!< (@ 0x00000398) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C13SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13DAR;                 /*!< (@ 0x0000039C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C13DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13BRUR;                /*!< (@ 0x000003A0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C13BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13LAR;                 /*!< (@ 0x000003A4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C13LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13TBR;                 /*!< (@ 0x000003A8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C13TBR_b;
  } ;
  __IM  uint32_t  RESERVED27;
  
  union {
    __IOM uint32_t MDMA_C13MAR;                 /*!< (@ 0x000003B0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C13MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C13MDR;                 /*!< (@ 0x000003B4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C13MDR_b;
  } ;
  __IM  uint32_t  RESERVED28[2];
  
  union {
    __IM  uint32_t MDMA_C14ISR;                 /*!< (@ 0x000003C0) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF14     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF14    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF14    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF14     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF14     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA14     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C14ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C14IFCR;                /*!< (@ 0x000003C4) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF14    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF14   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF14   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF14    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF14   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C14IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C14ESR;                 /*!< (@ 0x000003C8) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C14ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14CR;                  /*!< (@ 0x000003CC) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C14CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14TCR;                 /*!< (@ 0x000003D0) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C14TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14BNDTR;               /*!< (@ 0x000003D4) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C14BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14SAR;                 /*!< (@ 0x000003D8) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C14SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14DAR;                 /*!< (@ 0x000003DC) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C14DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14BRUR;                /*!< (@ 0x000003E0) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C14BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14LAR;                 /*!< (@ 0x000003E4) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C14LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14TBR;                 /*!< (@ 0x000003E8) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C14TBR_b;
  } ;
  __IM  uint32_t  RESERVED29;
  
  union {
    __IOM uint32_t MDMA_C14MAR;                 /*!< (@ 0x000003F0) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C14MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C14MDR;                 /*!< (@ 0x000003F4) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C14MDR_b;
  } ;
  __IM  uint32_t  RESERVED30[2];
  
  union {
    __IM  uint32_t MDMA_C15ISR;                 /*!< (@ 0x00000400) MDMA channel x interrupt/status register                   */
    
    struct {
      __IM  uint32_t TEIF15     : 1;            /*!< [0..0] Channel x transfer error interrupt flag This bit is set
                                                     by hardware. It is cleared by software writing 1 to the
                                                     corresponding bit in the DMA_IFCRy register.                              */
      __IM  uint32_t CTCIF15    : 1;            /*!< [1..1] Channel x Channel Transfer Complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register. CTC
                                                     is set when the last block was transferred and the channel
                                                     has been automatically disabled. CTC is also set when the
                                                     channel is suspended, as a result of writing EN bit to
                                                     0.                                                                        */
      __IM  uint32_t BRTIF15    : 1;            /*!< [2..2] Channel x block repeat transfer complete interrupt flag
                                                     This bit is set by hardware. It is cleared by software
                                                     writing 1 to the corresponding bit in the DMA_IFCRy register.             */
      __IM  uint32_t BTIF15     : 1;            /*!< [3..3] Channel x block transfer complete interrupt flag This
                                                     bit is set by hardware. It is cleared by software writing
                                                     1 to the corresponding bit in the DMA_IFCRy register.                     */
      __IM  uint32_t TCIF15     : 1;            /*!< [4..4] channel x buffer transfer complete                                 */
            uint32_t            : 11;
      __IM  uint32_t CRQA15     : 1;            /*!< [16..16] channel x request active flag                                    */
            uint32_t            : 15;
    } MDMA_C15ISR_b;
  } ;
  
  union {
    __OM  uint32_t MDMA_C15IFCR;                /*!< (@ 0x00000404) MDMA channel x interrupt flag clear register               */
    
    struct {
      __OM  uint32_t CTEIF15    : 1;            /*!< [0..0] Channel x clear transfer error interrupt flag Writing
                                                     a 1 into this bit clears TEIFx in the MDMA_ISRy register                  */
      __OM  uint32_t CCTCIF15   : 1;            /*!< [1..1] Clear Channel transfer complete interrupt flag for channel
                                                     x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBRTIF15   : 1;            /*!< [2..2] Channel x clear block repeat transfer complete interrupt
                                                     flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CBTIF15    : 1;            /*!< [3..3] Channel x Clear block transfer complete interrupt flag
                                                     Writing a 1 into this bit clears BTIFx in the MDMA_ISRy
                                                     register                                                                  */
      __OM  uint32_t CLTCIF15   : 1;            /*!< [4..4] CLear buffer Transfer Complete Interrupt Flag for channel
                                                     x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy
                                                     register                                                                  */
            uint32_t            : 27;
    } MDMA_C15IFCR_b;
  } ;
  
  union {
    __IM  uint32_t MDMA_C15ESR;                 /*!< (@ 0x00000408) MDMA Channel x error status register                       */
    
    struct {
      __IM  uint32_t TEA        : 7;            /*!< [6..0] Transfer Error Address These bits are set and cleared
                                                     by HW, in case of an MDMA data transfer error. It is used
                                                     in conjunction with TED. This field indicates the 7 LSBits
                                                     of the address which generated a transfer/access error.
                                                     It may be used by SW to retrieve the failing address, by
                                                     adding this value (truncated to the buffer transfer length
                                                     size) to the current SAR/DAR value. Note: The SAR/DAR                     */
      __IM  uint32_t TED        : 1;            /*!< [7..7] Transfer Error Direction These bit is set and cleared
                                                     by HW, in case of an MDMA data transfer error.                            */
      __IM  uint32_t TELD       : 1;            /*!< [8..8] Transfer Error Link Data These bit is set by HW, in case
                                                     of a transfer error while reading the block link data structure.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t TEMD       : 1;            /*!< [9..9] Transfer Error Mask Data These bit is set by HW, in case
                                                     of a transfer error while writing the Mask Data. It is
                                                     cleared by software writing 1 to the CTEIFx bit in the
                                                     DMA_IFCRy register.                                                       */
      __IM  uint32_t ASE        : 1;            /*!< [10..10] Address/Size Error These bit is set by HW, when the
                                                     programmed address is not aligned with the data size. TED
                                                     will indicate whether the problem is on the source or destination.
                                                     It is cleared by software writing 1 to the CTEIFx bit in
                                                     the DMA_IFCRy register.                                                   */
      __IM  uint32_t BSE        : 1;            /*!< [11..11] Block Size Error These bit is set by HW, when the block
                                                     size is not an integer multiple of the data size either
                                                     for source or destination. TED will indicate whether the
                                                     problem is on the source or destination. It is cleared
                                                     by software writing 1 to the CTEIFx bit in the DMA_IFCRy
                                                     register.                                                                 */
            uint32_t            : 20;
    } MDMA_C15ESR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15CR;                  /*!< (@ 0x0000040C) This register is used to control the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] channel enable                                                     */
      __IOM uint32_t TEIE       : 1;            /*!< [1..1] Transfer error interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t CTCIE      : 1;            /*!< [2..2] Channel Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t BRTIE      : 1;            /*!< [3..3] Block Repeat transfer interrupt enable This bit is set
                                                     and cleared by software.                                                  */
      __IOM uint32_t BTIE       : 1;            /*!< [4..4] Block Transfer interrupt enable This bit is set and cleared
                                                     by software.                                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [5..5] buffer Transfer Complete interrupt enable This bit is
                                                     set and cleared by software.                                              */
      __IOM uint32_t PL         : 2;            /*!< [7..6] Priority level These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0.                                                                     */
            uint32_t            : 4;
      __IOM uint32_t BEX        : 1;            /*!< [12..12] byte Endianness exchange                                         */
      __IOM uint32_t HEX        : 1;            /*!< [13..13] Half word Endianes exchange                                      */
      __IOM uint32_t WEX        : 1;            /*!< [14..14] Word Endianness exchange                                         */
            uint32_t            : 1;
      __OM  uint32_t SWRQ       : 1;            /*!< [16..16] SW ReQuest Writing a 1 into this bit sets the CRQAx
                                                     in MDMA_ISRy register, activating the request on Channel
                                                     x Note: Either the whole CxCR register or the 8-bit/16-bit
                                                     register @ Address offset: 0x4E + 0x40 chn may be used
                                                     for SWRQ activation. In case of a SW request, acknowledge
                                                     is not generated (neither HW signal, nor CxMAR write access).             */
            uint32_t            : 15;
    } MDMA_C15CR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15TCR;                 /*!< (@ 0x00000410) This register is used to configure the concerned
                                                                    channel.                                                   */
    
    struct {
      __IOM uint32_t SINC       : 2;            /*!< [1..0] Source increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When source is AHB (SBUS=1), SINC
                                                     = 00 is forbidden. In Linked List Mode, at the end of a
                                                     block (single or last block in repeated block transfer
                                                     mode), this register will be loaded from memory (from address
                                                     given by current LAR[31:0] + 0x00).                                       */
      __IOM uint32_t DINC       : 2;            /*!< [3..2] Destination increment mode These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0 Note: When destination is AHB (DBUS=1),
                                                     DINC = 00 is forbidden.                                                   */
      __IOM uint32_t SSIZE      : 2;            /*!< [5..4] Source data size These bits are set and cleared by software.
                                                     These bits are protected and can be written only if EN
                                                     is 0 Note: If a value of 11 is programmed for the TCM access/AHB
                                                     port, a transfer error will occur (TEIF bit set) If SINCOS
                                                     &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable.
                                                     Note: SSIZE = 11 (double-word) is forbidden when source
                                                     is TCM/AHB bus (SBUS=1).                                                  */
      __IOM uint32_t DSIZE      : 2;            /*!< [7..6] Destination data size These bits are set and cleared
                                                     by software. These bits are protected and can be written
                                                     only if EN is 0. Note: If a value of 11 is programmed for
                                                     the TCM access/AHB port, a transfer error will occur (TEIF
                                                     bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the
                                                     result will be unpredictable. Note: DSIZE = 11 (double-word)
                                                     is forbidden when destination is TCM/AHB bus (DB                          */
      __IOM uint32_t SINCOS     : 2;            /*!< [9..8] source increment offset size                                       */
      __IOM uint32_t DINCOS     : 2;            /*!< [11..10] Destination increment offset                                     */
      __IOM uint32_t SBURST     : 3;            /*!< [14..12] source burst transfer configuration                              */
      __IOM uint32_t DBURST     : 3;            /*!< [17..15] Destination burst transfer configuration                         */
      __IOM uint32_t TLEN       : 7;            /*!< [24..18] buffer transfer lengh                                            */
      __IOM uint32_t PKE        : 1;            /*!< [25..25] PacK Enable These bit is set and cleared by software.
                                                     If the Source Size is smaller than the destination, it
                                                     will be padded according to the PAM value. If the Source
                                                     data size is larger than the destination one, it will be
                                                     truncated. The alignment will be done according to the
                                                     PAM[0] value. This bit is protected and can be written
                                                     only if EN is 0                                                           */
      __IOM uint32_t PAM        : 2;            /*!< [27..26] Padding/Alignement Mode These bits are set and cleared
                                                     by software. Case 1: Source data size smaller than destination
                                                     data size - 3 options are valid. Case 2: Source data size
                                                     larger than destination data size. The remainder part is
                                                     discarded. When PKE = 1 or DSIZE=SSIZE, these bits are
                                                     ignored. These bits are protected and can be written only
                                                     if EN is 0                                                                */
      __IOM uint32_t TRGM       : 2;            /*!< [29..28] Trigger Mode These bits are set and cleared by software.
                                                     Note: If TRGM is 11 for the current block, all the values
                                                     loaded at the end of the current block through the linked
                                                     list mechanism must keep the same value (TRGM=11) and the
                                                     same SWRM value, otherwise the result is undefined. These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t SWRM       : 1;            /*!< [30..30] SW Request Mode This bit is set and cleared by software.
                                                     If a HW or SW request is currently active, the bit change
                                                     will be delayed until the current transfer is completed.
                                                     If the CxMAR contains a valid address, the CxMDR value
                                                     will also be written @ CxMAR address. This bit is protected
                                                     and can be written only if EN is 0.                                       */
      __IOM uint32_t BWM        : 1;            /*!< [31..31] Bufferable Write Mode This bit is set and cleared by
                                                     software. This bit is protected and can be written only
                                                     if EN is 0. Note: All MDMA destination accesses are non-cacheable.        */
    } MDMA_C15TCR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15BNDTR;               /*!< (@ 0x00000414) MDMA Channel x block number of data register               */
    
    struct {
      __IOM uint32_t BNDT       : 17;           /*!< [16..0] block number of data to transfer                                  */
            uint32_t            : 1;
      __IOM uint32_t BRSUM      : 1;            /*!< [18..18] Block Repeat Source address Update Mode These bits
                                                     are protected and can be written only if EN is 0.                         */
      __IOM uint32_t BRDUM      : 1;            /*!< [19..19] Block Repeat Destination address Update Mode These
                                                     bits are protected and can be written only if EN is 0.                    */
      __IOM uint32_t BRC        : 12;           /*!< [31..20] Block Repeat Count This field contains the number of
                                                     repetitions of the current block (0 to 4095). When the
                                                     channel is enabled, this register is read-only, indicating
                                                     the remaining number of blocks, excluding the current one.
                                                     This register decrements after each complete block transfer.
                                                     Once the last block transfer has completed, this register
                                                     can either stay at zero or be reloaded automatically from
                                                                                                                               */
    } MDMA_C15BNDTR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15SAR;                 /*!< (@ 0x00000418) MDMA channel x source address register                     */
    
    struct {
      __IOM uint32_t SAR        : 32;           /*!< [31..0] source adr base                                                   */
    } MDMA_C15SAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15DAR;                 /*!< (@ 0x0000041C) MDMA channel x destination address register                */
    
    struct {
      __IOM uint32_t DAR        : 32;           /*!< [31..0] Destination adr base                                              */
    } MDMA_C15DAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15BRUR;                /*!< (@ 0x00000420) MDMA channel x Block Repeat address Update register        */
    
    struct {
      __IOM uint32_t SUV        : 16;           /*!< [15..0] source adresse update value                                       */
      __IOM uint32_t DUV        : 16;           /*!< [31..16] destination address update                                       */
    } MDMA_C15BRUR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15LAR;                 /*!< (@ 0x00000424) MDMA channel x Link Address register                       */
    
    struct {
      __IOM uint32_t LAR        : 32;           /*!< [31..0] Link address register                                             */
    } MDMA_C15LAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15TBR;                 /*!< (@ 0x00000428) MDMA channel x Trigger and Bus selection Register          */
    
    struct {
      __IOM uint32_t TSEL       : 6;            /*!< [5..0] Trigger selection                                                  */
            uint32_t            : 10;
      __IOM uint32_t SBUS       : 1;            /*!< [16..16] Source BUS select This bit is protected and can be
                                                     written only if EN is 0.                                                  */
      __IOM uint32_t DBUS       : 1;            /*!< [17..17] Destination BUS slect This bit is protected and can
                                                     be written only if EN is 0.                                               */
            uint32_t            : 14;
    } MDMA_C15TBR_b;
  } ;
  __IM  uint32_t  RESERVED31;
  
  union {
    __IOM uint32_t MDMA_C15MAR;                 /*!< (@ 0x00000430) MDMA channel x Mask address register                       */
    
    struct {
      __IOM uint32_t MAR        : 32;           /*!< [31..0] Mask address                                                      */
    } MDMA_C15MAR_b;
  } ;
  
  union {
    __IOM uint32_t MDMA_C15MDR;                 /*!< (@ 0x00000434) MDMA channel x Mask Data register                          */
    
    struct {
      __IOM uint32_t MDR        : 32;           /*!< [31..0] Mask data                                                         */
    } MDMA_C15MDR_b;
  } ;
} MDMA_Type;                                    /*!< Size = 1080 (0x438)                                                       */



/* =========================================================================================================================== */
/* ================                                          QUADSPI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief QUADSPI (QUADSPI)
  */

typedef struct {                                /*!< (@ 0x52005000) QUADSPI Structure                                          */
  
  union {
    __IOM uint32_t QUADSPI_CR;                  /*!< (@ 0x00000000) QUADSPI control register                                   */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable Enable the QUADSPI.                                         */
      __IOM uint32_t ABORT      : 1;            /*!< [1..1] Abort request This bit aborts the on-going command sequence.
                                                     It is automatically reset once the abort is complete. This
                                                     bit stops the current transfer. In polling mode or memory-mapped
                                                     mode, this bit also reset the APM bit or the DM bit.                      */
      __IOM uint32_t DMAEN      : 1;            /*!< [2..2] DMA enable In indirect mode, DMA can be used to input
                                                     or output data via the QUADSPI_DR register. DMA transfers
                                                     are initiated when the FIFO threshold flag, FTF, is set.                  */
      __IOM uint32_t TCEN       : 1;            /*!< [3..3] Timeout counter enable This bit is valid only when memory-mapped
                                                     mode (FMODE = 11) is selected. Activating this bit causes
                                                     the chip select (nCS) to be released (and thus reduces
                                                     consumption) if there has not been an access after a certain
                                                     amount of time, where this time is defined by TIMEOUT[15:0]
                                                     (QUADSPI_LPTR). Enable the timeout counter. By default,
                                                     the QUADSPI never stops its prefetch                                      */
      __IOM uint32_t SSHIFT     : 1;            /*!< [4..4] Sample shift By default, the QUADSPI samples data 1/2
                                                     of a CLK cycle after the data is driven by the Flash memory.
                                                     This bit allows the data is to be sampled later in order
                                                     to account for external signal delays. Firmware must assure
                                                     that SSHIFT = 0 when in DDR mode (when DDRM = 1). This
                                                     field can be modified only when BUSY = 0.                                 */
            uint32_t            : 1;
      __IOM uint32_t DFM        : 1;            /*!< [6..6] Dual-flash mode This bit activates dual-flash mode, where
                                                     two external Flash memories are used simultaneously to
                                                     double throughput and capacity. This bit can be modified
                                                     only when BUSY = 0.                                                       */
      __IOM uint32_t FSEL       : 1;            /*!< [7..7] Flash memory selection This bit selects the Flash memory
                                                     to be addressed in single flash mode (when DFM = 0). This
                                                     bit can be modified only when BUSY = 0. This bit is ignored
                                                     when DFM = 1.                                                             */
      __IOM uint32_t FTHRES     : 5;            /*!< [12..8] FIFO threshold level Defines, in indirect mode, the
                                                     threshold number of bytes in the FIFO that will cause the
                                                     FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In
                                                     indirect write mode (FMODE = 00): ... In indirect read
                                                     mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller
                                                     for the corresponding channel must be disabled before changing
                                                     the FTHRES value.                                                         */
            uint32_t            : 3;
      __IOM uint32_t TEIE       : 1;            /*!< [16..16] Transfer error interrupt enable This bit enables the
                                                     transfer error interrupt.                                                 */
      __IOM uint32_t TCIE       : 1;            /*!< [17..17] Transfer complete interrupt enable This bit enables
                                                     the transfer complete interrupt.                                          */
      __IOM uint32_t FTIE       : 1;            /*!< [18..18] FIFO threshold interrupt enable This bit enables the
                                                     FIFO threshold interrupt.                                                 */
      __IOM uint32_t SMIE       : 1;            /*!< [19..19] Status match interrupt enable This bit enables the
                                                     status match interrupt.                                                   */
      __IOM uint32_t TOIE       : 1;            /*!< [20..20] TimeOut interrupt enable This bit enables the TimeOut
                                                     interrupt.                                                                */
            uint32_t            : 1;
      __IOM uint32_t APMS       : 1;            /*!< [22..22] Automatic poll mode stop This bit determines if automatic
                                                     polling is stopped after a match. This bit can be modified
                                                     only when BUSY = 0.                                                       */
      __IOM uint32_t PMM        : 1;            /*!< [23..23] Polling match mode This bit indicates which method
                                                     should be used for determining a match during automatic
                                                     polling mode. This bit can be modified only when BUSY =
                                                     0.                                                                        */
      __IOM uint32_t PRESCALER  : 8;            /*!< [31..24] clock prescaler                                                  */
    } QUADSPI_CR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_DCR;                 /*!< (@ 0x00000004) QUADSPI device configuration register                      */
    
    struct {
      __IOM uint32_t CKMODE     : 1;            /*!< [0..0] indicates the level that clk takes between command                 */
            uint32_t            : 7;
      __IOM uint32_t CSHT       : 3;            /*!< [10..8] Chip select high time CSHT+1 defines the minimum number
                                                     of CLK cycles which the chip select (nCS) must remain high
                                                     between commands issued to the Flash memory. ... This field
                                                     can be modified only when BUSY = 0.                                       */
            uint32_t            : 5;
      __IOM uint32_t FSIZE      : 5;            /*!< [20..16] Flash memory size This field defines the size of external
                                                     memory using the following formula: Number of bytes in
                                                     Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number
                                                     of address bits required to address the Flash memory. The
                                                     Flash memory capacity can be up to 4GB (addressed using
                                                     32 bits) in indirect mode, but the addressable space in
                                                     memory-mapped mode is limited to 256MB. If DFM = 1,                       */
            uint32_t            : 11;
    } QUADSPI_DCR_b;
  } ;
  
  union {
    __IM  uint32_t QUADSPI_SR;                  /*!< (@ 0x00000008) QUADSPI status register                                    */
    
    struct {
      __IM  uint32_t TEF        : 1;            /*!< [0..0] Transfer error flag This bit is set in indirect mode
                                                     when an invalid address is being accessed in indirect mode.
                                                     It is cleared by writing 1 to CTEF.                                       */
      __IM  uint32_t TCF        : 1;            /*!< [1..1] Transfer complete flag This bit is set in indirect mode
                                                     when the programmed number of data has been transferred
                                                     or in any mode when the transfer has been aborted.It is
                                                     cleared by writing 1 to CTCF.                                             */
      __IM  uint32_t FTF        : 1;            /*!< [2..2] FIFO threshold flag In indirect mode, this bit is set
                                                     when the FIFO threshold has been reached, or if there is
                                                     any data left in the FIFO after reads from the Flash memory
                                                     are complete. It is cleared automatically as soon as threshold
                                                     condition is no longer true. In automatic polling mode
                                                     this bit is set every time the status register is read,
                                                     and the bit is cleared when the data register is                          */
      __IM  uint32_t SMF        : 1;            /*!< [3..3] Status match flag This bit is set in automatic polling
                                                     mode when the unmasked received data matches the corresponding
                                                     bits in the match register (QUADSPI_PSMAR). It is cleared
                                                     by writing 1 to CSMF.                                                     */
      __IM  uint32_t TOF        : 1;            /*!< [4..4] Timeout flag This bit is set when timeout occurs. It
                                                     is cleared by writing 1 to CTOF.                                          */
      __IM  uint32_t BUSY       : 1;            /*!< [5..5] Busy This bit is set when an operation is on going. This
                                                     bit clears automatically when the operation with the Flash
                                                     memory is finished and the FIFO is empty.                                 */
            uint32_t            : 2;
      __IM  uint32_t FLEVEL     : 6;            /*!< [13..8] FIFO level This field gives the number of valid bytes
                                                     which are being held in the FIFO. FLEVEL = 0 when the FIFO
                                                     is empty, and 16 when it is full. In memory-mapped mode
                                                     and in automatic status polling mode, FLEVEL is zero.                     */
            uint32_t            : 18;
    } QUADSPI_SR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_FCR;                 /*!< (@ 0x0000000C) QUADSPI flag clear register                                */
    
    struct {
      __IOM uint32_t CTEF       : 1;            /*!< [0..0] Clear transfer error flag Writing 1 clears the TEF flag
                                                     in the QUADSPI_SR register                                                */
      __IOM uint32_t CTCF       : 1;            /*!< [1..1] Clear transfer complete flag Writing 1 clears the TCF
                                                     flag in the QUADSPI_SR register                                           */
            uint32_t            : 1;
      __IOM uint32_t CSMF       : 1;            /*!< [3..3] Clear status match flag Writing 1 clears the SMF flag
                                                     in the QUADSPI_SR register                                                */
      __IOM uint32_t CTOF       : 1;            /*!< [4..4] Clear timeout flag Writing 1 clears the TOF flag in the
                                                     QUADSPI_SR register                                                       */
            uint32_t            : 27;
    } QUADSPI_FCR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_DLR;                 /*!< (@ 0x00000010) QUADSPI data length register                               */
    
    struct {
      __IOM uint32_t DL         : 32;           /*!< [31..0] Data length Number of data to be retrieved (value+1)
                                                     in indirect and status-polling modes. A value no greater
                                                     than 3 (indicating 4 bytes) should be used for status-polling
                                                     mode. All 1s in indirect mode means undefined length, where
                                                     QUADSPI will continue until the end of memory, as defined
                                                     by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001:
                                                     2 bytes are to be transferred 0x0000_                                     */
    } QUADSPI_DLR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_CCR;                 /*!< (@ 0x00000014) QUADSPI communication configuration register               */
    
    struct {
      __IOM uint32_t INSTRUCTION : 8;           /*!< [7..0] Instruction Instruction to be send to the external SPI
                                                     device. This field can be written only when BUSY = 0.                     */
      __IOM uint32_t IMODE      : 2;            /*!< [9..8] Instruction mode This field defines the instruction phase
                                                     mode of operation: This field can be written only when
                                                     BUSY = 0.                                                                 */
      __IOM uint32_t ADMODE     : 2;            /*!< [11..10] Address mode This field defines the address phase mode
                                                     of operation: This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32_t ADSIZE     : 2;            /*!< [13..12] Address size This bit defines address size: This field
                                                     can be written only when BUSY = 0.                                        */
      __IOM uint32_t ABMODE     : 2;            /*!< [15..14] Alternate bytes mode This field defines the alternate-bytes
                                                     phase mode of operation: This field can be written only
                                                     when BUSY = 0.                                                            */
      __IOM uint32_t ABSIZE     : 2;            /*!< [17..16] Alternate bytes size This bit defines alternate bytes
                                                     size: This field can be written only when BUSY = 0.                       */
      __IOM uint32_t DCYC       : 5;            /*!< [22..18] Number of dummy cycles This field defines the duration
                                                     of the dummy phase. In both SDR and DDR modes, it specifies
                                                     a number of CLK cycles (0-31). This field can be written
                                                     only when BUSY = 0.                                                       */
            uint32_t            : 1;
      __IOM uint32_t DMODE      : 2;            /*!< [25..24] Data mode This field defines the data phases mode of
                                                     operation: This field also determines the dummy phase mode
                                                     of operation. This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32_t FMODE      : 2;            /*!< [27..26] Functional mode This field defines the QUADSPI functional
                                                     mode of operation. If DMAEN = 1 already, then the DMA controller
                                                     for the corresponding channel must be disabled before changing
                                                     the FMODE value. This field can be written only when BUSY
                                                     = 0.                                                                      */
      __IOM uint32_t SIOO       : 1;            /*!< [28..28] Send instruction only once mode See Section15.3.11:
                                                     Sending the instruction only once on page13. This bit has
                                                     no effect when IMODE = 00. This field can be written only
                                                     when BUSY = 0.                                                            */
            uint32_t            : 1;
      __IOM uint32_t DHHC       : 1;            /*!< [30..30] DDR hold Delay the data output by 1/4 of the QUADSPI
                                                     output clock cycle in DDR mode: This feature is only active
                                                     in DDR mode. This field can be written only when BUSY =
                                                     0.                                                                        */
      __IOM uint32_t DDRM       : 1;            /*!< [31..31] Double data rate mode This bit sets the DDR mode for
                                                     the address, alternate byte and data phase: This field
                                                     can be written only when BUSY = 0.                                        */
    } QUADSPI_CCR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_AR;                  /*!< (@ 0x00000018) QUADSPI address register                                   */
    
    struct {
      __IOM uint32_t ADDRESS    : 32;           /*!< [31..0] [31 0]: Address Address to be send to the external Flash
                                                     memory Writes to this field are ignored when BUSY = 0 or
                                                     when FMODE = 11 (memory-mapped mode). In dual flash mode,
                                                     ADDRESS[0] is automatically stuck to 0 as the address should
                                                     always be even                                                            */
    } QUADSPI_AR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_ABR;                 /*!< (@ 0x0000001C) QUADSPI alternate bytes registers                          */
    
    struct {
      __IOM uint32_t ALTERNATE  : 32;           /*!< [31..0] Alternate Bytes Optional data to be send to the external
                                                     SPI device right after the address. This field can be written
                                                     only when BUSY = 0.                                                       */
    } QUADSPI_ABR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_DR;                  /*!< (@ 0x00000020) QUADSPI data register                                      */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] Data Data to be sent/received to/from the external SPI
                                                     device. In indirect write mode, data written to this register
                                                     is stored on the FIFO before it is sent to the Flash memory
                                                     during the data phase. If the FIFO is too full, a write
                                                     operation is stalled until the FIFO has enough space to
                                                     accept the amount of data being written. In indirect read
                                                     mode, reading this register gives (via the FIFO) the data
                                                     w                                                                         */
    } QUADSPI_DR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_PSMKR;               /*!< (@ 0x00000024) QUADSPI polling status mask register                       */
    
    struct {
      __IOM uint32_t MASK       : 32;           /*!< [31..0] Status mask Mask to be applied to the status bytes received
                                                     in polling mode. For bit n: This field can be written only
                                                     when BUSY = 0.                                                            */
    } QUADSPI_PSMKR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_PSMAR;               /*!< (@ 0x00000028) QUADSPI polling status match register                      */
    
    struct {
      __IOM uint32_t MATCH      : 32;           /*!< [31..0] Status match Value to be compared with the masked status
                                                     register to get a match. This field can be written only
                                                     when BUSY = 0.                                                            */
    } QUADSPI_PSMAR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_PIR;                 /*!< (@ 0x0000002C) QUADSPI polling interval register                          */
    
    struct {
      __IOM uint32_t INTERVAL   : 16;           /*!< [15..0] Polling interval Number of CLK cycles between to read
                                                     during automatic polling phases. This field can be written
                                                     only when BUSY = 0.                                                       */
            uint32_t            : 16;
    } QUADSPI_PIR_b;
  } ;
  
  union {
    __IOM uint32_t QUADSPI_LPTR;                /*!< (@ 0x00000030) QUADSPI low-power timeout register                         */
    
    struct {
      __IOM uint32_t TIMEOUT    : 16;           /*!< [15..0] Timeout period After each access in memory-mapped mode,
                                                     the QUADSPI prefetches the subsequent bytes and holds these
                                                     bytes in the FIFO. This field indicates how many CLK cycles
                                                     the QUADSPI waits after the FIFO becomes full until it
                                                     raises nCS, putting the Flash memory in a lower-consumption
                                                     state. This field can be written only when BUSY = 0.                      */
            uint32_t            : 16;
    } QUADSPI_LPTR_b;
  } ;
} QUADSPI_Type;                                 /*!< Size = 52 (0x34)                                                          */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RNG (RNG)
  */

typedef struct {                                /*!< (@ 0x48021800) RNG Structure                                              */
  
  union {
    __IOM uint32_t RNG_CR;                      /*!< (@ 0x00000000) RNG control register                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t RNGEN      : 1;            /*!< [2..2] Random number generator enable                                     */
      __IOM uint32_t IE         : 1;            /*!< [3..3] Interrupt enable                                                   */
            uint32_t            : 1;
      __IOM uint32_t CED        : 1;            /*!< [5..5] Clock error detection Note: The clock error detection
                                                     can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q =
                                                     48MHz) source is selected otherwise, CED bit must be equal
                                                     to 1. The clock error detection cannot be enabled nor disabled
                                                     on the fly when RNG peripheral is enabled, to enable or
                                                     disable CED the RNG must be disabled.                                     */
            uint32_t            : 26;
    } RNG_CR_b;
  } ;
  
  union {
    __IOM uint32_t RNG_SR;                      /*!< (@ 0x00000004) RNG status register                                        */
    
    struct {
      __IM  uint32_t DRDY       : 1;            /*!< [0..0] Data ready Note: If IE=1 in RNG_CR, an interrupt is generated
                                                     when DRDY=1. It can rise when the peripheral is disabled.
                                                     When the output buffer becomes empty (after reading RNG_DR),
                                                     this bit returns to 0 until a new random value is generated.              */
      __IM  uint32_t CECS       : 1;            /*!< [1..1] Clock error current status Note: This bit is meaningless
                                                     if CED (Clock error detection) bit in RNG_CR is equal to
                                                     1.                                                                        */
      __IM  uint32_t SECS       : 1;            /*!< [2..2] Seed error current status ** More than 64 consecutive
                                                     bits at the same value (0 or 1) ** More than 32 consecutive
                                                     alternances of 0 and 1 (0101010101...01)                                  */
            uint32_t            : 2;
      __IOM uint32_t CEIS       : 1;            /*!< [5..5] Clock error interrupt status This bit is set at the same
                                                     time as CECS. It is cleared by writing it to 0. An interrupt
                                                     is pending if IE = 1 in the RNG_CR register. Note: This
                                                     bit is meaningless if CED (Clock error detection) bit in
                                                     RNG_CR is equal to 1.                                                     */
      __IOM uint32_t SEIS       : 1;            /*!< [6..6] Seed error interrupt status This bit is set at the same
                                                     time as SECS. It is cleared by writing it to 0. ** More
                                                     than 64 consecutive bits at the same value (0 or 1) **
                                                     More than 32 consecutive alternances of 0 and 1 (0101010101...01)
                                                     An interrupt is pending if IE = 1 in the RNG_CR register.                 */
            uint32_t            : 25;
    } RNG_SR_b;
  } ;
  
  union {
    __IM  uint32_t RNG_DR;                      /*!< (@ 0x00000008) The RNG_DR register is a read-only register that
                                                                    delivers a 32-bit random value when read.
                                                                    The content of this register is valid when
                                                                    DRDY= 1, even if RNGEN=0.                                  */
    
    struct {
      __IM  uint32_t RNDATA     : 32;           /*!< [31..0] Random data 32-bit random data which are valid when
                                                     DRDY=1.                                                                   */
    } RNG_DR_b;
  } ;
} RNG_Type;                                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RTC (RTC)
  */

typedef struct {                                /*!< (@ 0x58004000) RTC Structure                                              */
  
  union {
    __IOM uint32_t RTC_TR;                      /*!< (@ 0x00000000) The RTC_TR is the calendar time shadow register.
                                                                    This register must be written in initialization
                                                                    mode only. Refer to Calendar initialization
                                                                    and configuration on page9 and Reading the
                                                                    calendar on page10.This register is write
                                                                    protected. The write access procedure is
                                                                    described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32_t SU         : 4;            /*!< [3..0] Second units in BCD format                                         */
      __IOM uint32_t ST         : 3;            /*!< [6..4] Second tens in BCD format                                          */
            uint32_t            : 1;
      __IOM uint32_t MNU        : 4;            /*!< [11..8] Minute units in BCD format                                        */
      __IOM uint32_t MNT        : 3;            /*!< [14..12] Minute tens in BCD format                                        */
            uint32_t            : 1;
      __IOM uint32_t HU         : 4;            /*!< [19..16] Hour units in BCD format                                         */
      __IOM uint32_t HT         : 2;            /*!< [21..20] Hour tens in BCD format                                          */
      __IOM uint32_t PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
            uint32_t            : 9;
    } RTC_TR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_DR;                      /*!< (@ 0x00000004) The RTC_DR is the calendar date shadow register.
                                                                    This register must be written in initialization
                                                                    mode only. Refer to Calendar initialization
                                                                    and configuration on page9 and Reading the
                                                                    calendar on page10.This register is write
                                                                    protected. The write access procedure is
                                                                    described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32_t DU         : 4;            /*!< [3..0] Date units in BCD format                                           */
      __IOM uint32_t DT         : 2;            /*!< [5..4] Date tens in BCD format                                            */
            uint32_t            : 2;
      __IOM uint32_t MU         : 4;            /*!< [11..8] Month units in BCD format                                         */
      __IOM uint32_t MT         : 1;            /*!< [12..12] Month tens in BCD format                                         */
      __IOM uint32_t WDU        : 3;            /*!< [15..13] Week day units                                                   */
      __IOM uint32_t YU         : 4;            /*!< [19..16] Year units in BCD format                                         */
      __IOM uint32_t YT         : 4;            /*!< [23..20] Year tens in BCD format                                          */
            uint32_t            : 8;
    } RTC_DR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_CR;                      /*!< (@ 0x00000008) RTC control register                                       */
    
    struct {
      __IOM uint32_t WUCKSEL    : 3;            /*!< [2..0] Wakeup clock selection                                             */
      __IOM uint32_t TSEDGE     : 1;            /*!< [3..3] Time-stamp event active edge TSE must be reset when TSEDGE
                                                     is changed to avoid unwanted TSF setting.                                 */
      __IOM uint32_t REFCKON    : 1;            /*!< [4..4] RTC_REFIN reference clock detection enable (50 or 60Hz)
                                                     Note: PREDIV_S must be 0x00FF.                                            */
      __IOM uint32_t BYPSHAD    : 1;            /*!< [5..5] Bypass the shadow registers Note: If the frequency of
                                                     the APB clock is less than seven times the frequency of
                                                     RTCCLK, BYPSHAD must be set to 1.                                         */
      __IOM uint32_t FMT        : 1;            /*!< [6..6] Hour format                                                        */
            uint32_t            : 1;
      __IOM uint32_t ALRAE      : 1;            /*!< [8..8] Alarm A enable                                                     */
      __IOM uint32_t ALRBE      : 1;            /*!< [9..9] Alarm B enable                                                     */
      __IOM uint32_t WUTE       : 1;            /*!< [10..10] Wakeup timer enable                                              */
      __IOM uint32_t TSE        : 1;            /*!< [11..11] timestamp enable                                                 */
      __IOM uint32_t ALRAIE     : 1;            /*!< [12..12] Alarm A interrupt enable                                         */
      __IOM uint32_t ALRBIE     : 1;            /*!< [13..13] Alarm B interrupt enable                                         */
      __IOM uint32_t WUTIE      : 1;            /*!< [14..14] Wakeup timer interrupt enable                                    */
      __IOM uint32_t TSIE       : 1;            /*!< [15..15] Time-stamp interrupt enable                                      */
      __OM  uint32_t ADD1H      : 1;            /*!< [16..16] Add 1 hour (summer time change) When this bit is set
                                                     outside initialization mode, 1 hour is added to the calendar
                                                     time. This bit is always read as 0.                                       */
      __OM  uint32_t SUB1H      : 1;            /*!< [17..17] Subtract 1 hour (winter time change) When this bit
                                                     is set outside initialization mode, 1 hour is subtracted
                                                     to the calendar time if the current hour is not 0. This
                                                     bit is always read as 0. Setting this bit has no effect
                                                     when current hour is 0.                                                   */
      __IOM uint32_t BKP        : 1;            /*!< [18..18] Backup This bit can be written by the user to memorize
                                                     whether the daylight saving time change has been performed
                                                     or not.                                                                   */
      __IOM uint32_t COSEL      : 1;            /*!< [19..19] Calibration output selection When COE=1, this bit selects
                                                     which signal is output on RTC_CALIB. These frequencies
                                                     are valid for RTCCLK at 32.768 kHz and prescalers at their
                                                     default values (PREDIV_A=127 and PREDIV_S=255). Refer to
                                                     Section24.3.15: Calibration clock output                                  */
      __IOM uint32_t POL        : 1;            /*!< [20..20] Output polarity This bit is used to configure the polarity
                                                     of RTC_ALARM output                                                       */
      __IOM uint32_t OSEL       : 2;            /*!< [22..21] Output selection These bits are used to select the
                                                     flag to be routed to RTC_ALARM output                                     */
      __IOM uint32_t COE        : 1;            /*!< [23..23] Calibration output enable This bit enables the RTC_CALIB
                                                     output                                                                    */
      __IOM uint32_t ITSE       : 1;            /*!< [24..24] timestamp on internal event enable                               */
            uint32_t            : 7;
    } RTC_CR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_ISR;                     /*!< (@ 0x0000000C) This register is write protected (except for
                                                                    RTC_ISR[13:8] bits). The write access procedure
                                                                    is described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IM  uint32_t ALRAWF     : 1;            /*!< [0..0] Alarm A write flag This bit is set by hardware when Alarm
                                                     A values can be changed, after the ALRAE bit has been set
                                                     to 0 in RTC_CR. It is cleared by hardware in initialization
                                                     mode.                                                                     */
      __IM  uint32_t ALRBWF     : 1;            /*!< [1..1] Alarm B write flag This bit is set by hardware when Alarm
                                                     B values can be changed, after the ALRBE bit has been set
                                                     to 0 in RTC_CR. It is cleared by hardware in initialization
                                                     mode.                                                                     */
      __IM  uint32_t WUTWF      : 1;            /*!< [2..2] Wakeup timer write flag This bit is set by hardware up
                                                     to 2 RTCCLK cycles after the WUTE bit has been set to 0
                                                     in RTC_CR, and is cleared up to 2 RTCCLK cycles after the
                                                     WUTE bit has been set to 1. The wakeup timer values can
                                                     be changed when WUTE bit is cleared and WUTWF is set.                     */
      __IM  uint32_t SHPF       : 1;            /*!< [3..3] Shift operation pending This flag is set by hardware
                                                     as soon as a shift operation is initiated by a write to
                                                     the RTC_SHIFTR register. It is cleared by hardware when
                                                     the corresponding shift operation has been executed. Writing
                                                     to the SHPF bit has no effect.                                            */
      __IM  uint32_t INITS      : 1;            /*!< [4..4] Initialization status flag This bit is set by hardware
                                                     when the calendar year field is different from 0 (Backup
                                                     domain reset state).                                                      */
      __IOM uint32_t RSF        : 1;            /*!< [5..5] Registers synchronization flag This bit is set by hardware
                                                     each time the calendar registers are copied into the shadow
                                                     registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is
                                                     cleared by hardware in initialization mode, while a shift
                                                     operation is pending (SHPF=1), or when in bypass shadow
                                                     register mode (BYPSHAD=1). This bit can also be cleared
                                                     by software. It is cleared either by software or by                       */
      __IM  uint32_t INITF      : 1;            /*!< [6..6] Initialization flag When this bit is set to 1, the RTC
                                                     is in initialization state, and the time, date and prescaler
                                                     registers can be updated.                                                 */
      __IOM uint32_t INIT       : 1;            /*!< [7..7] Initialization mode                                                */
      __IOM uint32_t ALRAF      : 1;            /*!< [8..8] Alarm A flag This flag is set by hardware when the time/date
                                                     registers (RTC_TR and RTC_DR) match the Alarm A register
                                                     (RTC_ALRMAR). This flag is cleared by software by writing
                                                     0.                                                                        */
      __IOM uint32_t ALRBF      : 1;            /*!< [9..9] Alarm B flag This flag is set by hardware when the time/date
                                                     registers (RTC_TR and RTC_DR) match the Alarm B register
                                                     (RTC_ALRMBR). This flag is cleared by software by writing
                                                     0.                                                                        */
      __IOM uint32_t WUTF       : 1;            /*!< [10..10] Wakeup timer flag This flag is set by hardware when
                                                     the wakeup auto-reload counter reaches 0. This flag is
                                                     cleared by software by writing 0. This flag must be cleared
                                                     by software at least 1.5 RTCCLK periods before WUTF is
                                                     set to 1 again.                                                           */
      __IOM uint32_t TSF        : 1;            /*!< [11..11] Time-stamp flag This flag is set by hardware when a
                                                     time-stamp event occurs. This flag is cleared by software
                                                     by writing 0.                                                             */
      __IOM uint32_t TSOVF      : 1;            /*!< [12..12] Time-stamp overflow flag This flag is set by hardware
                                                     when a time-stamp event occurs while TSF is already set.
                                                     This flag is cleared by software by writing 0. It is recommended
                                                     to check and then clear TSOVF only after clearing the TSF
                                                     bit. Otherwise, an overflow might not be noticed if a time-stamp
                                                     event occurs immediately before the TSF bit is cleared.                   */
      __IOM uint32_t TAMP1F     : 1;            /*!< [13..13] RTC_TAMP1 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP1
                                                     input. It is cleared by software writing 0                                */
      __IOM uint32_t TAMP2F     : 1;            /*!< [14..14] RTC_TAMP2 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP2
                                                     input. It is cleared by software writing 0                                */
      __IOM uint32_t TAMP3F     : 1;            /*!< [15..15] RTC_TAMP3 detection flag This flag is set by hardware
                                                     when a tamper detection event is detected on the RTC_TAMP3
                                                     input. It is cleared by software writing 0                                */
      __IM  uint32_t RECALPF    : 1;            /*!< [16..16] Recalibration pending Flag The RECALPF status flag
                                                     is automatically set to 1 when software writes to the RTC_CALR
                                                     register, indicating that the RTC_CALR register is blocked.
                                                     When the new calibration settings are taken into account,
                                                     this bit returns to 0. Refer to Re-calibration on-the-fly.                */
      __IOM uint32_t ITSF       : 1;            /*!< [17..17] Internal tTime-stamp flag                                        */
            uint32_t            : 14;
    } RTC_ISR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_PRER;                    /*!< (@ 0x00000010) This register must be written in initialization
                                                                    mode only. The initialization must be performed
                                                                    in two separate write accesses. Refer to
                                                                    Calendar initialization and configuration
                                                                    on page9.This register is write protected.
                                                                    The write access procedure is described
                                                                    in RTC register write protection on page9.                 */
    
    struct {
      __IOM uint32_t PREDIV_S   : 15;           /*!< [14..0] Synchronous prescaler factor This is the synchronous
                                                     division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)       */
            uint32_t            : 1;
      __IOM uint32_t PREDIV_A   : 7;            /*!< [22..16] Asynchronous prescaler factor This is the asynchronous
                                                     division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)        */
            uint32_t            : 9;
    } RTC_PRER_b;
  } ;
  
  union {
    __IOM uint32_t RTC_WUTR;                    /*!< (@ 0x00000014) This register can be written only when WUTWF
                                                                    is set to 1 in RTC_ISR.This register is
                                                                    write protected. The write access procedure
                                                                    is described in RTC register write protection
                                                                    on page9.                                                  */
    
    struct {
      __IOM uint32_t WUT        : 16;           /*!< [15..0] Wakeup auto-reload value bits When the wakeup timer
                                                     is enabled (WUTE set to 1), the WUTF flag is set every
                                                     (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected
                                                     through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2]
                                                     = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively
                                                     becomes WUT[16] the most-significant bit to be reloaded
                                                     into the timer. The first assertion of                                    */
            uint32_t            : 16;
    } RTC_WUTR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t RTC_ALRMAR;                  /*!< (@ 0x0000001C) This register can be written only when ALRAWF
                                                                    is set to 1 in RTC_ISR, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9.                        */
    
    struct {
      __IOM uint32_t SU         : 4;            /*!< [3..0] Second units in BCD format.                                        */
      __IOM uint32_t ST         : 3;            /*!< [6..4] Second tens in BCD format.                                         */
      __IOM uint32_t MSK1       : 1;            /*!< [7..7] Alarm A seconds mask                                               */
      __IOM uint32_t MNU        : 4;            /*!< [11..8] Minute units in BCD format.                                       */
      __IOM uint32_t MNT        : 3;            /*!< [14..12] Minute tens in BCD format.                                       */
      __IOM uint32_t MSK2       : 1;            /*!< [15..15] Alarm A minutes mask                                             */
      __IOM uint32_t HU         : 4;            /*!< [19..16] Hour units in BCD format.                                        */
      __IOM uint32_t HT         : 2;            /*!< [21..20] Hour tens in BCD format.                                         */
      __IOM uint32_t PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
      __IOM uint32_t MSK3       : 1;            /*!< [23..23] Alarm A hours mask                                               */
      __IOM uint32_t DU         : 4;            /*!< [27..24] Date units or day in BCD format.                                 */
      __IOM uint32_t DT         : 2;            /*!< [29..28] Date tens in BCD format.                                         */
      __IOM uint32_t WDSEL      : 1;            /*!< [30..30] Week day selection                                               */
      __IOM uint32_t MSK4       : 1;            /*!< [31..31] Alarm A date mask                                                */
    } RTC_ALRMAR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_ALRMBR;                  /*!< (@ 0x00000020) This register can be written only when ALRBWF
                                                                    is set to 1 in RTC_ISR, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9.                        */
    
    struct {
      __IOM uint32_t SU         : 4;            /*!< [3..0] Second units in BCD format                                         */
      __IOM uint32_t ST         : 3;            /*!< [6..4] Second tens in BCD format                                          */
      __IOM uint32_t MSK1       : 1;            /*!< [7..7] Alarm B seconds mask                                               */
      __IOM uint32_t MNU        : 4;            /*!< [11..8] Minute units in BCD format                                        */
      __IOM uint32_t MNT        : 3;            /*!< [14..12] Minute tens in BCD format                                        */
      __IOM uint32_t MSK2       : 1;            /*!< [15..15] Alarm B minutes mask                                             */
      __IOM uint32_t HU         : 4;            /*!< [19..16] Hour units in BCD format                                         */
      __IOM uint32_t HT         : 2;            /*!< [21..20] Hour tens in BCD format                                          */
      __IOM uint32_t PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
      __IOM uint32_t MSK3       : 1;            /*!< [23..23] Alarm B hours mask                                               */
      __IOM uint32_t DU         : 4;            /*!< [27..24] Date units or day in BCD format                                  */
      __IOM uint32_t DT         : 2;            /*!< [29..28] Date tens in BCD format                                          */
      __IOM uint32_t WDSEL      : 1;            /*!< [30..30] Week day selection                                               */
      __IOM uint32_t MSK4       : 1;            /*!< [31..31] Alarm B date mask                                                */
    } RTC_ALRMBR_b;
  } ;
  
  union {
    __OM  uint32_t RTC_WPR;                     /*!< (@ 0x00000024) RTC write protection register                              */
    
    struct {
      __OM  uint32_t KEY        : 8;            /*!< [7..0] Write protection key This byte is written by software.
                                                     Reading this byte always returns 0x00. Refer to RTC register
                                                     write protection for a description of how to unlock RTC
                                                     register write protection.                                                */
            uint32_t            : 24;
    } RTC_WPR_b;
  } ;
  
  union {
    __IM  uint32_t RTC_SSR;                     /*!< (@ 0x00000028) RTC sub second register                                    */
    
    struct {
      __IM  uint32_t SS         : 16;           /*!< [15..0] Sub second value SS[15:0] is the value in the synchronous
                                                     prescaler counter. The fraction of a second is given by
                                                     the formula below: Second fraction = (PREDIV_S - SS) /
                                                     (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only
                                                     after a shift operation. In that case, the correct time/date
                                                     is one second less than as indicated by RTC_TR/RTC_DR.                    */
            uint32_t            : 16;
    } RTC_SSR_b;
  } ;
  
  union {
    __OM  uint32_t RTC_SHIFTR;                  /*!< (@ 0x0000002C) This register is write protected. The write access
                                                                    procedure is described in RTC register write
                                                                    protection on page9.                                       */
    
    struct {
      __OM  uint32_t SUBFS      : 15;           /*!< [14..0] Subtract a fraction of a second These bits are write
                                                     only and is always read as zero. Writing to this bit has
                                                     no effect when a shift operation is pending (when SHPF=1,
                                                     in RTC_ISR). The value which is written to SUBFS is added
                                                     to the synchronous prescaler counter. Since this counter
                                                     counts down, this operation effectively subtracts from
                                                     (delays) the clock by: Delay (seconds) = SUBFS / (PRE                     */
            uint32_t            : 16;
      __OM  uint32_t ADD1S      : 1;            /*!< [31..31] Add one second This bit is write only and is always
                                                     read as zero. Writing to this bit has no effect when a
                                                     shift operation is pending (when SHPF=1, in RTC_ISR). This
                                                     function is intended to be used with SUBFS (see description
                                                     below) in order to effectively add a fraction of a second
                                                     to the clock in an atomic operation.                                      */
    } RTC_SHIFTR_b;
  } ;
  
  union {
    __IM  uint32_t RTC_TSTR;                    /*!< (@ 0x00000030) The content of this register is valid only when
                                                                    TSF is set to 1 in RTC_ISR. It is cleared
                                                                    when TSF bit is reset.                                     */
    
    struct {
      __IM  uint32_t SU         : 4;            /*!< [3..0] Second units in BCD format.                                        */
      __IM  uint32_t ST         : 3;            /*!< [6..4] Second tens in BCD format.                                         */
            uint32_t            : 1;
      __IM  uint32_t MNU        : 4;            /*!< [11..8] Minute units in BCD format.                                       */
      __IM  uint32_t MNT        : 3;            /*!< [14..12] Minute tens in BCD format.                                       */
            uint32_t            : 1;
      __IM  uint32_t HU         : 4;            /*!< [19..16] Hour units in BCD format.                                        */
      __IM  uint32_t HT         : 2;            /*!< [21..20] Hour tens in BCD format.                                         */
      __IM  uint32_t PM         : 1;            /*!< [22..22] AM/PM notation                                                   */
            uint32_t            : 9;
    } RTC_TSTR_b;
  } ;
  
  union {
    __IM  uint32_t RTC_TSDR;                    /*!< (@ 0x00000034) The content of this register is valid only when
                                                                    TSF is set to 1 in RTC_ISR. It is cleared
                                                                    when TSF bit is reset.                                     */
    
    struct {
      __IM  uint32_t DU         : 4;            /*!< [3..0] Date units in BCD format                                           */
      __IM  uint32_t DT         : 2;            /*!< [5..4] Date tens in BCD format                                            */
            uint32_t            : 2;
      __IM  uint32_t MU         : 4;            /*!< [11..8] Month units in BCD format                                         */
      __IM  uint32_t MT         : 1;            /*!< [12..12] Month tens in BCD format                                         */
      __IM  uint32_t WDU        : 3;            /*!< [15..13] Week day units                                                   */
            uint32_t            : 16;
    } RTC_TSDR_b;
  } ;
  
  union {
    __IM  uint32_t RTC_TSSSR;                   /*!< (@ 0x00000038) The content of this register is valid only when
                                                                    RTC_ISR/TSF is set. It is cleared when the
                                                                    RTC_ISR/TSF bit is reset.                                  */
    
    struct {
      __IM  uint32_t SS         : 16;           /*!< [15..0] Sub second value SS[15:0] is the value of the synchronous
                                                     prescaler counter when the timestamp event occurred.                      */
            uint32_t            : 16;
    } RTC_TSSSR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_CALR;                    /*!< (@ 0x0000003C) This register is write protected. The write access
                                                                    procedure is described in RTC register write
                                                                    protection on page9.                                       */
    
    struct {
      __IOM uint32_t CALM       : 9;            /*!< [8..0] Calibration minus The frequency of the calendar is reduced
                                                     by masking CALM out of 220 RTCCLK pulses (32 seconds if
                                                     the input frequency is 32768 Hz). This decreases the frequency
                                                     of the calendar with a resolution of 0.9537 ppm. To increase
                                                     the frequency of the calendar, this feature should be used
                                                     in conjunction with CALP. See Section24.3.12: RTC smooth
                                                     digital calibration on page13.                                            */
            uint32_t            : 4;
      __IOM uint32_t CALW16     : 1;            /*!< [13..13] Use a 16-second calibration cycle period When CALW16
                                                     is set to 1, the 16-second calibration cycle period is
                                                     selected.This bit must not be set to 1 if CALW8=1. Note:
                                                     CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12:
                                                     RTC smooth digital calibration.                                           */
      __IOM uint32_t CALW8      : 1;            /*!< [14..14] Use an 8-second calibration cycle period When CALW8
                                                     is set to 1, the 8-second calibration cycle period is selected.
                                                     Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to
                                                     Section24.3.12: RTC smooth digital calibration.                           */
      __IOM uint32_t CALP       : 1;            /*!< [15..15] Increase frequency of RTC by 488.5 ppm This feature
                                                     is intended to be used in conjunction with CALM, which
                                                     lowers the frequency of the calendar with a fine resolution.
                                                     if the input frequency is 32768 Hz, the number of RTCCLK
                                                     pulses added during a 32-second window is calculated as
                                                     follows: (512 * CALP) - CALM. Refer to Section24.3.12:
                                                     RTC smooth digital calibration.                                           */
            uint32_t            : 16;
    } RTC_CALR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_TAMPCR;                  /*!< (@ 0x00000040) RTC tamper and alternate function configuration
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t TAMP1E     : 1;            /*!< [0..0] RTC_TAMP1 input detection enable                                   */
      __IOM uint32_t TAMP1TRG   : 1;            /*!< [1..1] Active level for RTC_TAMP1 input If TAMPFLT != 00 if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32_t TAMPIE     : 1;            /*!< [2..2] Tamper interrupt enable                                            */
      __IOM uint32_t TAMP2E     : 1;            /*!< [3..3] RTC_TAMP2 input detection enable                                   */
      __IOM uint32_t TAMP2TRG   : 1;            /*!< [4..4] Active level for RTC_TAMP2 input if TAMPFLT != 00: if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32_t TAMP3E     : 1;            /*!< [5..5] RTC_TAMP3 detection enable                                         */
      __IOM uint32_t TAMP3TRG   : 1;            /*!< [6..6] Active level for RTC_TAMP3 input if TAMPFLT != 00: if
                                                     TAMPFLT = 00:                                                             */
      __IOM uint32_t TAMPTS     : 1;            /*!< [7..7] Activate timestamp on tamper detection event TAMPTS is
                                                     valid even if TSE=0 in the RTC_CR register.                               */
      __IOM uint32_t TAMPFREQ   : 3;            /*!< [10..8] Tamper sampling frequency Determines the frequency at
                                                     which each of the RTC_TAMPx inputs are sampled.                           */
      __IOM uint32_t TAMPFLT    : 2;            /*!< [12..11] RTC_TAMPx filter count These bits determines the number
                                                     of consecutive samples at the specified level (TAMP*TRG)
                                                     needed to activate a Tamper event. TAMPFLT is valid for
                                                     each of the RTC_TAMPx inputs.                                             */
      __IOM uint32_t TAMPPRCH   : 2;            /*!< [14..13] RTC_TAMPx precharge duration These bit determines the
                                                     duration of time during which the pull-up/is activated
                                                     before each sample. TAMPPRCH is valid for each of the RTC_TAMPx
                                                     inputs.                                                                   */
      __IOM uint32_t TAMPPUDIS  : 1;            /*!< [15..15] RTC_TAMPx pull-up disable This bit determines if each
                                                     of the RTC_TAMPx pins are pre-charged before each sample.                 */
      __IOM uint32_t TAMP1IE    : 1;            /*!< [16..16] Tamper 1 interrupt enable                                        */
      __IOM uint32_t TAMP1NOERASE : 1;          /*!< [17..17] Tamper 1 no erase                                                */
      __IOM uint32_t TAMP1MF    : 1;            /*!< [18..18] Tamper 1 mask flag                                               */
      __IOM uint32_t TAMP2IE    : 1;            /*!< [19..19] Tamper 2 interrupt enable                                        */
      __IOM uint32_t TAMP2NOERASE : 1;          /*!< [20..20] Tamper 2 no erase                                                */
      __IOM uint32_t TAMP2MF    : 1;            /*!< [21..21] Tamper 2 mask flag                                               */
      __IOM uint32_t TAMP3IE    : 1;            /*!< [22..22] Tamper 3 interrupt enable                                        */
      __IOM uint32_t TAMP3NOERASE : 1;          /*!< [23..23] Tamper 3 no erase                                                */
      __IOM uint32_t TAMP3MF    : 1;            /*!< [24..24] Tamper 3 mask flag                                               */
            uint32_t            : 7;
    } RTC_TAMPCR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_ALRMASSR;                /*!< (@ 0x00000044) This register can be written only when ALRAE
                                                                    is reset in RTC_CR register, or in initialization
                                                                    mode.This register is write protected. The
                                                                    write access procedure is described in RTC
                                                                    register write protection on page9                         */
    
    struct {
      __IOM uint32_t SS         : 15;           /*!< [14..0] Sub seconds value This value is compared with the contents
                                                     of the synchronous prescaler counter to determine if Alarm
                                                     A is to be activated. Only bits 0 up MASKSS-1 are compared.               */
            uint32_t            : 9;
      __IOM uint32_t MASKSS     : 4;            /*!< [27..24] Mask the most-significant bits starting at this bit
                                                     ... The overflow bits of the synchronous counter (bits
                                                     15) is never compared. This bit can be different from 0
                                                     only after a shift operation.                                             */
            uint32_t            : 4;
    } RTC_ALRMASSR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_ALRMBSSR;                /*!< (@ 0x00000048) This register can be written only when ALRBE
                                                                    is reset in RTC_CR register, or in initialization
                                                                    mode.This register is write protected.The
                                                                    write access procedure is described in Section:
                                                                    RTC register write protection.                             */
    
    struct {
      __IOM uint32_t SS         : 15;           /*!< [14..0] Sub seconds value This value is compared with the contents
                                                     of the synchronous prescaler counter to determine if Alarm
                                                     B is to be activated. Only bits 0 up to MASKSS-1 are compared.            */
            uint32_t            : 9;
      __IOM uint32_t MASKSS     : 4;            /*!< [27..24] Mask the most-significant bits starting at this bit
                                                     ... The overflow bits of the synchronous counter (bits
                                                     15) is never compared. This bit can be different from 0
                                                     only after a shift operation.                                             */
            uint32_t            : 4;
    } RTC_ALRMBSSR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_OR;                      /*!< (@ 0x0000004C) RTC option register                                        */
    
    struct {
      __IOM uint32_t RTC_ALARM_TYPE : 1;        /*!< [0..0] RTC_ALARM output type on PC13                                      */
      __IOM uint32_t RTC_OUT_RMP : 1;           /*!< [1..1] RTC_OUT remap                                                      */
            uint32_t            : 30;
    } RTC_OR_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP0R;                   /*!< (@ 0x00000050) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP0R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP1R;                   /*!< (@ 0x00000054) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP1R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP2R;                   /*!< (@ 0x00000058) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP2R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP3R;                   /*!< (@ 0x0000005C) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP3R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP4R;                   /*!< (@ 0x00000060) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP4R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP5R;                   /*!< (@ 0x00000064) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP5R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP6R;                   /*!< (@ 0x00000068) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP6R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP7R;                   /*!< (@ 0x0000006C) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP7R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP8R;                   /*!< (@ 0x00000070) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP8R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP9R;                   /*!< (@ 0x00000074) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP9R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP10R;                  /*!< (@ 0x00000078) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP10R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP11R;                  /*!< (@ 0x0000007C) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP11R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP12R;                  /*!< (@ 0x00000080) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP12R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP13R;                  /*!< (@ 0x00000084) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP13R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP14R;                  /*!< (@ 0x00000088) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP14R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP15R;                  /*!< (@ 0x0000008C) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP15R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP16R;                  /*!< (@ 0x00000090) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP16R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP17R;                  /*!< (@ 0x00000094) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP17R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP18R;                  /*!< (@ 0x00000098) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP18R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP19R;                  /*!< (@ 0x0000009C) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP19R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP20R;                  /*!< (@ 0x000000A0) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP20R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP21R;                  /*!< (@ 0x000000A4) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP21R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP22R;                  /*!< (@ 0x000000A8) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP22R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP23R;                  /*!< (@ 0x000000AC) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP23R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP24R;                  /*!< (@ 0x000000B0) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP24R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP25R;                  /*!< (@ 0x000000B4) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP25R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP26R;                  /*!< (@ 0x000000B8) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP26R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP27R;                  /*!< (@ 0x000000BC) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP27R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP28R;                  /*!< (@ 0x000000C0) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP28R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP29R;                  /*!< (@ 0x000000C4) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP29R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP30R;                  /*!< (@ 0x000000C8) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP30R_b;
  } ;
  
  union {
    __IOM uint32_t RTC_BKP31R;                  /*!< (@ 0x000000CC) RTC backup registers                                       */
    
    struct {
      __IOM uint32_t BKP        : 32;           /*!< [31..0] The application can write or read data to and from these
                                                     registers. They are powered-on by VBAT when VDD is switched
                                                     off, so that they are not reset by System reset, and their
                                                     contents remain valid when the device operates in low-power
                                                     mode. This register is reset on a tamper detection event,
                                                     as long as TAMPxF=1. or when the Flash readout protection
                                                     is disabled.                                                              */
    } RTC_BKP31R_b;
  } ;
} RTC_Type;                                     /*!< Size = 208 (0xd0)                                                         */



/* =========================================================================================================================== */
/* ================                                           SAI4                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SAI (SAI4)
  */

typedef struct {                                /*!< (@ 0x58005400) SAI4 Structure                                             */
  
  union {
    __IOM uint32_t SAI_GCR;                     /*!< (@ 0x00000000) Global configuration register                              */
    
    struct {
      __IOM uint32_t SYNCIN     : 2;            /*!< [1..0] Synchronization inputs                                             */
            uint32_t            : 2;
      __IOM uint32_t SYNCOUT    : 2;            /*!< [5..4] Synchronization outputs These bits are set and cleared
                                                     by software.                                                              */
            uint32_t            : 26;
    } SAI_GCR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_ACR1;                    /*!< (@ 0x00000004) Configuration register 1                                   */
    
    struct {
      __IOM uint32_t MODE       : 2;            /*!< [1..0] SAIx audio block mode immediately                                  */
      __IOM uint32_t PRTCFG     : 2;            /*!< [3..2] Protocol configuration. These bits are set and cleared
                                                     by software. These bits have to be configured when the
                                                     audio block is disabled.                                                  */
            uint32_t            : 1;
      __IOM uint32_t DS         : 3;            /*!< [7..5] Data size. These bits are set and cleared by software.
                                                     These bits are ignored when the SPDIF protocols are selected
                                                     (bit PRTCFG[1:0]), because the frame and the data size
                                                     are fixed in such case. When the companding mode is selected
                                                     through COMP[1:0] bits, DS[1:0] are ignored since the data
                                                     size is fixed to 8 bits by the algorithm. These bits must
                                                     be configured when the audio block is disa                                */
      __IOM uint32_t LSBFIRST   : 1;            /*!< [8..8] Least significant bit first. This bit is set and cleared
                                                     by software. It must be configured when the audio block
                                                     is disabled. This bit has no meaning in AC97 audio protocol
                                                     since AC97 data are always transferred with the MSB first.
                                                     This bit has no meaning in SPDIF audio protocol since in
                                                     SPDIF data are always transferred with LSB first.                         */
      __IOM uint32_t CKSTR      : 1;            /*!< [9..9] Clock strobing edge. This bit is set and cleared by software.
                                                     It must be configured when the audio block is disabled.
                                                     This bit has no meaning in SPDIF audio protocol.                          */
      __IOM uint32_t SYNCEN     : 2;            /*!< [11..10] Synchronization enable. These bits are set and cleared
                                                     by software. They must be configured when the audio sub-block
                                                     is disabled. Note: The audio sub-block should be configured
                                                     as asynchronous when SPDIF mode is enabled.                               */
      __IOM uint32_t MONO       : 1;            /*!< [12..12] Mono mode. This bit is set and cleared by software.
                                                     It is meaningful only when the number of slots is equal
                                                     to 2. When the mono mode is selected, slot 0 data are duplicated
                                                     on slot 1 when the audio block operates as a transmitter.
                                                     In reception mode, the slot1 is discarded and only the
                                                     data received from slot 0 are stored. Refer to Section:
                                                     Mono/stereo mode for more details.                                        */
      __IOM uint32_t OUTDRIV    : 1;            /*!< [13..13] Output drive. This bit is set and cleared by software.
                                                     Note: This bit has to be set before enabling the audio
                                                     block and after the audio block configuration.                            */
            uint32_t            : 2;
      __IOM uint32_t SAIXEN     : 1;            /*!< [16..16] Audio block enable where x is A or B. This bit is set
                                                     by software. To switch off the audio block, the application
                                                     software must program this bit to 0 and poll the bit till
                                                     it reads back 0, meaning that the block is completely disabled.
                                                     Before setting this bit to 1, check that it is set to 0,
                                                     otherwise the enable command will not be taken into account.
                                                     This bit allows to control the state of SAIx audio                        */
      __IOM uint32_t DMAEN      : 1;            /*!< [17..17] DMA enable. This bit is set and cleared by software.
                                                     Note: Since the audio block defaults to operate as a transmitter
                                                     after reset, the MODE[1:0] bits must be configured before
                                                     setting DMAEN to avoid a DMA request in receiver mode.                    */
            uint32_t            : 1;
      __IOM uint32_t NOMCK      : 1;            /*!< [19..19] No divider                                                       */
      __IOM uint32_t MCKDIV     : 4;            /*!< [23..20] Master clock divider. These bits are set and cleared
                                                     by software. These bits are meaningless when the audio
                                                     block operates in slave mode. They have to be configured
                                                     when the audio block is disabled. Others: the master clock
                                                     frequency is calculated accordingly to the following formula:             */
            uint32_t            : 2;
      __IOM uint32_t OSR        : 1;            /*!< [26..26] Oversampling ratio for master clock                              */
            uint32_t            : 5;
    } SAI_ACR1_b;
  } ;
  
  union {
    __IOM uint32_t SAI_ACR2;                    /*!< (@ 0x00000008) Configuration register 2                                   */
    
    struct {
      __IOM uint32_t FTH        : 3;            /*!< [2..0] FIFO threshold. This bit is set and cleared by software.           */
      __OM  uint32_t FFLUSH     : 1;            /*!< [3..3] FIFO flush. This bit is set by software. It is always
                                                     read as 0. This bit should be configured when the SAI is
                                                     disabled.                                                                 */
      __IOM uint32_t TRIS       : 1;            /*!< [4..4] Tristate management on data line. This bit is set and
                                                     cleared by software. It is meaningful only if the audio
                                                     block is configured as a transmitter. This bit is not used
                                                     when the audio block is configured in SPDIF mode. It should
                                                     be configured when SAI is disabled. Refer to Section: Output
                                                     data line management on an inactive slot for more details.                */
      __IOM uint32_t MUTE       : 1;            /*!< [5..5] Mute. This bit is set and cleared by software. It is
                                                     meaningful only when the audio block operates as a transmitter.
                                                     The MUTE value is linked to value of MUTEVAL if the number
                                                     of slots is lower or equal to 2, or equal to 0 if it is
                                                     greater than 2. Refer to Section: Mute mode for more details.
                                                     Note: This bit is meaningless and should not be used for
                                                     SPDIF audio blocks.                                                       */
      __IOM uint32_t MUTEVAL    : 1;            /*!< [6..6] Mute value. This bit is set and cleared by software.It
                                                     must be written before enabling the audio block: SAIXEN.
                                                     This bit is meaningful only when the audio block operates
                                                     as a transmitter, the number of slots is lower or equal
                                                     to 2 and the MUTE bit is set. If more slots are declared,
                                                     the bit value sent during the transmission in mute mode
                                                     is equal to 0, whatever the value of MUTEVAL. if the number
                                                     of slo                                                                    */
      __IOM uint32_t MUTECNT    : 6;            /*!< [12..7] Mute counter. These bits are set and cleared by software.
                                                     They are used only in reception mode. The value set in
                                                     these bits is compared to the number of consecutive mute
                                                     frames detected in reception. When the number of mute frames
                                                     is equal to this value, the flag MUTEDET will be set and
                                                     an interrupt will be generated if bit MUTEDETIE is set.
                                                     Refer to Section: Mute mode for more details.                             */
      __IOM uint32_t CPL        : 1;            /*!< [13..13] Complement bit. This bit is set and cleared by software.
                                                     It defines the type of complement to be used for companding
                                                     mode Note: This bit has effect only when the companding
                                                     mode is -Law algorithm or A-Law algorithm.                                */
      __IOM uint32_t COMP       : 2;            /*!< [15..14] Companding mode. These bits are set and cleared by
                                                     software. The -Law and the A-Law log are a part of the
                                                     CCITT G.711 recommendation, the type of complement that
                                                     will be used depends on CPL bit. The data expansion or
                                                     data compression are determined by the state of bit MODE[0].
                                                     The data compression is applied if the audio block is configured
                                                     as a transmitter. The data expansion is automatically                     */
            uint32_t            : 16;
    } SAI_ACR2_b;
  } ;
  
  union {
    __IOM uint32_t SAI_AFRCR;                   /*!< (@ 0x0000000C) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32_t FRL        : 8;            /*!< [7..0] Frame length. These bits are set and cleared by software.
                                                     They define the audio frame length expressed in number
                                                     of SCK clock cycles: the number of bits in the frame is
                                                     equal to FRL[7:0] + 1. The minimum number of bits to transfer
                                                     in an audio frame must be equal to 8, otherwise the audio
                                                     block will behaves in an unexpected way. This is the case
                                                     when the data size is 8 bits and only one slot 0 is                       */
      __IOM uint32_t FSALL      : 7;            /*!< [14..8] Frame synchronization active level length. These bits
                                                     are set and cleared by software. They specify the length
                                                     in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the
                                                     active level of the FS signal in the audio frame These
                                                     bits are meaningless and are not used in AC97 or SPDIF
                                                     audio block configuration. They must be configured when
                                                     the audio block is disabled.                                              */
            uint32_t            : 1;
      __IM  uint32_t FSDEF      : 1;            /*!< [16..16] Frame synchronization definition. This bit is set and
                                                     cleared by software. When the bit is set, the number of
                                                     slots defined in the SAI_xSLOTR register has to be even.
                                                     It means that half of this number of slots will be dedicated
                                                     to the left channel and the other slots for the right channel
                                                     (e.g: this bit has to be set for I2S or MSB/LSB-justified
                                                     protocols...). This bit is meaningless and is not                         */
      __IOM uint32_t FSPOL      : 1;            /*!< [17..17] Frame synchronization polarity. This bit is set and
                                                     cleared by software. It is used to configure the level
                                                     of the start of frame on the FS signal. It is meaningless
                                                     and is not used in AC97 or SPDIF audio block configuration.
                                                     This bit must be configured when the audio block is disabled.             */
      __IOM uint32_t FSOFF      : 1;            /*!< [18..18] Frame synchronization offset. This bit is set and cleared
                                                     by software. It is meaningless and is not used in AC97
                                                     or SPDIF audio block configuration. This bit must be configured
                                                     when the audio block is disabled.                                         */
            uint32_t            : 13;
    } SAI_AFRCR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_ASLOTR;                  /*!< (@ 0x00000010) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32_t FBOFF      : 5;            /*!< [4..0] First bit offset These bits are set and cleared by software.
                                                     The value set in this bitfield defines the position of
                                                     the first data transfer bit in the slot. It represents
                                                     an offset value. In transmission mode, the bits outside
                                                     the data field are forced to 0. In reception mode, the
                                                     extra received bits are discarded. These bits must be set
                                                     when the audio block is disabled. They are ignored in                     */
            uint32_t            : 1;
      __IOM uint32_t SLOTSZ     : 2;            /*!< [7..6] Slot size This bits is set and cleared by software. The
                                                     slot size must be higher or equal to the data size. If
                                                     this condition is not respected, the behavior of the SAI
                                                     will be undetermined. Refer to Section: Output data line
                                                     management on an inactive slot for information on how to
                                                     drive SD line. These bits must be set when the audio block
                                                     is disabled. They are ignored in AC97 or SPDIF mod                        */
      __IOM uint32_t NBSLOT     : 4;            /*!< [11..8] Number of slots in an audio frame. These bits are set
                                                     and cleared by software. The value set in this bitfield
                                                     represents the number of slots + 1 in the audio frame (including
                                                     the number of inactive slots). The maximum number of slots
                                                     is 16. The number of slots should be even if FSDEF bit
                                                     in the SAI_xFRCR register is set. The number of slots must
                                                     be configured when the audio block is disabled. They are                  */
            uint32_t            : 4;
      __IOM uint32_t SLOTEN     : 16;           /*!< [31..16] Slot enable. These bits are set and cleared by software.
                                                     Each SLOTEN bit corresponds to a slot position from 0 to
                                                     15 (maximum 16 slots). The slot must be enabled when the
                                                     audio block is disabled. They are ignored in AC97 or SPDIF
                                                     mode.                                                                     */
    } SAI_ASLOTR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_AIM;                     /*!< (@ 0x00000014) Interrupt mask register 2                                  */
    
    struct {
      __IOM uint32_t OVRUDRIE   : 1;            /*!< [0..0] Overrun/underrun interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the OVRUDR bit in the SAI_xSR register
                                                     is set.                                                                   */
      __IOM uint32_t MUTEDETIE  : 1;            /*!< [1..1] Mute detection interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the MUTEDET bit in the SAI_xSR register
                                                     is set. This bit has a meaning only if the audio block
                                                     is configured in receiver mode.                                           */
      __IOM uint32_t WCKCFGIE   : 1;            /*!< [2..2] Wrong clock configuration interrupt enable. This bit
                                                     is set and cleared by software. This bit is taken into
                                                     account only if the audio block is configured as a master
                                                     (MODE[1] = 0) and NODIV = 0. It generates an interrupt
                                                     if the WCKCFG flag in the SAI_xSR register is set. Note:
                                                     This bit is used only in TDM mode and is meaningless in
                                                     other modes.                                                              */
      __IOM uint32_t FREQIE     : 1;            /*!< [3..3] FIFO request interrupt enable. This bit is set and cleared
                                                     by software. When this bit is set, an interrupt is generated
                                                     if the FREQ bit in the SAI_xSR register is set. Since the
                                                     audio block defaults to operate as a transmitter after
                                                     reset, the MODE bit must be configured before setting FREQIE
                                                     to avoid a parasitic interruption in receiver mode,                       */
      __IOM uint32_t CNRDYIE    : 1;            /*!< [4..4] Codec not ready interrupt enable (AC97). This bit is
                                                     set and cleared by software. When the interrupt is enabled,
                                                     the audio block detects in the slot 0 (tag0) of the AC97
                                                     frame if the Codec connected to this line is ready or not.
                                                     If it is not ready, the CNRDY flag in the SAI_xSR register
                                                     is set and an interruption i generated. This bit has a
                                                     meaning only if the AC97 mode is selected through                         */
      __IOM uint32_t AFSDETIE   : 1;            /*!< [5..5] Anticipated frame synchronization detection interrupt
                                                     enable. This bit is set and cleared by software. When this
                                                     bit is set, an interrupt will be generated if the AFSDET
                                                     bit in the SAI_xSR register is set. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
      __IOM uint32_t LFSDETIE   : 1;            /*!< [6..6] Late frame synchronization detection interrupt enable.
                                                     This bit is set and cleared by software. When this bit
                                                     is set, an interrupt will be generated if the LFSDET bit
                                                     is set in the SAI_xSR register. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
            uint32_t            : 25;
    } SAI_AIM_b;
  } ;
  
  union {
    __IM  uint32_t SAI_ASR;                     /*!< (@ 0x00000018) Status register                                            */
    
    struct {
      __IM  uint32_t OVRUDR     : 1;            /*!< [0..0] Overrun / underrun. This bit is read only. The overrun
                                                     and underrun conditions can occur only when the audio block
                                                     is configured as a receiver and a transmitter, respectively.
                                                     It can generate an interrupt if OVRUDRIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets COVRUDR bit in SAI_xCLRFR register.                                  */
      __IM  uint32_t MUTEDET    : 1;            /*!< [1..1] Mute detection. This bit is read only. This flag is set
                                                     if consecutive 0 values are received in each slot of a
                                                     given audio frame and for a consecutive number of audio
                                                     frames (set in the MUTECNT bit in the SAI_xCR2 register).
                                                     It can generate an interrupt if MUTEDETIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CMUTEDET in the SAI_xCLRFR register.                             */
      __IM  uint32_t WCKCFG     : 1;            /*!< [2..2] Wrong clock configuration flag. This bit is read only.
                                                     This bit is used only when the audio block operates in
                                                     master mode (MODE[1] = 0) and NODIV = 0. It can generate
                                                     an interrupt if WCKCFGIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CWCKCFG bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32_t FREQ       : 1;            /*!< [3..3] FIFO request. This bit is read only. The request depends
                                                     on the audio block configuration: If the block is configured
                                                     in transmission mode, the FIFO request is related to a
                                                     write request operation in the SAI_xDR. If the block configured
                                                     in reception, the FIFO request related to a read request
                                                     operation from the SAI_xDR. This flag can generate an interrupt
                                                     if FREQIE bit is set in SAI_xIM r                                         */
      __IM  uint32_t CNRDY      : 1;            /*!< [4..4] Codec not ready. This bit is read only. This bit is used
                                                     only when the AC97 audio protocol is selected in the SAI_xCR1
                                                     register and configured in receiver mode. It can generate
                                                     an interrupt if CNRDYIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CCNRDY bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32_t AFSDET     : 1;            /*!< [5..5] Anticipated frame synchronization detection. This bit
                                                     is read only. This flag can be set only if the audio block
                                                     is configured in slave mode. It is not used in AC97or SPDIF
                                                     mode. It can generate an interrupt if AFSDETIE bit is set
                                                     in SAI_xIM register. This flag is cleared when the software
                                                     sets CAFSDET bit in SAI_xCLRFR register.                                  */
      __IM  uint32_t LFSDET     : 1;            /*!< [6..6] Late frame synchronization detection. This bit is read
                                                     only. This flag can be set only if the audio block is configured
                                                     in slave mode. It is not used in AC97 or SPDIF mode. It
                                                     can generate an interrupt if LFSDETIE bit is set in the
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CLFSDET in SAI_xCLRFR register                                   */
            uint32_t            : 9;
      __IM  uint32_t FLVL       : 3;            /*!< [18..16] FIFO level threshold. This bit is read only. The FIFO
                                                     level threshold flag is managed only by hardware and its
                                                     setting depends on SAI block configuration (transmitter
                                                     or receiver mode). If the SAI block is configured as transmitter:
                                                     If SAI block is configured as receiver:                                   */
            uint32_t            : 13;
    } SAI_ASR_b;
  } ;
  
  union {
    __OM  uint32_t SAI_ACLRFR;                  /*!< (@ 0x0000001C) Clear flag register                                        */
    
    struct {
      __OM  uint32_t COVRUDR    : 1;            /*!< [0..0] Clear overrun / underrun. This bit is write only. Programming
                                                     this bit to 1 clears the OVRUDR flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32_t CMUTEDET   : 1;            /*!< [1..1] Mute detection flag. This bit is write only. Programming
                                                     this bit to 1 clears the MUTEDET flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32_t CWCKCFG    : 1;            /*!< [2..2] Clear wrong clock configuration flag. This bit is write
                                                     only. Programming this bit to 1 clears the WCKCFG flag
                                                     in the SAI_xSR register. This bit is used only when the
                                                     audio block is set as master (MODE[1] = 0) and NODIV =
                                                     0 in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
            uint32_t            : 1;
      __OM  uint32_t CCNRDY     : 1;            /*!< [4..4] Clear Codec not ready flag. This bit is write only. Programming
                                                     this bit to 1 clears the CNRDY flag in the SAI_xSR register.
                                                     This bit is used only when the AC97 audio protocol is selected
                                                     in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
      __OM  uint32_t CAFSDET    : 1;            /*!< [5..5] Clear anticipated frame synchronization detection flag.
                                                     This bit is write only. Programming this bit to 1 clears
                                                     the AFSDET flag in the SAI_xSR register. It is not used
                                                     in AC97or SPDIF mode. Reading this bit always returns the
                                                     value 0.                                                                  */
      __OM  uint32_t CLFSDET    : 1;            /*!< [6..6] Clear late frame synchronization detection flag. This
                                                     bit is write only. Programming this bit to 1 clears the
                                                     LFSDET flag in the SAI_xSR register. This bit is not used
                                                     in AC97or SPDIF mode Reading this bit always returns the
                                                     value 0.                                                                  */
            uint32_t            : 25;
    } SAI_ACLRFR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_ADR;                     /*!< (@ 0x00000020) Data register                                              */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] Data A write to this register loads the FIFO provided
                                                     the FIFO is not full. A read from this register empties
                                                     the FIFO if the FIFO is not empty.                                        */
    } SAI_ADR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BCR1;                    /*!< (@ 0x00000024) Configuration register 1                                   */
    
    struct {
      __IOM uint32_t MODE       : 2;            /*!< [1..0] SAIx audio block mode immediately                                  */
      __IOM uint32_t PRTCFG     : 2;            /*!< [3..2] Protocol configuration. These bits are set and cleared
                                                     by software. These bits have to be configured when the
                                                     audio block is disabled.                                                  */
            uint32_t            : 1;
      __IOM uint32_t DS         : 3;            /*!< [7..5] Data size. These bits are set and cleared by software.
                                                     These bits are ignored when the SPDIF protocols are selected
                                                     (bit PRTCFG[1:0]), because the frame and the data size
                                                     are fixed in such case. When the companding mode is selected
                                                     through COMP[1:0] bits, DS[1:0] are ignored since the data
                                                     size is fixed to 8 bits by the algorithm. These bits must
                                                     be configured when the audio block is disa                                */
      __IOM uint32_t LSBFIRST   : 1;            /*!< [8..8] Least significant bit first. This bit is set and cleared
                                                     by software. It must be configured when the audio block
                                                     is disabled. This bit has no meaning in AC97 audio protocol
                                                     since AC97 data are always transferred with the MSB first.
                                                     This bit has no meaning in SPDIF audio protocol since in
                                                     SPDIF data are always transferred with LSB first.                         */
      __IOM uint32_t CKSTR      : 1;            /*!< [9..9] Clock strobing edge. This bit is set and cleared by software.
                                                     It must be configured when the audio block is disabled.
                                                     This bit has no meaning in SPDIF audio protocol.                          */
      __IOM uint32_t SYNCEN     : 2;            /*!< [11..10] Synchronization enable. These bits are set and cleared
                                                     by software. They must be configured when the audio sub-block
                                                     is disabled. Note: The audio sub-block should be configured
                                                     as asynchronous when SPDIF mode is enabled.                               */
      __IOM uint32_t MONO       : 1;            /*!< [12..12] Mono mode. This bit is set and cleared by software.
                                                     It is meaningful only when the number of slots is equal
                                                     to 2. When the mono mode is selected, slot 0 data are duplicated
                                                     on slot 1 when the audio block operates as a transmitter.
                                                     In reception mode, the slot1 is discarded and only the
                                                     data received from slot 0 are stored. Refer to Section:
                                                     Mono/stereo mode for more details.                                        */
      __IOM uint32_t OUTDRIV    : 1;            /*!< [13..13] Output drive. This bit is set and cleared by software.
                                                     Note: This bit has to be set before enabling the audio
                                                     block and after the audio block configuration.                            */
            uint32_t            : 2;
      __IOM uint32_t SAIXEN     : 1;            /*!< [16..16] Audio block enable where x is A or B. This bit is set
                                                     by software. To switch off the audio block, the application
                                                     software must program this bit to 0 and poll the bit till
                                                     it reads back 0, meaning that the block is completely disabled.
                                                     Before setting this bit to 1, check that it is set to 0,
                                                     otherwise the enable command will not be taken into account.
                                                     This bit allows to control the state of SAIx audio                        */
      __IOM uint32_t DMAEN      : 1;            /*!< [17..17] DMA enable. This bit is set and cleared by software.
                                                     Note: Since the audio block defaults to operate as a transmitter
                                                     after reset, the MODE[1:0] bits must be configured before
                                                     setting DMAEN to avoid a DMA request in receiver mode.                    */
            uint32_t            : 1;
      __IOM uint32_t NOMCK      : 1;            /*!< [19..19] No divider                                                       */
      __IOM uint32_t MCKDIV     : 4;            /*!< [23..20] Master clock divider. These bits are set and cleared
                                                     by software. These bits are meaningless when the audio
                                                     block operates in slave mode. They have to be configured
                                                     when the audio block is disabled. Others: the master clock
                                                     frequency is calculated accordingly to the following formula:             */
            uint32_t            : 2;
      __IOM uint32_t OSR        : 1;            /*!< [26..26] Oversampling ratio for master clock                              */
            uint32_t            : 5;
    } SAI_BCR1_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BCR2;                    /*!< (@ 0x00000028) Configuration register 2                                   */
    
    struct {
      __IOM uint32_t FTH        : 3;            /*!< [2..0] FIFO threshold. This bit is set and cleared by software.           */
      __OM  uint32_t FFLUSH     : 1;            /*!< [3..3] FIFO flush. This bit is set by software. It is always
                                                     read as 0. This bit should be configured when the SAI is
                                                     disabled.                                                                 */
      __IOM uint32_t TRIS       : 1;            /*!< [4..4] Tristate management on data line. This bit is set and
                                                     cleared by software. It is meaningful only if the audio
                                                     block is configured as a transmitter. This bit is not used
                                                     when the audio block is configured in SPDIF mode. It should
                                                     be configured when SAI is disabled. Refer to Section: Output
                                                     data line management on an inactive slot for more details.                */
      __IOM uint32_t MUTE       : 1;            /*!< [5..5] Mute. This bit is set and cleared by software. It is
                                                     meaningful only when the audio block operates as a transmitter.
                                                     The MUTE value is linked to value of MUTEVAL if the number
                                                     of slots is lower or equal to 2, or equal to 0 if it is
                                                     greater than 2. Refer to Section: Mute mode for more details.
                                                     Note: This bit is meaningless and should not be used for
                                                     SPDIF audio blocks.                                                       */
      __IOM uint32_t MUTEVAL    : 1;            /*!< [6..6] Mute value. This bit is set and cleared by software.It
                                                     must be written before enabling the audio block: SAIXEN.
                                                     This bit is meaningful only when the audio block operates
                                                     as a transmitter, the number of slots is lower or equal
                                                     to 2 and the MUTE bit is set. If more slots are declared,
                                                     the bit value sent during the transmission in mute mode
                                                     is equal to 0, whatever the value of MUTEVAL. if the number
                                                     of slo                                                                    */
      __IOM uint32_t MUTECNT    : 6;            /*!< [12..7] Mute counter. These bits are set and cleared by software.
                                                     They are used only in reception mode. The value set in
                                                     these bits is compared to the number of consecutive mute
                                                     frames detected in reception. When the number of mute frames
                                                     is equal to this value, the flag MUTEDET will be set and
                                                     an interrupt will be generated if bit MUTEDETIE is set.
                                                     Refer to Section: Mute mode for more details.                             */
      __IOM uint32_t CPL        : 1;            /*!< [13..13] Complement bit. This bit is set and cleared by software.
                                                     It defines the type of complement to be used for companding
                                                     mode Note: This bit has effect only when the companding
                                                     mode is -Law algorithm or A-Law algorithm.                                */
      __IOM uint32_t COMP       : 2;            /*!< [15..14] Companding mode. These bits are set and cleared by
                                                     software. The -Law and the A-Law log are a part of the
                                                     CCITT G.711 recommendation, the type of complement that
                                                     will be used depends on CPL bit. The data expansion or
                                                     data compression are determined by the state of bit MODE[0].
                                                     The data compression is applied if the audio block is configured
                                                     as a transmitter. The data expansion is automatically                     */
            uint32_t            : 16;
    } SAI_BCR2_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BFRCR;                   /*!< (@ 0x0000002C) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32_t FRL        : 8;            /*!< [7..0] Frame length. These bits are set and cleared by software.
                                                     They define the audio frame length expressed in number
                                                     of SCK clock cycles: the number of bits in the frame is
                                                     equal to FRL[7:0] + 1. The minimum number of bits to transfer
                                                     in an audio frame must be equal to 8, otherwise the audio
                                                     block will behaves in an unexpected way. This is the case
                                                     when the data size is 8 bits and only one slot 0 is                       */
      __IOM uint32_t FSALL      : 7;            /*!< [14..8] Frame synchronization active level length. These bits
                                                     are set and cleared by software. They specify the length
                                                     in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the
                                                     active level of the FS signal in the audio frame These
                                                     bits are meaningless and are not used in AC97 or SPDIF
                                                     audio block configuration. They must be configured when
                                                     the audio block is disabled.                                              */
            uint32_t            : 1;
      __IM  uint32_t FSDEF      : 1;            /*!< [16..16] Frame synchronization definition. This bit is set and
                                                     cleared by software. When the bit is set, the number of
                                                     slots defined in the SAI_xSLOTR register has to be even.
                                                     It means that half of this number of slots will be dedicated
                                                     to the left channel and the other slots for the right channel
                                                     (e.g: this bit has to be set for I2S or MSB/LSB-justified
                                                     protocols...). This bit is meaningless and is not                         */
      __IOM uint32_t FSPOL      : 1;            /*!< [17..17] Frame synchronization polarity. This bit is set and
                                                     cleared by software. It is used to configure the level
                                                     of the start of frame on the FS signal. It is meaningless
                                                     and is not used in AC97 or SPDIF audio block configuration.
                                                     This bit must be configured when the audio block is disabled.             */
      __IOM uint32_t FSOFF      : 1;            /*!< [18..18] Frame synchronization offset. This bit is set and cleared
                                                     by software. It is meaningless and is not used in AC97
                                                     or SPDIF audio block configuration. This bit must be configured
                                                     when the audio block is disabled.                                         */
            uint32_t            : 13;
    } SAI_BFRCR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BSLOTR;                  /*!< (@ 0x00000030) This register has no meaning in AC97 and SPDIF
                                                                    audio protocol                                             */
    
    struct {
      __IOM uint32_t FBOFF      : 5;            /*!< [4..0] First bit offset These bits are set and cleared by software.
                                                     The value set in this bitfield defines the position of
                                                     the first data transfer bit in the slot. It represents
                                                     an offset value. In transmission mode, the bits outside
                                                     the data field are forced to 0. In reception mode, the
                                                     extra received bits are discarded. These bits must be set
                                                     when the audio block is disabled. They are ignored in                     */
            uint32_t            : 1;
      __IOM uint32_t SLOTSZ     : 2;            /*!< [7..6] Slot size This bits is set and cleared by software. The
                                                     slot size must be higher or equal to the data size. If
                                                     this condition is not respected, the behavior of the SAI
                                                     will be undetermined. Refer to Section: Output data line
                                                     management on an inactive slot for information on how to
                                                     drive SD line. These bits must be set when the audio block
                                                     is disabled. They are ignored in AC97 or SPDIF mod                        */
      __IOM uint32_t NBSLOT     : 4;            /*!< [11..8] Number of slots in an audio frame. These bits are set
                                                     and cleared by software. The value set in this bitfield
                                                     represents the number of slots + 1 in the audio frame (including
                                                     the number of inactive slots). The maximum number of slots
                                                     is 16. The number of slots should be even if FSDEF bit
                                                     in the SAI_xFRCR register is set. The number of slots must
                                                     be configured when the audio block is disabled. They are                  */
            uint32_t            : 4;
      __IOM uint32_t SLOTEN     : 16;           /*!< [31..16] Slot enable. These bits are set and cleared by software.
                                                     Each SLOTEN bit corresponds to a slot position from 0 to
                                                     15 (maximum 16 slots). The slot must be enabled when the
                                                     audio block is disabled. They are ignored in AC97 or SPDIF
                                                     mode.                                                                     */
    } SAI_BSLOTR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BIM;                     /*!< (@ 0x00000034) Interrupt mask register 2                                  */
    
    struct {
      __IOM uint32_t OVRUDRIE   : 1;            /*!< [0..0] Overrun/underrun interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the OVRUDR bit in the SAI_xSR register
                                                     is set.                                                                   */
      __IOM uint32_t MUTEDETIE  : 1;            /*!< [1..1] Mute detection interrupt enable. This bit is set and
                                                     cleared by software. When this bit is set, an interrupt
                                                     is generated if the MUTEDET bit in the SAI_xSR register
                                                     is set. This bit has a meaning only if the audio block
                                                     is configured in receiver mode.                                           */
      __IOM uint32_t WCKCFGIE   : 1;            /*!< [2..2] Wrong clock configuration interrupt enable. This bit
                                                     is set and cleared by software. This bit is taken into
                                                     account only if the audio block is configured as a master
                                                     (MODE[1] = 0) and NODIV = 0. It generates an interrupt
                                                     if the WCKCFG flag in the SAI_xSR register is set. Note:
                                                     This bit is used only in TDM mode and is meaningless in
                                                     other modes.                                                              */
      __IOM uint32_t FREQIE     : 1;            /*!< [3..3] FIFO request interrupt enable. This bit is set and cleared
                                                     by software. When this bit is set, an interrupt is generated
                                                     if the FREQ bit in the SAI_xSR register is set. Since the
                                                     audio block defaults to operate as a transmitter after
                                                     reset, the MODE bit must be configured before setting FREQIE
                                                     to avoid a parasitic interruption in receiver mode,                       */
      __IOM uint32_t CNRDYIE    : 1;            /*!< [4..4] Codec not ready interrupt enable (AC97). This bit is
                                                     set and cleared by software. When the interrupt is enabled,
                                                     the audio block detects in the slot 0 (tag0) of the AC97
                                                     frame if the Codec connected to this line is ready or not.
                                                     If it is not ready, the CNRDY flag in the SAI_xSR register
                                                     is set and an interruption i generated. This bit has a
                                                     meaning only if the AC97 mode is selected through                         */
      __IOM uint32_t AFSDETIE   : 1;            /*!< [5..5] Anticipated frame synchronization detection interrupt
                                                     enable. This bit is set and cleared by software. When this
                                                     bit is set, an interrupt will be generated if the AFSDET
                                                     bit in the SAI_xSR register is set. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
      __IOM uint32_t LFSDETIE   : 1;            /*!< [6..6] Late frame synchronization detection interrupt enable.
                                                     This bit is set and cleared by software. When this bit
                                                     is set, an interrupt will be generated if the LFSDET bit
                                                     is set in the SAI_xSR register. This bit is meaningless
                                                     in AC97, SPDIF mode or when the audio block operates as
                                                     a master.                                                                 */
            uint32_t            : 25;
    } SAI_BIM_b;
  } ;
  
  union {
    __IM  uint32_t SAI_BSR;                     /*!< (@ 0x00000038) Status register                                            */
    
    struct {
      __IM  uint32_t OVRUDR     : 1;            /*!< [0..0] Overrun / underrun. This bit is read only. The overrun
                                                     and underrun conditions can occur only when the audio block
                                                     is configured as a receiver and a transmitter, respectively.
                                                     It can generate an interrupt if OVRUDRIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets COVRUDR bit in SAI_xCLRFR register.                                  */
      __IM  uint32_t MUTEDET    : 1;            /*!< [1..1] Mute detection. This bit is read only. This flag is set
                                                     if consecutive 0 values are received in each slot of a
                                                     given audio frame and for a consecutive number of audio
                                                     frames (set in the MUTECNT bit in the SAI_xCR2 register).
                                                     It can generate an interrupt if MUTEDETIE bit is set in
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CMUTEDET in the SAI_xCLRFR register.                             */
      __IM  uint32_t WCKCFG     : 1;            /*!< [2..2] Wrong clock configuration flag. This bit is read only.
                                                     This bit is used only when the audio block operates in
                                                     master mode (MODE[1] = 0) and NODIV = 0. It can generate
                                                     an interrupt if WCKCFGIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CWCKCFG bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32_t FREQ       : 1;            /*!< [3..3] FIFO request. This bit is read only. The request depends
                                                     on the audio block configuration: If the block is configured
                                                     in transmission mode, the FIFO request is related to a
                                                     write request operation in the SAI_xDR. If the block configured
                                                     in reception, the FIFO request related to a read request
                                                     operation from the SAI_xDR. This flag can generate an interrupt
                                                     if FREQIE bit is set in SAI_xIM r                                         */
      __IM  uint32_t CNRDY      : 1;            /*!< [4..4] Codec not ready. This bit is read only. This bit is used
                                                     only when the AC97 audio protocol is selected in the SAI_xCR1
                                                     register and configured in receiver mode. It can generate
                                                     an interrupt if CNRDYIE bit is set in SAI_xIM register.
                                                     This flag is cleared when the software sets CCNRDY bit
                                                     in SAI_xCLRFR register.                                                   */
      __IM  uint32_t AFSDET     : 1;            /*!< [5..5] Anticipated frame synchronization detection. This bit
                                                     is read only. This flag can be set only if the audio block
                                                     is configured in slave mode. It is not used in AC97or SPDIF
                                                     mode. It can generate an interrupt if AFSDETIE bit is set
                                                     in SAI_xIM register. This flag is cleared when the software
                                                     sets CAFSDET bit in SAI_xCLRFR register.                                  */
      __IM  uint32_t LFSDET     : 1;            /*!< [6..6] Late frame synchronization detection. This bit is read
                                                     only. This flag can be set only if the audio block is configured
                                                     in slave mode. It is not used in AC97 or SPDIF mode. It
                                                     can generate an interrupt if LFSDETIE bit is set in the
                                                     SAI_xIM register. This flag is cleared when the software
                                                     sets bit CLFSDET in SAI_xCLRFR register                                   */
            uint32_t            : 9;
      __IM  uint32_t FLVL       : 3;            /*!< [18..16] FIFO level threshold. This bit is read only. The FIFO
                                                     level threshold flag is managed only by hardware and its
                                                     setting depends on SAI block configuration (transmitter
                                                     or receiver mode). If the SAI block is configured as transmitter:
                                                     If SAI block is configured as receiver:                                   */
            uint32_t            : 13;
    } SAI_BSR_b;
  } ;
  
  union {
    __OM  uint32_t SAI_BCLRFR;                  /*!< (@ 0x0000003C) Clear flag register                                        */
    
    struct {
      __OM  uint32_t COVRUDR    : 1;            /*!< [0..0] Clear overrun / underrun. This bit is write only. Programming
                                                     this bit to 1 clears the OVRUDR flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32_t CMUTEDET   : 1;            /*!< [1..1] Mute detection flag. This bit is write only. Programming
                                                     this bit to 1 clears the MUTEDET flag in the SAI_xSR register.
                                                     Reading this bit always returns the value 0.                              */
      __OM  uint32_t CWCKCFG    : 1;            /*!< [2..2] Clear wrong clock configuration flag. This bit is write
                                                     only. Programming this bit to 1 clears the WCKCFG flag
                                                     in the SAI_xSR register. This bit is used only when the
                                                     audio block is set as master (MODE[1] = 0) and NODIV =
                                                     0 in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
            uint32_t            : 1;
      __OM  uint32_t CCNRDY     : 1;            /*!< [4..4] Clear Codec not ready flag. This bit is write only. Programming
                                                     this bit to 1 clears the CNRDY flag in the SAI_xSR register.
                                                     This bit is used only when the AC97 audio protocol is selected
                                                     in the SAI_xCR1 register. Reading this bit always returns
                                                     the value 0.                                                              */
      __OM  uint32_t CAFSDET    : 1;            /*!< [5..5] Clear anticipated frame synchronization detection flag.
                                                     This bit is write only. Programming this bit to 1 clears
                                                     the AFSDET flag in the SAI_xSR register. It is not used
                                                     in AC97or SPDIF mode. Reading this bit always returns the
                                                     value 0.                                                                  */
      __OM  uint32_t CLFSDET    : 1;            /*!< [6..6] Clear late frame synchronization detection flag. This
                                                     bit is write only. Programming this bit to 1 clears the
                                                     LFSDET flag in the SAI_xSR register. This bit is not used
                                                     in AC97or SPDIF mode Reading this bit always returns the
                                                     value 0.                                                                  */
            uint32_t            : 25;
    } SAI_BCLRFR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_BDR;                     /*!< (@ 0x00000040) Data register                                              */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] Data A write to this register loads the FIFO provided
                                                     the FIFO is not full. A read from this register empties
                                                     the FIFO if the FIFO is not empty.                                        */
    } SAI_BDR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_PDMCR;                   /*!< (@ 0x00000044) PDM control register                                       */
    
    struct {
      __IOM uint32_t PDMEN      : 1;            /*!< [0..0] PDM enable                                                         */
            uint32_t            : 3;
      __IOM uint32_t MICNBR     : 2;            /*!< [5..4] Number of microphones                                              */
            uint32_t            : 2;
      __IOM uint32_t CKEN1      : 1;            /*!< [8..8] Clock enable of bitstream clock number 1                           */
      __IOM uint32_t CKEN2      : 1;            /*!< [9..9] Clock enable of bitstream clock number 2                           */
      __IOM uint32_t CKEN3      : 1;            /*!< [10..10] Clock enable of bitstream clock number 3                         */
      __IOM uint32_t CKEN4      : 1;            /*!< [11..11] Clock enable of bitstream clock number 4                         */
            uint32_t            : 20;
    } SAI_PDMCR_b;
  } ;
  
  union {
    __IOM uint32_t SAI_PDMDLY;                  /*!< (@ 0x00000048) PDM delay register                                         */
    
    struct {
      __IOM uint32_t DLYM1L     : 3;            /*!< [2..0] Delay line adjust for first microphone of pair 1                   */
            uint32_t            : 1;
      __IOM uint32_t DLYM1R     : 3;            /*!< [6..4] Delay line adjust for second microphone of pair 1                  */
            uint32_t            : 1;
      __IOM uint32_t DLYM2L     : 3;            /*!< [10..8] Delay line for first microphone of pair 2                         */
            uint32_t            : 1;
      __IOM uint32_t DLYM2R     : 3;            /*!< [14..12] Delay line for second microphone of pair 2                       */
            uint32_t            : 1;
      __IOM uint32_t DLYM3L     : 3;            /*!< [18..16] Delay line for first microphone of pair 3                        */
            uint32_t            : 1;
      __IOM uint32_t DLYM3R     : 3;            /*!< [22..20] Delay line for second microphone of pair 3                       */
            uint32_t            : 1;
      __IOM uint32_t DLYM4L     : 3;            /*!< [26..24] Delay line for first microphone of pair 4                        */
            uint32_t            : 1;
      __IOM uint32_t DLYM4R     : 3;            /*!< [30..28] Delay line for second microphone of pair 4                       */
            uint32_t            : 1;
    } SAI_PDMDLY_b;
  } ;
} SAI4_Type;                                    /*!< Size = 76 (0x4c)                                                          */



/* =========================================================================================================================== */
/* ================                                          SDMMC1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SDMMC1 (SDMMC1)
  */

typedef struct {                                /*!< (@ 0x52007000) SDMMC1 Structure                                           */
  
  union {
    __IOM uint32_t SDMMC_POWER;                 /*!< (@ 0x00000000) SDMMC power control register                               */
    
    struct {
      __IOM uint32_t PWRCTRL    : 2;            /*!< [1..0] SDMMC state control bits. These bits can only be written
                                                     when the SDMMC is not in the power-on state (PWRCTRL?11).
                                                     These bits are used to define the functional state of the
                                                     SDMMC signals: Any further write will be ignored, PWRCTRL
                                                     value will keep 11.                                                       */
      __IOM uint32_t VSWITCH    : 1;            /*!< [2..2] Voltage switch sequence start. This bit is used to start
                                                     the timing critical section of the voltage switch sequence:               */
      __IOM uint32_t VSWITCHEN  : 1;            /*!< [3..3] Voltage switch procedure enable. This bit can only be
                                                     written by firmware when CPSM is disabled (CPSMEN = 0).
                                                     This bit is used to stop the SDMMC_CK after the voltage
                                                     switch command response:                                                  */
      __IOM uint32_t DIRPOL     : 1;            /*!< [4..4] Data and command direction signals polarity selection.
                                                     This bit can only be written when the SDMMC is in the power-off
                                                     state (PWRCTRL = 00).                                                     */
            uint32_t            : 27;
    } SDMMC_POWER_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_CLKCR;                 /*!< (@ 0x00000004) The SDMMC_CLKCR register controls the SDMMC_CK
                                                                    output clock, the SDMMC_RX_CLK receive clock,
                                                                    and the bus width.                                         */
    
    struct {
      __IOM uint32_t CLKDIV     : 10;           /*!< [9..0] Clock divide factor This bit can only be written when
                                                     the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT
                                                     = 0). This field defines the divide factor between the
                                                     input clock (SDMMCCLK) and the output clock (SDMMC_CK):
                                                     SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc..
                                                     xxx: etc..                                                                */
            uint32_t            : 2;
      __IOM uint32_t PWRSAV     : 1;            /*!< [12..12] Power saving configuration bit This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock
                                                     output can be disabled when the bus is idle by setting
                                                     PWRSAV:                                                                   */
            uint32_t            : 1;
      __IOM uint32_t WIDBUS     : 2;            /*!< [15..14] Wide bus mode enable bit This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
      __IOM uint32_t NEGEDGE    : 1;            /*!< [16..16] SDMMC_CK dephasing selection bit for data and Command.
                                                     This bit can only be written when the CPSM and DPSM are
                                                     not active (CPSMACT = 0 and DPSMACT = 0). When clock division
                                                     = 1 (CLKDIV = 0), this bit has no effect. Data and Command
                                                     change on SDMMC_CK falling edge. When clock division &gt;1
                                                     (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on
                                                     SDMMCCLK rising edge. When clock division >                               */
      __IOM uint32_t HWFC_EN    : 1;            /*!< [17..17] Hardware flow control enable This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0) When Hardware flow control is enabled, the
                                                     meaning of the TXFIFOE and RXFIFOF flags change, please
                                                     see SDMMC status register definition in Section56.8.11.                   */
      __IOM uint32_t DDR        : 1;            /*!< [18..18] Data rate signaling selection This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0) DDR rate shall only be selected with
                                                     4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1
                                                     has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate
                                                     shall only be selected with clock division &gt;1. (CLKDIV
                                                     &gt; 0)                                                                   */
      __IOM uint32_t BUSSPEED   : 1;            /*!< [19..19] Bus speed mode selection between DS, HS, SDR12, SDR25
                                                     and SDR50, DDR50, SDR104. This bit can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
      __IOM uint32_t SELCLKRX   : 2;            /*!< [21..20] Receive clock selection. These bits can only be written
                                                     when the CPSM and DPSM are not active (CPSMACT = 0 and
                                                     DPSMACT = 0)                                                              */
            uint32_t            : 10;
    } SDMMC_CLKCR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_ARGR;                  /*!< (@ 0x00000008) The SDMMC_ARGR register contains a 32-bit command
                                                                    argument, which is sent to a card as part
                                                                    of a command message.                                      */
    
    struct {
      __IOM uint32_t CMDARG     : 32;           /*!< [31..0] Command argument. These bits can only be written by
                                                     firmware when CPSM is disabled (CPSMEN = 0). Command argument
                                                     sent to a card as part of a command message. If a command
                                                     contains an argument, it must be loaded into this register
                                                     before writing a command to the command register.                         */
    } SDMMC_ARGR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_CMDR;                  /*!< (@ 0x0000000C) The SDMMC_CMDR register contains the command
                                                                    index and command type bits. The command
                                                                    index is sent to a card as part of a command
                                                                    message. The command type bits control the
                                                                    command path state machine (CPSM).                         */
    
    struct {
      __IOM uint32_t CMDINDEX   : 6;            /*!< [5..0] Command index. This bit can only be written by firmware
                                                     when CPSM is disabled (CPSMEN = 0). The command index is
                                                     sent to the card as part of a command message.                            */
      __IOM uint32_t CMDTRANS   : 1;            /*!< [6..6] The CPSM treats the command as a data transfer command,
                                                     stops the interrupt period, and signals DataEnable to the
                                                     DPSM This bit can only be written by firmware when CPSM
                                                     is disabled (CPSMEN = 0). If this bit is set, the CPSM
                                                     issues an end of interrupt period and issues DataEnable
                                                     signal to the DPSM when the command is sent.                              */
      __IOM uint32_t CMDSTOP    : 1;            /*!< [7..7] The CPSM treats the command as a Stop Transmission command
                                                     and signals Abort to the DPSM. This bit can only be written
                                                     by firmware when CPSM is disabled (CPSMEN = 0). If this
                                                     bit is set, the CPSM issues the Abort signal to the DPSM
                                                     when the command is sent.                                                 */
      __IOM uint32_t WAITRESP   : 2;            /*!< [9..8] Wait for response bits. This bit can only be written
                                                     by firmware when CPSM is disabled (CPSMEN = 0). They are
                                                     used to configure whether the CPSM is to wait for a response,
                                                     and if yes, which kind of response.                                       */
      __IOM uint32_t WAITINT    : 1;            /*!< [10..10] CPSM waits for interrupt request. If this bit is set,
                                                     the CPSM disables command timeout and waits for an card
                                                     interrupt request (Response). If this bit is cleared in
                                                     the CPSM Wait state, will cause the abort of the interrupt
                                                     mode.                                                                     */
      __IOM uint32_t WAITPEND   : 1;            /*!< [11..11] CPSM Waits for end of data transfer (CmdPend internal
                                                     signal) from DPSM. This bit when set, the CPSM waits for
                                                     the end of data transfer trigger before it starts sending
                                                     a command. WAITPEND is only taken into account when DTMODE
                                                     = MMC stream data transfer, WIDBUS = 1-bit wide bus mode,
                                                     DPSMACT = 1 and DTDIR = from host to card.                                */
      __IOM uint32_t CPSMEN     : 1;            /*!< [12..12] Command path state machine (CPSM) Enable bit This bit
                                                     is written 1 by firmware, and cleared by hardware when
                                                     the CPSM enters the Idle state. If this bit is set, the
                                                     CPSM is enabled. When DTEN = 1, no command will be transfered
                                                     nor boot procedure will be started. CPSMEN is cleared to
                                                     0.                                                                        */
      __IOM uint32_t DTHOLD     : 1;            /*!< [13..13] Hold new data block transmission and reception in the
                                                     DPSM. If this bit is set, the DPSM will not move from the
                                                     Wait_S state to the Send state or from the Wait_R state
                                                     to the Receive state.                                                     */
      __IOM uint32_t BOOTMODE   : 1;            /*!< [14..14] Select the boot mode procedure to be used. This bit
                                                     can only be written by firmware when CPSM is disabled (CPSMEN
                                                     = 0)                                                                      */
      __IOM uint32_t BOOTEN     : 1;            /*!< [15..15] Enable boot mode procedure.                                      */
      __IOM uint32_t CMDSUSPEND : 1;            /*!< [16..16] The CPSM treats the command as a Suspend or Resume
                                                     command and signals interrupt period start/end. This bit
                                                     can only be written by firmware when CPSM is disabled (CPSMEN
                                                     = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command,
                                                     start interrupt period when response bit BS=0. CMDSUSPEND
                                                     = 1 and CMDTRANS = 1 Resume command with data, end interrupt
                                                     period when response bit DF=1.                                            */
            uint32_t            : 15;
    } SDMMC_CMDR_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_RESPCMDR;              /*!< (@ 0x00000010) SDMMC command response register                            */
    
    struct {
      __IM  uint32_t RESPCMD    : 6;            /*!< [5..0] Response command index                                             */
            uint32_t            : 26;
    } SDMMC_RESPCMDR_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_RESP1R;                /*!< (@ 0x00000014) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32_t CARDSTATUS1 : 32;          /*!< [31..0] see Table 432                                                     */
    } SDMMC_RESP1R_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_RESP2R;                /*!< (@ 0x00000018) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32_t CARDSTATUS2 : 32;          /*!< [31..0] see Table404.                                                     */
    } SDMMC_RESP2R_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_RESP3R;                /*!< (@ 0x0000001C) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32_t CARDSTATUS3 : 32;          /*!< [31..0] see Table404.                                                     */
    } SDMMC_RESP3R_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_RESP4R;                /*!< (@ 0x00000020) The SDMMC_RESP1/2/3/4R registers contain the
                                                                    status of a card, which is part of the received
                                                                    response.                                                  */
    
    struct {
      __IM  uint32_t CARDSTATUS4 : 32;          /*!< [31..0] see Table404.                                                     */
    } SDMMC_RESP4R_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_DTIMER;                /*!< (@ 0x00000024) The SDMMC_DTIMER register contains the data timeout
                                                                    period, in card bus clock periods. A counter
                                                                    loads the value from the SDMMC_DTIMER register,
                                                                    and starts decrementing when the data path
                                                                    state machine (DPSM) enters the Wait_R or
                                                                    Busy state. If the timer reaches 0 while
                                                                    the DPSM is in either of these states, the
                                                                    timeout status flag is set.                                */
    
    struct {
      __IOM uint32_t DATATIME   : 32;           /*!< [31..0] Data and R1b busy timeout period This bit can only be
                                                     written when the CPSM and DPSM are not active (CPSMACT
                                                     = 0 and DPSMACT = 0). Data and R1b busy timeout period
                                                     expressed in card bus clock periods.                                      */
    } SDMMC_DTIMER_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_DLENR;                 /*!< (@ 0x00000028) The SDMMC_DLENR register contains the number
                                                                    of data bytes to be transferred. The value
                                                                    is loaded into the data counter when data
                                                                    transfer starts.                                           */
    
    struct {
      __IOM uint32_t DATALENGTH : 25;           /*!< [24..0] Data length value This register can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0). Number
                                                     of data bytes to be transferred. When DDR = 1 DATALENGTH
                                                     is truncated to a multiple of 2. (The last odd byte is
                                                     not transfered) When DATALENGTH = 0 no data will be transfered,
                                                     when requested by a CPSMEN and CMDTRANS = 1 also no command
                                                     will be transfered. DTEN and CPSMEN are cleared to                        */
            uint32_t            : 7;
    } SDMMC_DLENR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_DCTRL;                 /*!< (@ 0x0000002C) The SDMMC_DCTRL register control the data path
                                                                    state machine (DPSM).                                      */
    
    struct {
      __IOM uint32_t DTEN       : 1;            /*!< [0..0] Data transfer enable bit This bit can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0). This bit
                                                     is cleared by Hardware when data transfer completes. This
                                                     bit shall only be used to transfer data when no associated
                                                     data transfer command is used, i.e. shall not be used with
                                                     SD or eMMC cards.                                                         */
      __IOM uint32_t DTDIR      : 1;            /*!< [1..1] Data transfer direction selection This bit can only be
                                                     written by firmware when DPSM is inactive (DPSMACT = 0).                  */
      __IOM uint32_t DTMODE     : 2;            /*!< [3..2] Data transfer mode selection. This bit can only be written
                                                     by firmware when DPSM is inactive (DPSMACT = 0).                          */
      __IOM uint32_t DBLOCKSIZE : 4;            /*!< [7..4] Data block size This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0). Define the data block
                                                     length when the block data transfer mode is selected: When
                                                     DATALENGTH is not a multiple of DBLOCKSIZE, the transfered
                                                     data is truncated at a multiple of DBLOCKSIZE. (Any remain
                                                     data will not be transfered.) When DDR = 1, DBLOCKSIZE
                                                     = 0000 shall not be used. (No data will be                                */
      __IOM uint32_t RWSTART    : 1;            /*!< [8..8] Read wait start. If this bit is set, read wait operation
                                                     starts.                                                                   */
      __IOM uint32_t RWSTOP     : 1;            /*!< [9..9] Read wait stop This bit is written by firmware and auto
                                                     cleared by hardware when the DPSM moves from the READ_WAIT
                                                     state to the WAIT_R or IDLE state.                                        */
      __IOM uint32_t RWMOD      : 1;            /*!< [10..10] Read wait mode. This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0).                                      */
      __IOM uint32_t SDIOEN     : 1;            /*!< [11..11] SD I/O interrupt enable functions This bit can only
                                                     be written by firmware when DPSM is inactive (DPSMACT =
                                                     0). If this bit is set, the DPSM enables the SD I/O card
                                                     specific interrupt operation.                                             */
      __IOM uint32_t BOOTACKEN  : 1;            /*!< [12..12] Enable the reception of the boot acknowledgment. This
                                                     bit can only be written by firmware when DPSM is inactive
                                                     (DPSMACT = 0).                                                            */
      __IOM uint32_t FIFORST    : 1;            /*!< [13..13] FIFO reset, will flush any remaining data. This bit
                                                     can only be written by firmware when IDMAEN= 0 and DPSM
                                                     is active (DPSMACT = 1). This bit will only take effect
                                                     when a transfer error or transfer hold occurs.                            */
            uint32_t            : 18;
    } SDMMC_DCTRL_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_DCNTR;                 /*!< (@ 0x00000030) The SDMMC_DCNTR register loads the value from
                                                                    the data length register (see SDMMC_DLENR)
                                                                    when the DPSM moves from the Idle state
                                                                    to the Wait_R or Wait_S state. As data is
                                                                    transferred, the counter decrements the
                                                                    value until it reaches 0. The DPSM then
                                                                    moves to the Idle state and when there has
                                                                    been no error, the data status end flag
                                                                    (DATAEND) is set.                                          */
    
    struct {
      __IM  uint32_t DATACOUNT  : 25;           /*!< [24..0] Data count value When read, the number of remaining
                                                     data bytes to be transferred is returned. Write has no
                                                     effect.                                                                   */
            uint32_t            : 7;
    } SDMMC_DCNTR_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_STAR;                  /*!< (@ 0x00000034) The SDMMC_STAR register is a read-only register.
                                                                    It contains two types of flag:Static flags
                                                                    (bits [29,21,11:0]): these bits remain asserted
                                                                    until they are cleared by writing to the
                                                                    SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic
                                                                    flags (bits [20:12]): these bits change
                                                                    state depending on the state of the underlying
                                                                    logic (for example, FIFO full and empty
                                                                    flags are asserted and de-asserted as data
                                                                    while written                                              */
    
    struct {
      __IM  uint32_t CCRCFAIL   : 1;            /*!< [0..0] Command response received (CRC check failed). Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32_t DCRCFAIL   : 1;            /*!< [1..1] Data block sent/received (CRC check failed). Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32_t CTIMEOUT   : 1;            /*!< [2..2] Command response timeout. Interrupt flag is cleared by
                                                     writing corresponding interrupt clear bit in SDMMC_ICR.
                                                     The Command Timeout period has a fixed value of 64 SDMMC_CK
                                                     clock periods.                                                            */
      __IM  uint32_t DTIMEOUT   : 1;            /*!< [3..3] Data timeout. Interrupt flag is cleared by writing corresponding
                                                     interrupt clear bit in SDMMC_ICR.                                         */
      __IM  uint32_t TXUNDERR   : 1;            /*!< [4..4] Transmit FIFO underrun error or IDMA read transfer error.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32_t RXOVERR    : 1;            /*!< [5..5] Received FIFO overrun error or IDMA write transfer error.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32_t CMDREND    : 1;            /*!< [6..6] Command response received (CRC check passed, or no CRC).
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32_t CMDSENT    : 1;            /*!< [7..7] Command sent (no response required). Interrupt flag is
                                                     cleared by writing corresponding interrupt clear bit in
                                                     SDMMC_ICR.                                                                */
      __IM  uint32_t DATAEND    : 1;            /*!< [8..8] Data transfer ended correctly. (data counter, DATACOUNT
                                                     is zero and no errors occur). Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32_t DHOLD      : 1;            /*!< [9..9] Data transfer Hold. Interrupt flag is cleared by writing
                                                     corresponding interrupt clear bit in SDMMC_ICR.                           */
      __IM  uint32_t DBCKEND    : 1;            /*!< [10..10] Data block sent/received. (CRC check passed) and DPSM
                                                     moves to the READWAIT state. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32_t DABORT     : 1;            /*!< [11..11] Data transfer aborted by CMD12. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32_t DPSMACT    : 1;            /*!< [12..12] Data path state machine active, i.e. not in Idle state.
                                                     This is a hardware status flag only, does not generate
                                                     an interrupt.                                                             */
      __IM  uint32_t CPSMACT    : 1;            /*!< [13..13] Command path state machine active, i.e. not in Idle
                                                     state. This is a hardware status flag only, does not generate
                                                     an interrupt.                                                             */
      __IM  uint32_t TXFIFOHE   : 1;            /*!< [14..14] Transmit FIFO half empty At least half the number of
                                                     words can be written into the FIFO. This bit is cleared
                                                     when the FIFO becomes half+1 full.                                        */
      __IM  uint32_t RXFIFOHF   : 1;            /*!< [15..15] Receive FIFO half full There are at least half the
                                                     number of words in the FIFO. This bit is cleared when the
                                                     FIFO becomes half+1 empty.                                                */
      __IM  uint32_t TXFIFOF    : 1;            /*!< [16..16] Transmit FIFO full This is a hardware status flag only,
                                                     does not generate an interrupt. This bit is cleared when
                                                     one FIFO location becomes empty.                                          */
      __IM  uint32_t RXFIFOF    : 1;            /*!< [17..17] Receive FIFO full This bit is cleared when one FIFO
                                                     location becomes empty.                                                   */
      __IM  uint32_t TXFIFOE    : 1;            /*!< [18..18] Transmit FIFO empty This bit is cleared when one FIFO
                                                     location becomes full.                                                    */
      __IM  uint32_t RXFIFOE    : 1;            /*!< [19..19] Receive FIFO empty This is a hardware status flag only,
                                                     does not generate an interrupt. This bit is cleared when
                                                     one FIFO location becomes full.                                           */
      __IM  uint32_t BUSYD0     : 1;            /*!< [20..20] Inverted value of SDMMC_D0 line (Busy), sampled at
                                                     the end of a CMD response and a second time 2 SDMMC_CK
                                                     cycles after the CMD response. This bit is reset to not
                                                     busy when the SDMMCD0 line changes from busy to not busy.
                                                     This bit does not signal busy due to data transfer. This
                                                     is a hardware status flag only, it does not generate an
                                                     interrupt.                                                                */
      __IM  uint32_t BUSYD0END  : 1;            /*!< [21..21] end of SDMMC_D0 Busy following a CMD response detected.
                                                     This indicates only end of busy following a CMD response.
                                                     This bit does not signal busy due to data transfer. Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32_t SDIOIT     : 1;            /*!< [22..22] SDIO interrupt received. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32_t ACKFAIL    : 1;            /*!< [23..23] Boot acknowledgment received (boot acknowledgment check
                                                     fail). Interrupt flag is cleared by writing corresponding
                                                     interrupt clear bit in SDMMC_ICR.                                         */
      __IM  uint32_t ACKTIMEOUT : 1;            /*!< [24..24] Boot acknowledgment timeout. Interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
      __IM  uint32_t VSWEND     : 1;            /*!< [25..25] Voltage switch critical timing section completion.
                                                     Interrupt flag is cleared by writing corresponding interrupt
                                                     clear bit in SDMMC_ICR.                                                   */
      __IM  uint32_t CKSTOP     : 1;            /*!< [26..26] SDMMC_CK stopped in Voltage switch procedure. Interrupt
                                                     flag is cleared by writing corresponding interrupt clear
                                                     bit in SDMMC_ICR.                                                         */
      __IM  uint32_t IDMATE     : 1;            /*!< [27..27] IDMA transfer error. Interrupt flag is cleared by writing
                                                     corresponding interrupt clear bit in SDMMC_ICR.                           */
      __IM  uint32_t IDMABTC    : 1;            /*!< [28..28] IDMA buffer transfer complete. interrupt flag is cleared
                                                     by writing corresponding interrupt clear bit in SDMMC_ICR.                */
            uint32_t            : 3;
    } SDMMC_STAR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_ICR;                   /*!< (@ 0x00000038) The SDMMC_ICR register is a write-only register.
                                                                    Writing a bit with 1 clears the corresponding
                                                                    bit in the SDMMC_STAR status register.                     */
    
    struct {
      __IOM uint32_t CCRCFAILC  : 1;            /*!< [0..0] CCRCFAIL flag clear bit Set by software to clear the
                                                     CCRCFAIL flag.                                                            */
      __IOM uint32_t DCRCFAILC  : 1;            /*!< [1..1] DCRCFAIL flag clear bit Set by software to clear the
                                                     DCRCFAIL flag.                                                            */
      __IOM uint32_t CTIMEOUTC  : 1;            /*!< [2..2] CTIMEOUT flag clear bit Set by software to clear the
                                                     CTIMEOUT flag.                                                            */
      __IOM uint32_t DTIMEOUTC  : 1;            /*!< [3..3] DTIMEOUT flag clear bit Set by software to clear the
                                                     DTIMEOUT flag.                                                            */
      __IOM uint32_t TXUNDERRC  : 1;            /*!< [4..4] TXUNDERR flag clear bit Set by software to clear TXUNDERR
                                                     flag.                                                                     */
      __IOM uint32_t RXOVERRC   : 1;            /*!< [5..5] RXOVERR flag clear bit Set by software to clear the RXOVERR
                                                     flag.                                                                     */
      __IOM uint32_t CMDRENDC   : 1;            /*!< [6..6] CMDREND flag clear bit Set by software to clear the CMDREND
                                                     flag.                                                                     */
      __IOM uint32_t CMDSENTC   : 1;            /*!< [7..7] CMDSENT flag clear bit Set by software to clear the CMDSENT
                                                     flag.                                                                     */
      __IOM uint32_t DATAENDC   : 1;            /*!< [8..8] DATAEND flag clear bit Set by software to clear the DATAEND
                                                     flag.                                                                     */
      __IOM uint32_t DHOLDC     : 1;            /*!< [9..9] DHOLD flag clear bit Set by software to clear the DHOLD
                                                     flag.                                                                     */
      __IOM uint32_t DBCKENDC   : 1;            /*!< [10..10] DBCKEND flag clear bit Set by software to clear the
                                                     DBCKEND flag.                                                             */
      __IOM uint32_t DABORTC    : 1;            /*!< [11..11] DABORT flag clear bit Set by software to clear the
                                                     DABORT flag.                                                              */
            uint32_t            : 9;
      __IOM uint32_t BUSYD0ENDC : 1;            /*!< [21..21] BUSYD0END flag clear bit Set by software to clear the
                                                     BUSYD0END flag.                                                           */
      __IOM uint32_t SDIOITC    : 1;            /*!< [22..22] SDIOIT flag clear bit Set by software to clear the
                                                     SDIOIT flag.                                                              */
      __IOM uint32_t ACKFAILC   : 1;            /*!< [23..23] ACKFAIL flag clear bit Set by software to clear the
                                                     ACKFAIL flag.                                                             */
      __IOM uint32_t ACKTIMEOUTC : 1;           /*!< [24..24] ACKTIMEOUT flag clear bit Set by software to clear
                                                     the ACKTIMEOUT flag.                                                      */
      __IOM uint32_t VSWENDC    : 1;            /*!< [25..25] VSWEND flag clear bit Set by software to clear the
                                                     VSWEND flag.                                                              */
      __IOM uint32_t CKSTOPC    : 1;            /*!< [26..26] CKSTOP flag clear bit Set by software to clear the
                                                     CKSTOP flag.                                                              */
      __IOM uint32_t IDMATEC    : 1;            /*!< [27..27] IDMA transfer error clear bit Set by software to clear
                                                     the IDMATE flag.                                                          */
      __IOM uint32_t IDMABTCC   : 1;            /*!< [28..28] IDMA buffer transfer complete clear bit Set by software
                                                     to clear the IDMABTC flag.                                                */
            uint32_t            : 3;
    } SDMMC_ICR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_MASKR;                 /*!< (@ 0x0000003C) The interrupt mask register determines which
                                                                    status flags generate an interrupt request
                                                                    by setting the corresponding bit to 1.                     */
    
    struct {
      __IOM uint32_t CCRCFAILIE : 1;            /*!< [0..0] Command CRC fail interrupt enable Set and cleared by
                                                     software to enable/disable interrupt caused by command
                                                     CRC failure.                                                              */
      __IOM uint32_t DCRCFAILIE : 1;            /*!< [1..1] Data CRC fail interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data CRC failure.                   */
      __IOM uint32_t CTIMEOUTIE : 1;            /*!< [2..2] Command timeout interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by command timeout.                    */
      __IOM uint32_t DTIMEOUTIE : 1;            /*!< [3..3] Data timeout interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data timeout.                       */
      __IOM uint32_t TXUNDERRIE : 1;            /*!< [4..4] Tx FIFO underrun error interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Tx FIFO
                                                     underrun error.                                                           */
      __IOM uint32_t RXOVERRIE  : 1;            /*!< [5..5] Rx FIFO overrun error interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Rx FIFO
                                                     overrun error.                                                            */
      __IOM uint32_t CMDRENDIE  : 1;            /*!< [6..6] Command response received interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by receiving
                                                     command response.                                                         */
      __IOM uint32_t CMDSENTIE  : 1;            /*!< [7..7] Command sent interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by sending command.                    */
      __IOM uint32_t DATAENDIE  : 1;            /*!< [8..8] Data end interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by data end.                           */
      __IOM uint32_t DHOLDIE    : 1;            /*!< [9..9] Data hold interrupt enable Set and cleared by software
                                                     to enable/disable the interrupt generated when sending
                                                     new data is hold in the DPSM Wait_S state.                                */
      __IOM uint32_t DBCKENDIE  : 1;            /*!< [10..10] Data block end interrupt enable Set and cleared by
                                                     software to enable/disable interrupt caused by data block
                                                     end.                                                                      */
      __IOM uint32_t DABORTIE   : 1;            /*!< [11..11] Data transfer aborted interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by a data
                                                     transfer being aborted.                                                   */
            uint32_t            : 2;
      __IOM uint32_t TXFIFOHEIE : 1;            /*!< [14..14] Tx FIFO half empty interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Tx FIFO
                                                     half empty.                                                               */
      __IOM uint32_t RXFIFOHFIE : 1;            /*!< [15..15] Rx FIFO half full interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by Rx FIFO
                                                     half full.                                                                */
            uint32_t            : 1;
      __IOM uint32_t RXFIFOFIE  : 1;            /*!< [17..17] Rx FIFO full interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by Rx FIFO full.                       */
      __IOM uint32_t TXFIFOEIE  : 1;            /*!< [18..18] Tx FIFO empty interrupt enable Set and cleared by software
                                                     to enable/disable interrupt caused by Tx FIFO empty.                      */
            uint32_t            : 2;
      __IOM uint32_t BUSYD0ENDIE : 1;           /*!< [21..21] BUSYD0END interrupt enable Set and cleared by software
                                                     to enable/disable the interrupt generated when SDMMC_D0
                                                     signal changes from busy to NOT busy following a CMD response.            */
      __IOM uint32_t SDIOITIE   : 1;            /*!< [22..22] SDIO mode interrupt received interrupt enable Set and
                                                     cleared by software to enable/disable the interrupt generated
                                                     when receiving the SDIO mode interrupt.                                   */
      __IOM uint32_t ACKFAILIE  : 1;            /*!< [23..23] Acknowledgment Fail interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by acknowledgment
                                                     Fail.                                                                     */
      __IOM uint32_t ACKTIMEOUTIE : 1;          /*!< [24..24] Acknowledgment timeout interrupt enable Set and cleared
                                                     by software to enable/disable interrupt caused by acknowledgment
                                                     timeout.                                                                  */
      __IOM uint32_t VSWENDIE   : 1;            /*!< [25..25] Voltage switch critical timing section completion interrupt
                                                     enable Set and cleared by software to enable/disable the
                                                     interrupt generated when voltage switch critical timing
                                                     section completion.                                                       */
      __IOM uint32_t CKSTOPIE   : 1;            /*!< [26..26] Voltage Switch clock stopped interrupt enable Set and
                                                     cleared by software to enable/disable interrupt caused
                                                     by Voltage Switch clock stopped.                                          */
            uint32_t            : 1;
      __IOM uint32_t IDMABTCIE  : 1;            /*!< [28..28] IDMA buffer transfer complete interrupt enable Set
                                                     and cleared by software to enable/disable the interrupt
                                                     generated when the IDMA has transferred all data belonging
                                                     to a memory buffer.                                                       */
            uint32_t            : 3;
    } SDMMC_MASKR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_ACKTIMER;              /*!< (@ 0x00000040) The SDMMC_ACKTIMER register contains the acknowledgment
                                                                    timeout period, in SDMMC_CK bus clock periods.
                                                                    A counter loads the value from the SDMMC_ACKTIMER
                                                                    register, and starts decrementing when the
                                                                    data path state machine (DPSM) enters the
                                                                    Wait_Ack state. If the timer reaches 0 while
                                                                    the DPSM is in this states, the acknowledgment
                                                                    timeout status flag is set.                                */
    
    struct {
      __IOM uint32_t ACKTIME    : 25;           /*!< [24..0] Boot acknowledgment timeout period This bit can only
                                                     be written by firmware when CPSM is disabled (CPSMEN =
                                                     0). Boot acknowledgment timeout period expressed in card
                                                     bus clock periods.                                                        */
            uint32_t            : 7;
    } SDMMC_ACKTIMER_b;
  } ;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t SDMMC_IDMACTRLR;             /*!< (@ 0x00000050) The receive and transmit FIFOs can be read or
                                                                    written as 32-bit wide registers. The FIFOs
                                                                    contain 32 entries on 32 sequential addresses.
                                                                    This allows the CPU to use its load and
                                                                    store multiple operands to read from/write
                                                                    to the FIFO.                                               */
    
    struct {
      __IOM uint32_t IDMAEN     : 1;            /*!< [0..0] IDMA enable This bit can only be written by firmware
                                                     when DPSM is inactive (DPSMACT = 0).                                      */
      __IOM uint32_t IDMABMODE  : 1;            /*!< [1..1] Buffer mode selection. This bit can only be written by
                                                     firmware when DPSM is inactive (DPSMACT = 0).                             */
      __IOM uint32_t IDMABACT   : 1;            /*!< [2..2] Double buffer mode active buffer indication This bit
                                                     can only be written by firmware when DPSM is inactive (DPSMACT
                                                     = 0). When IDMA is enabled this bit is toggled by hardware.               */
            uint32_t            : 29;
    } SDMMC_IDMACTRLR_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_IDMABSIZER;            /*!< (@ 0x00000054) The SDMMC_IDMABSIZER register contains the buffers
                                                                    size when in double buffer configuration.                  */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t IDMABNDT   : 8;            /*!< [12..5] Number of transfers per buffer. This 8-bit value shall
                                                     be multiplied by 8 to get the size of the buffer in 32-bit
                                                     words and by 32 to get the size of the buffer in bytes.
                                                     Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes.
                                                     These bits can only be written by firmware when DPSM is
                                                     inactive (DPSMACT = 0).                                                   */
            uint32_t            : 19;
    } SDMMC_IDMABSIZER_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_IDMABASE0R;            /*!< (@ 0x00000058) The SDMMC_IDMABASE0R register contains the memory
                                                                    buffer base address in single buffer configuration
                                                                    and the buffer 0 base address in double
                                                                    buffer configuration.                                      */
    
    struct {
      __IOM uint32_t IDMABASE0  : 32;           /*!< [31..0] Buffer 0 memory base address bits [31:2], shall be word
                                                     aligned (bit [1:0] are always 0 and read only). This register
                                                     can be written by firmware when DPSM is inactive (DPSMACT
                                                     = 0), and can dynamically be written by firmware when DPSM
                                                     active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT
                                                     = 1).                                                                     */
    } SDMMC_IDMABASE0R_b;
  } ;
  
  union {
    __IOM uint32_t SDMMC_IDMABASE1R;            /*!< (@ 0x0000005C) The SDMMC_IDMABASE1R register contains the double
                                                                    buffer configuration second buffer memory
                                                                    base address.                                              */
    
    struct {
      __IOM uint32_t IDMABASE1  : 32;           /*!< [31..0] Buffer 1 memory base address, shall be word aligned
                                                     (bit [1:0] are always 0 and read only). This register can
                                                     be written by firmware when DPSM is inactive (DPSMACT =
                                                     0), and can dynamically be written by firmware when DPSM
                                                     active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT
                                                     = 0).                                                                     */
    } SDMMC_IDMABASE1R_b;
  } ;
  __IM  uint32_t  RESERVED1[8];
  
  union {
    __IOM uint32_t SDMMC_FIFOR;                 /*!< (@ 0x00000080) The receive and transmit FIFOs can be only read
                                                                    or written as word (32-bit) wide registers.
                                                                    The FIFOs contain 16 entries on sequential
                                                                    addresses. This allows the CPU to use its
                                                                    load and store multiple operands to read
                                                                    from/write to the FIFO.When accessing SDMMC_FIFOR
                                                                    with half word or byte access an AHB bus
                                                                    fault is generated.                                        */
    
    struct {
      __IOM uint32_t FIFODATA   : 32;           /*!< [31..0] Receive and transmit FIFO data This register can only
                                                     be read or written by firmware when the DPSM is active
                                                     (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit
                                                     words.                                                                    */
    } SDMMC_FIFOR_b;
  } ;
  __IM  uint32_t  RESERVED2[220];
  
  union {
    __IM  uint32_t SDMMC_VER;                   /*!< (@ 0x000003F4) SDMMC IP version register                                  */
    
    struct {
      __IM  uint32_t MINREV     : 4;            /*!< [3..0] IP minor revision number.                                          */
      __IM  uint32_t MAJREV     : 4;            /*!< [7..4] IP major revision number.                                          */
            uint32_t            : 24;
    } SDMMC_VER_b;
  } ;
  
  union {
    __IM  uint32_t SDMMC_ID;                    /*!< (@ 0x000003F8) SDMMC IP identification register                           */
    
    struct {
      __IM  uint32_t IP_ID      : 32;           /*!< [31..0] SDMMC IP identification.                                          */
    } SDMMC_ID_b;
  } ;
} SDMMC1_Type;                                  /*!< Size = 1020 (0x3fc)                                                       */



/* =========================================================================================================================== */
/* ================                                          VREFBUF                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief VREFBUF (VREFBUF)
  */

typedef struct {                                /*!< (@ 0x58003C00) VREFBUF Structure                                          */
  
  union {
    __IOM uint32_t VREFBUF_CSR;                 /*!< (@ 0x00000000) VREFBUF control and status register                        */
    
    struct {
      __IOM uint32_t ENVR       : 1;            /*!< [0..0] Voltage reference buffer mode enable This bit is used
                                                     to enable the voltage reference buffer mode.                              */
      __IOM uint32_t HIZ        : 1;            /*!< [1..1] High impedance mode This bit controls the analog switch
                                                     to connect or not the VREF+ pin. Refer to Table196: VREF
                                                     buffer modes for the mode descriptions depending on ENVR
                                                     bit configuration.                                                        */
            uint32_t            : 1;
      __IM  uint32_t VRR        : 1;            /*!< [3..3] Voltage reference buffer ready                                     */
      __IOM uint32_t VRS        : 3;            /*!< [6..4] Voltage reference scale These bits select the value generated
                                                     by the voltage reference buffer. Other: Reserved                          */
            uint32_t            : 25;
    } VREFBUF_CSR_b;
  } ;
  
  union {
    __IOM uint32_t VREFBUF_CCR;                 /*!< (@ 0x00000004) VREFBUF calibration control register                       */
    
    struct {
      __IOM uint32_t TRIM       : 6;            /*!< [5..0] Trimming code These bits are automatically initialized
                                                     after reset with the trimming value stored in the Flash
                                                     memory during the production test. Writing into these bits
                                                     allows to tune the internal reference buffer voltage.                     */
            uint32_t            : 26;
    } VREFBUF_CCR_b;
  } ;
} VREFBUF_Type;                                 /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           IWDG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief IWDG (IWDG)
  */

typedef struct {                                /*!< (@ 0x58004800) IWDG Structure                                             */
  
  union {
    __OM  uint32_t IWDG_KR;                     /*!< (@ 0x00000000) Key register                                               */
    
    struct {
      __OM  uint32_t KEY        : 16;           /*!< [15..0] Key value (write only, read 0x0000) These bits must
                                                     be written by software at regular intervals with the key
                                                     value 0xAAAA, otherwise the watchdog generates a reset
                                                     when the counter reaches 0. Writing the key value 0x5555
                                                     to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR
                                                     registers (see Section23.3.6: Register access protection)
                                                     Writing the key value CCCCh starts the watchdog (except
                                                     if                                                                        */
            uint32_t            : 16;
    } IWDG_KR_b;
  } ;
  
  union {
    __IOM uint32_t IWDG_PR;                     /*!< (@ 0x00000004) Prescaler register                                         */
    
    struct {
      __IOM uint32_t PR         : 3;            /*!< [2..0] Prescaler divider These bits are write access protected
                                                     see Section23.3.6: Register access protection. They are
                                                     written by software to select the prescaler divider feeding
                                                     the counter clock. PVU bit of IWDG_SR must be reset in
                                                     order to be able to change the prescaler divider. Note:
                                                     Reading this register returns the prescaler value from
                                                     the VDD voltage domain. This value may not be up to d                     */
            uint32_t            : 29;
    } IWDG_PR_b;
  } ;
  
  union {
    __IOM uint32_t IWDG_RLR;                    /*!< (@ 0x00000008) Reload register                                            */
    
    struct {
      __IOM uint32_t RL         : 12;           /*!< [11..0] Watchdog counter reload value These bits are write access
                                                     protected see Section23.3.6. They are written by software
                                                     to define the value to be loaded in the watchdog counter
                                                     each time the value 0xAAAA is written in the IWDG_KR register.
                                                     The watchdog counter counts down from this value. The timeout
                                                     period is a function of this value and the clock prescaler.
                                                     Refer to the datasheet for the ti                                         */
            uint32_t            : 20;
    } IWDG_RLR_b;
  } ;
  
  union {
    __IM  uint32_t IWDG_SR;                     /*!< (@ 0x0000000C) Status register                                            */
    
    struct {
      __IM  uint32_t PVU        : 1;            /*!< [0..0] Watchdog prescaler value update This bit is set by hardware
                                                     to indicate that an update of the prescaler value is ongoing.
                                                     It is reset by hardware when the prescaler update operation
                                                     is completed in the VDD voltage domain (takes up to 5 RC
                                                     40 kHz cycles). Prescaler value can be updated only when
                                                     PVU bit is reset.                                                         */
      __IM  uint32_t RVU        : 1;            /*!< [1..1] Watchdog counter reload value update This bit is set
                                                     by hardware to indicate that an update of the reload value
                                                     is ongoing. It is reset by hardware when the reload value
                                                     update operation is completed in the VDD voltage domain
                                                     (takes up to 5 RC 40 kHz cycles). Reload value can be updated
                                                     only when RVU bit is reset.                                               */
      __IM  uint32_t WVU        : 1;            /*!< [2..2] Watchdog counter window value update This bit is set
                                                     by hardware to indicate that an update of the window value
                                                     is ongoing. It is reset by hardware when the reload value
                                                     update operation is completed in the VDD voltage domain
                                                     (takes up to 5 RC 40 kHz cycles). Window value can be updated
                                                     only when WVU bit is reset. This bit is generated only
                                                     if generic window = 1                                                     */
            uint32_t            : 29;
    } IWDG_SR_b;
  } ;
  
  union {
    __IOM uint32_t IWDG_WINR;                   /*!< (@ 0x00000010) Window register                                            */
    
    struct {
      __IOM uint32_t WIN        : 12;           /*!< [11..0] Watchdog counter window value These bits are write access
                                                     protected see Section23.3.6. These bits contain the high
                                                     limit of the window value to be compared to the downcounter.
                                                     To prevent a reset, the downcounter must be reloaded when
                                                     its value is lower than the window register value and greater
                                                     than 0x0 The WVU bit in the IWDG_SR register must be reset
                                                     in order to be able to change the reload value. Not                       */
            uint32_t            : 20;
    } IWDG_WINR_b;
  } ;
} IWDG_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           WWDG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief WWDG (WWDG)
  */

typedef struct {                                /*!< (@ 0x50003000) WWDG Structure                                             */
  
  union {
    __IOM uint32_t WWDG_CR;                     /*!< (@ 0x00000000) Control register                                           */
    
    struct {
      __IOM uint32_t T          : 7;            /*!< [6..0] 7-bit counter (MSB to LSB) These bits contain the value
                                                     of the watchdog counter. It is decremented every (4096
                                                     x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it
                                                     is decremented from 0x40 to 0x3F (T6 becomes cleared).                    */
      __IOM uint32_t WDGA       : 1;            /*!< [7..7] Activation bit This bit is set by software and only cleared
                                                     by hardware after a reset. When WDGA=1, the watchdog can
                                                     generate a reset.                                                         */
            uint32_t            : 24;
    } WWDG_CR_b;
  } ;
  
  union {
    __IOM uint32_t WWDG_CFR;                    /*!< (@ 0x00000004) Configuration register                                     */
    
    struct {
      __IOM uint32_t W          : 7;            /*!< [6..0] 7-bit window value These bits contain the window value
                                                     to be compared to the downcounter.                                        */
            uint32_t            : 2;
      __IOM uint32_t EWI        : 1;            /*!< [9..9] Early wakeup interrupt When set, an interrupt occurs
                                                     whenever the counter reaches the value 0x40. This interrupt
                                                     is only cleared by hardware after a reset.                                */
            uint32_t            : 1;
      __IOM uint32_t WDGTB      : 2;            /*!< [12..11] Timer base The time base of the prescaler can be modified
                                                     as follows:                                                               */
            uint32_t            : 19;
    } WWDG_CFR_b;
  } ;
  
  union {
    __IOM uint32_t WWDG_SR;                     /*!< (@ 0x00000008) Status register                                            */
    
    struct {
      __IOM uint32_t EWIF       : 1;            /*!< [0..0] Early wakeup interrupt flag This bit is set by hardware
                                                     when the counter has reached the value 0x40. It must be
                                                     cleared by software by writing 0. A write of 1 has no effect.
                                                     This bit is also set if the interrupt is not enabled.                     */
            uint32_t            : 31;
    } WWDG_SR_b;
  } ;
} WWDG_Type;                                    /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            PWR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PWR (PWR)
  */

typedef struct {                                /*!< (@ 0x58024800) PWR Structure                                              */
  
  union {
    __IOM uint32_t PWR_CR1;                     /*!< (@ 0x00000000) PWR control register 1                                     */
    
    struct {
      __IOM uint32_t LPDS       : 1;            /*!< [0..0] Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always
                                                     use low-power, regardless of the setting of this bit)                     */
            uint32_t            : 3;
      __IOM uint32_t PVDE       : 1;            /*!< [4..4] Programmable voltage detector enable                               */
      __IOM uint32_t PLS        : 3;            /*!< [7..5] Programmable voltage detector level selection These bits
                                                     select the voltage threshold detected by the PVD. Note:
                                                     Refer to Section Electrical characteristics of the product
                                                     datasheet for more details.                                               */
      __IOM uint32_t DBP        : 1;            /*!< [8..8] Disable backup domain write protection In reset state,
                                                     the RCC_BDCR register, the RTC registers (including the
                                                     backup registers), BREN and MOEN bits in PWR_CR2 register,
                                                     are protected against parasitic write access. This bit
                                                     must be set to enable write access to these registers.                    */
      __IOM uint32_t FLPS       : 1;            /*!< [9..9] Flash low-power mode in DStop mode This bit allows to
                                                     obtain the best trade-off between low-power consumption
                                                     and restart time when exiting from DStop mode. When it
                                                     is set, the Flash memory enters low-power mode when D1
                                                     domain is in DStop mode.                                                  */
            uint32_t            : 4;
      __IOM uint32_t SVOS       : 2;            /*!< [15..14] System Stop mode voltage scaling selection These bits
                                                     control the VCORE voltage level in system Stop mode, to
                                                     obtain the best trade-off between power consumption and
                                                     performance.                                                              */
      __IOM uint32_t AVDEN      : 1;            /*!< [16..16] Peripheral voltage monitor on VDDA enable                        */
      __IOM uint32_t ALS        : 2;            /*!< [18..17] Analog voltage detector level selection These bits
                                                     select the voltage threshold detected by the AVD.                         */
            uint32_t            : 13;
    } PWR_CR1_b;
  } ;
  
  union {
    __IM  uint32_t PWR_CSR1;                    /*!< (@ 0x00000004) PWR control status register 1                              */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t PVDO       : 1;            /*!< [4..4] Programmable voltage detect output This bit is set and
                                                     cleared by hardware. It is valid only if the PVD has been
                                                     enabled by the PVDE bit. Note: since the PVD is disabled
                                                     in Standby mode, this bit is equal to 0 after Standby or
                                                     reset until the PVDE bit is set.                                          */
            uint32_t            : 8;
      __IM  uint32_t ACTVOSRDY  : 1;            /*!< [13..13] Voltage levels ready bit for currently used VOS and
                                                     SDLEVEL This bit is set to 1 by hardware when the voltage
                                                     regulator and the SD converter are both disabled and Bypass
                                                     mode is selected in PWR control register 3 (PWR_CR3).                     */
      __IM  uint32_t ACTVOS     : 2;            /*!< [15..14] VOS currently applied for VCORE voltage scaling selection.
                                                     These bits reflect the last VOS value applied to the PMU.                 */
      __IM  uint32_t AVDO       : 1;            /*!< [16..16] Analog voltage detector output on VDDA This bit is
                                                     set and cleared by hardware. It is valid only if AVD on
                                                     VDDA is enabled by the AVDEN bit. Note: Since the AVD is
                                                     disabled in Standby mode, this bit is equal to 0 after
                                                     Standby or reset until the AVDEN bit is set.                              */
            uint32_t            : 15;
    } PWR_CSR1_b;
  } ;
  
  union {
    __IOM uint32_t PWR_CR2;                     /*!< (@ 0x00000008) This register is not reset by wakeup from Standby
                                                                    mode, RESET signal and VDD POR. It is only
                                                                    reset by VSW POR and VSWRST reset. This
                                                                    register shall not be accessed when VSWRST
                                                                    bit in RCC_BDCR register resets the VSW
                                                                    domain.After reset, PWR_CR2 register is
                                                                    write-protected. Prior to modifying its
                                                                    content, the DBP bit in PWR_CR1 register
                                                                    must be set to disable the write protection.               */
    
    struct {
      __IOM uint32_t BREN       : 1;            /*!< [0..0] Backup regulator enable When set, the Backup regulator
                                                     (used to maintain the backup RAM content in Standby and
                                                     VBAT modes) is enabled. If BREN is reset, the backup regulator
                                                     is switched off. The backup RAM can still be used in Run
                                                     and Stop modes. However, its content will be lost in Standby
                                                     and VBAT modes. If BREN is set, the application must wait
                                                     till the Backup Regulator Ready flag (BRRDY) is                           */
            uint32_t            : 3;
      __IOM uint32_t MONEN      : 1;            /*!< [4..4] VBAT and temperature monitoring enable When set, the
                                                     VBAT supply and temperature monitoring is enabled.                        */
            uint32_t            : 11;
      __IM  uint32_t BRRDY      : 1;            /*!< [16..16] Backup regulator ready This bit is set by hardware
                                                     to indicate that the Backup regulator is ready.                           */
            uint32_t            : 3;
      __IM  uint32_t VBATL      : 1;            /*!< [20..20] VBAT level monitoring versus low threshold                       */
      __IM  uint32_t VBATH      : 1;            /*!< [21..21] VBAT level monitoring versus high threshold                      */
      __IM  uint32_t TEMPL      : 1;            /*!< [22..22] Temperature level monitoring versus low threshold                */
      __IM  uint32_t TEMPH      : 1;            /*!< [23..23] Temperature level monitoring versus high threshold               */
            uint32_t            : 8;
    } PWR_CR2_b;
  } ;
  
  union {
    __IOM uint32_t PWR_CR3;                     /*!< (@ 0x0000000C) Reset only by POR only, not reset by wakeup from
                                                                    Standby mode and RESET pad. The lower byte
                                                                    of this register is written once after POR
                                                                    and shall be written before changing VOS
                                                                    level or ck_sys clock frequency. No limitation
                                                                    applies to the upper bytes.Programming data
                                                                    corresponding to an invalid combination
                                                                    of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS
                                                                    bits (see Table9) will be ignored: data
                                                                    will not be written, the wri                               */
    
    struct {
      __IOM uint32_t BYPASS     : 1;            /*!< [0..0] Power management unit bypass                                       */
      __IOM uint32_t LDOEN      : 1;            /*!< [1..1] Low drop-out regulator enable                                      */
      __IOM uint32_t SDEN       : 1;            /*!< [2..2] SD converter Enable                                                */
            uint32_t            : 5;
      __IOM uint32_t VBE        : 1;            /*!< [8..8] VBAT charging enable                                               */
      __IOM uint32_t VBRS       : 1;            /*!< [9..9] VBAT charging resistor selection                                   */
            uint32_t            : 14;
      __OM  uint32_t USB33DEN   : 1;            /*!< [24..24] VDD33USB voltage level detector enable.                          */
      __IOM uint32_t USBREGEN   : 1;            /*!< [25..25] USB regulator enable.                                            */
      __IM  uint32_t USB33RDY   : 1;            /*!< [26..26] USB supply ready.                                                */
            uint32_t            : 5;
    } PWR_CR3_b;
  } ;
  
  union {
    __IOM uint32_t PWR_CPUCR;                   /*!< (@ 0x00000010) This register allows controlling CPU1 power.               */
    
    struct {
      __IOM uint32_t PDDS_D1    : 1;            /*!< [0..0] D1 domain Power Down Deepsleep selection. This bit allows
                                                     CPU1 to define the Deepsleep mode for D1 domain.                          */
      __IOM uint32_t PDDS_D2    : 1;            /*!< [1..1] D2 domain Power Down Deepsleep. This bit allows CPU1
                                                     to define the Deepsleep mode for D2 domain.                               */
      __IOM uint32_t PDDS_D3    : 1;            /*!< [2..2] System D3 domain Power Down Deepsleep. This bit allows
                                                     CPU1 to define the Deepsleep mode for System D3 domain.                   */
            uint32_t            : 2;
      __IM  uint32_t STOPF      : 1;            /*!< [5..5] STOP flag This bit is set by hardware and cleared only
                                                     by any reset or by setting the CPU1 CSSF bit.                             */
      __IM  uint32_t SBF        : 1;            /*!< [6..6] System Standby flag This bit is set by hardware and cleared
                                                     only by a POR (Power-on Reset) or by setting the CPU1 CSSF
                                                     bit                                                                       */
      __IM  uint32_t SBF_D1     : 1;            /*!< [7..7] D1 domain DStandby flag This bit is set by hardware and
                                                     cleared by any system reset or by setting the CPU1 CSSF
                                                     bit. Once set, this bit can be cleared only when the D1
                                                     domain is no longer in DStandby mode.                                     */
      __IM  uint32_t SBF_D2     : 1;            /*!< [8..8] D2 domain DStandby flag This bit is set by hardware and
                                                     cleared by any system reset or by setting the CPU1 CSSF
                                                     bit. Once set, this bit can be cleared only when the D2
                                                     domain is no longer in DStandby mode.                                     */
      __IOM uint32_t CSSF       : 1;            /*!< [9..9] Clear D1 domain CPU1 Standby, Stop and HOLD flags (always
                                                     read as 0) This bit is cleared to 0 by hardware.                          */
            uint32_t            : 1;
      __IOM uint32_t RUN_D3     : 1;            /*!< [11..11] Keep system D3 domain in Run mode regardless of the
                                                     CPU sub-systems modes                                                     */
            uint32_t            : 20;
    } PWR_CPUCR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t PWR_D3CR;                    /*!< (@ 0x00000018) This register allows controlling D3 domain power.Following
                                                                    reset VOSRDY will be read 1 by software                    */
    
    struct {
            uint32_t            : 13;
      __IM  uint32_t VOSRDY     : 1;            /*!< [13..13] VOS Ready bit for VCORE voltage scaling output selection.
                                                     This bit is set to 1 by hardware when Bypass mode is selected
                                                     in PWR control register 3 (PWR_CR3).                                      */
      __IOM uint32_t VOS        : 2;            /*!< [15..14] Voltage scaling selection according to performance
                                                     These bits control the VCORE voltage level and allow to
                                                     obtains the best trade-off between power consumption and
                                                     performance: When increasing the performance, the voltage
                                                     scaling shall be changed before increasing the system frequency.
                                                     When decreasing performance, the system frequency shall
                                                     first be decreased before changing the voltage s                          */
            uint32_t            : 16;
    } PWR_D3CR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t PWR_WKUPCR;                  /*!< (@ 0x00000020) reset only by system reset, not reset by wakeup
                                                                    from Standby mode5 wait states are required
                                                                    when writing this register (when clearing
                                                                    a WKUPF bit in PWR_WKUPFR, the AHB write
                                                                    access will complete after the WKUPF has
                                                                    been cleared).                                             */
    
    struct {
      __IOM uint32_t WKUPC      : 6;            /*!< [5..0] Clear Wakeup pin flag for WKUP. These bits are always
                                                     read as 0.                                                                */
            uint32_t            : 26;
    } PWR_WKUPCR_b;
  } ;
  
  union {
    __IOM uint32_t PWR_WKUPFR;                  /*!< (@ 0x00000024) reset only by system reset, not reset by wakeup
                                                                    from Standby mode                                          */
    
    struct {
      __IOM uint32_t WKUPF1     : 1;            /*!< [0..0] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32_t WKUPF2     : 1;            /*!< [1..1] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32_t WKUPF3     : 1;            /*!< [2..2] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32_t WKUPF4     : 1;            /*!< [3..3] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32_t WKUPF5     : 1;            /*!< [4..4] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
      __IOM uint32_t WKUPF6     : 1;            /*!< [5..5] Wakeup pin WKUPF flag. This bit is set by hardware and
                                                     cleared only by a Reset pin or by setting the WKUPCn+1
                                                     bit in the PWR wakeup clear register (PWR_WKUPCR).                        */
            uint32_t            : 26;
    } PWR_WKUPFR_b;
  } ;
  
  union {
    __IOM uint32_t PWR_WKUPEPR;                 /*!< (@ 0x00000028) Reset only by system reset, not reset by wakeup
                                                                    from Standby mode                                          */
    
    struct {
      __IOM uint32_t WKUPEN1    : 1;            /*!< [0..0] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32_t WKUPEN2    : 1;            /*!< [1..1] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32_t WKUPEN3    : 1;            /*!< [2..2] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32_t WKUPEN4    : 1;            /*!< [3..3] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32_t WKUPEN5    : 1;            /*!< [4..4] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
      __IOM uint32_t WKUPEN6    : 1;            /*!< [5..5] Enable Wakeup Pin WKUPn+1 Each bit is set and cleared
                                                     by software. Note: An additional wakeup event is detected
                                                     if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit)
                                                     when WKUPn+1 pin level is already high when WKUPPn+1 selects
                                                     rising edge, or low when WKUPPn+1 selects falling edge.                   */
            uint32_t            : 2;
      __IOM uint32_t WKUPP1     : 1;            /*!< [8..8] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32_t WKUPP2     : 1;            /*!< [9..9] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32_t WKUPP3     : 1;            /*!< [10..10] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32_t WKUPP4     : 1;            /*!< [11..11] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32_t WKUPP5     : 1;            /*!< [12..12] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
      __IOM uint32_t WKUPP6     : 1;            /*!< [13..13] Wakeup pin polarity bit for WKUPn-7 These bits define
                                                     the polarity used for event detection on WKUPn-7 external
                                                     wakeup pin.                                                               */
            uint32_t            : 2;
      __IOM uint32_t WKUPPUPD1  : 2;            /*!< [17..16] Wakeup pin pull configuration                                    */
      __IOM uint32_t WKUPPUPD2  : 2;            /*!< [19..18] Wakeup pin pull configuration                                    */
      __IOM uint32_t WKUPPUPD3  : 2;            /*!< [21..20] Wakeup pin pull configuration                                    */
      __IOM uint32_t WKUPPUPD4  : 2;            /*!< [23..22] Wakeup pin pull configuration                                    */
      __IOM uint32_t WKUPPUPD5  : 2;            /*!< [25..24] Wakeup pin pull configuration                                    */
      __IOM uint32_t WKUPPUPD6  : 2;            /*!< [27..26] Wakeup pin pull configuration for WKUP(truncate(n/2)-7)
                                                     These bits define the I/O pad pull configuration used when
                                                     WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull
                                                     configuration shall be set to the same value or to 00.
                                                     The Wakeup pin pull configuration is kept in Standby mode.                */
            uint32_t            : 4;
    } PWR_WKUPEPR_b;
  } ;
} PWR_Type;                                     /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial peripheral interface (SPI1)
  */

typedef struct {                                /*!< (@ 0x40013000) SPI1 Structure                                             */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t SPE        : 1;            /*!< [0..0] Serial Peripheral Enable                                           */
            uint32_t            : 7;
      __IOM uint32_t MASRX      : 1;            /*!< [8..8] Master automatic SUSP in Receive mode                              */
      __IM  uint32_t CSTART     : 1;            /*!< [9..9] Master transfer start                                              */
      __OM  uint32_t CSUSP      : 1;            /*!< [10..10] Master SUSPend request                                           */
      __IOM uint32_t HDDIR      : 1;            /*!< [11..11] Rx/Tx direction at Half-duplex mode                              */
      __IOM uint32_t SSI        : 1;            /*!< [12..12] Internal SS signal input level                                   */
      __IOM uint32_t CRC33_17   : 1;            /*!< [13..13] 32-bit CRC polynomial configuration                              */
      __IOM uint32_t RCRCI      : 1;            /*!< [14..14] CRC calculation initialization pattern control for
                                                     receiver                                                                  */
      __IOM uint32_t TCRCI      : 1;            /*!< [15..15] CRC calculation initialization pattern control for
                                                     transmitter                                                               */
      __IM  uint32_t IOLOCK     : 1;            /*!< [16..16] Locking the AF configuration of associated IOs                   */
            uint32_t            : 15;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32_t TSIZE      : 16;           /*!< [15..0] Number of data at current transfer                                */
      __IM  uint32_t TSER       : 16;           /*!< [31..16] Number of data transfer extension to be reload into
                                                     TSIZE just when a previous                                                */
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t CFG1;                        /*!< (@ 0x00000008) configuration register 1                                   */
    
    struct {
      __IOM uint32_t DSIZE      : 5;            /*!< [4..0] Number of bits in at single SPI data frame                         */
      __IOM uint32_t FTHVL      : 4;            /*!< [8..5] threshold level                                                    */
      __IOM uint32_t UDRCFG     : 2;            /*!< [10..9] Behavior of slave transmitter at underrun condition               */
      __IOM uint32_t UDRDET     : 2;            /*!< [12..11] Detection of underrun condition at slave transmitter             */
            uint32_t            : 1;
      __IOM uint32_t RXDMAEN    : 1;            /*!< [14..14] Rx DMA stream enable                                             */
      __IOM uint32_t TXDMAEN    : 1;            /*!< [15..15] Tx DMA stream enable                                             */
      __IOM uint32_t CRCSIZE    : 5;            /*!< [20..16] Length of CRC frame to be transacted and compared                */
            uint32_t            : 1;
      __IOM uint32_t CRCEN      : 1;            /*!< [22..22] Hardware CRC computation enable                                  */
            uint32_t            : 5;
      __IOM uint32_t MBR        : 3;            /*!< [30..28] Master baud rate                                                 */
            uint32_t            : 1;
    } CFG1_b;
  } ;
  
  union {
    __IOM uint32_t CFG2;                        /*!< (@ 0x0000000C) configuration register 2                                   */
    
    struct {
      __IOM uint32_t MSSI       : 4;            /*!< [3..0] Master SS Idleness                                                 */
      __IOM uint32_t MIDI       : 4;            /*!< [7..4] Master Inter-Data Idleness                                         */
            uint32_t            : 7;
      __IOM uint32_t IOSWP      : 1;            /*!< [15..15] Swap functionality of MISO and MOSI pins                         */
            uint32_t            : 1;
      __IOM uint32_t COMM       : 2;            /*!< [18..17] SPI Communication Mode                                           */
      __IOM uint32_t SP         : 3;            /*!< [21..19] Serial Protocol                                                  */
      __IOM uint32_t MASTER     : 1;            /*!< [22..22] SPI Master                                                       */
      __IOM uint32_t LSBFRST    : 1;            /*!< [23..23] Data frame format                                                */
      __IOM uint32_t CPHA       : 1;            /*!< [24..24] Clock phase                                                      */
      __IOM uint32_t CPOL       : 1;            /*!< [25..25] Clock polarity                                                   */
      __IOM uint32_t SSM        : 1;            /*!< [26..26] Software management of SS signal input                           */
            uint32_t            : 1;
      __IOM uint32_t SSIOP      : 1;            /*!< [28..28] SS input/output polarity                                         */
      __IOM uint32_t SSOE       : 1;            /*!< [29..29] SS output enable                                                 */
      __IOM uint32_t SSOM       : 1;            /*!< [30..30] SS output management in master mode                              */
      __IOM uint32_t AFCNTR     : 1;            /*!< [31..31] Alternate function GPIOs control                                 */
    } CFG2_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000010) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t RXPIE      : 1;            /*!< [0..0] RXP Interrupt Enable                                               */
      __IM  uint32_t TXPIE      : 1;            /*!< [1..1] TXP interrupt enable                                               */
      __IM  uint32_t DPXPIE     : 1;            /*!< [2..2] DXP interrupt enabled                                              */
      __IOM uint32_t EOTIE      : 1;            /*!< [3..3] EOT, SUSP and TXC interrupt enable                                 */
      __IOM uint32_t TXTFIE     : 1;            /*!< [4..4] TXTFIE interrupt enable                                            */
      __IOM uint32_t UDRIE      : 1;            /*!< [5..5] UDR interrupt enable                                               */
      __IOM uint32_t OVRIE      : 1;            /*!< [6..6] OVR interrupt enable                                               */
      __IOM uint32_t CRCEIE     : 1;            /*!< [7..7] CRC Interrupt enable                                               */
      __IOM uint32_t TIFREIE    : 1;            /*!< [8..8] TIFRE interrupt enable                                             */
      __IOM uint32_t MODFIE     : 1;            /*!< [9..9] Mode Fault interrupt enable                                        */
      __IOM uint32_t TSERFIE    : 1;            /*!< [10..10] Additional number of transactions reload interrupt
                                                     enable                                                                    */
            uint32_t            : 21;
    } IER_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000014) Status Register                                            */
    
    struct {
      __IM  uint32_t RXP        : 1;            /*!< [0..0] Rx-Packet available                                                */
      __IM  uint32_t TXP        : 1;            /*!< [1..1] Tx-Packet space available                                          */
      __IM  uint32_t DXP        : 1;            /*!< [2..2] Duplex Packet                                                      */
      __IM  uint32_t EOT        : 1;            /*!< [3..3] End Of Transfer                                                    */
      __IM  uint32_t TXTF       : 1;            /*!< [4..4] Transmission Transfer Filled                                       */
      __IM  uint32_t UDR        : 1;            /*!< [5..5] Underrun at slave transmission mode                                */
      __IM  uint32_t OVR        : 1;            /*!< [6..6] Overrun                                                            */
      __IM  uint32_t CRCE       : 1;            /*!< [7..7] CRC Error                                                          */
      __IM  uint32_t TIFRE      : 1;            /*!< [8..8] TI frame format error                                              */
      __IM  uint32_t MODF       : 1;            /*!< [9..9] Mode Fault                                                         */
      __IM  uint32_t TSERF      : 1;            /*!< [10..10] Additional number of SPI data to be transacted was
                                                     reload                                                                    */
      __IM  uint32_t SUSP       : 1;            /*!< [11..11] SUSPend                                                          */
      __IM  uint32_t TXC        : 1;            /*!< [12..12] TxFIFO transmission complete                                     */
      __IM  uint32_t RXPLVL     : 2;            /*!< [14..13] RxFIFO Packing LeVeL                                             */
      __IM  uint32_t RXWNE      : 1;            /*!< [15..15] RxFIFO Word Not Empty                                            */
      __IM  uint32_t CTSIZE     : 16;           /*!< [31..16] Number of data frames remaining in current TSIZE session         */
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t IFCR;                        /*!< (@ 0x00000018) Interrupt/Status Flags Clear Register                      */
    
    struct {
            uint32_t            : 3;
      __OM  uint32_t EOTC       : 1;            /*!< [3..3] End Of Transfer flag clear                                         */
      __OM  uint32_t TXTFC      : 1;            /*!< [4..4] Transmission Transfer Filled flag clear                            */
      __OM  uint32_t UDRC       : 1;            /*!< [5..5] Underrun flag clear                                                */
      __OM  uint32_t OVRC       : 1;            /*!< [6..6] Overrun flag clear                                                 */
      __OM  uint32_t CRCEC      : 1;            /*!< [7..7] CRC Error flag clear                                               */
      __OM  uint32_t TIFREC     : 1;            /*!< [8..8] TI frame format error flag clear                                   */
      __OM  uint32_t MODFC      : 1;            /*!< [9..9] Mode Fault flag clear                                              */
      __OM  uint32_t TSERFC     : 1;            /*!< [10..10] TSERFC flag clear                                                */
      __OM  uint32_t SUSPC      : 1;            /*!< [11..11] SUSPend flag clear                                               */
            uint32_t            : 20;
    } IFCR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __OM  uint32_t TXDR;                        /*!< (@ 0x00000020) Transmit Data Register                                     */
    
    struct {
      __OM  uint32_t TXDR       : 32;           /*!< [31..0] Transmit data register                                            */
    } TXDR_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IM  uint32_t RXDR;                        /*!< (@ 0x00000030) Receive Data Register                                      */
    
    struct {
      __IM  uint32_t RXDR       : 32;           /*!< [31..0] Receive data register                                             */
    } RXDR_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t CRCPOLY;                     /*!< (@ 0x00000040) Polynomial Register                                        */
    
    struct {
      __IOM uint32_t CRCPOLY    : 32;           /*!< [31..0] CRC polynomial register                                           */
    } CRCPOLY_b;
  } ;
  
  union {
    __IOM uint32_t TXCRC;                       /*!< (@ 0x00000044) Transmitter CRC Register                                   */
    
    struct {
      __IOM uint32_t TXCRC      : 32;           /*!< [31..0] CRC register for transmitter                                      */
    } TXCRC_b;
  } ;
  
  union {
    __IOM uint32_t RXCRC;                       /*!< (@ 0x00000048) Receiver CRC Register                                      */
    
    struct {
      __IOM uint32_t RXCRC      : 32;           /*!< [31..0] CRC register for receiver                                         */
    } RXCRC_b;
  } ;
  
  union {
    __IOM uint32_t UDRDR;                       /*!< (@ 0x0000004C) Underrun Data Register                                     */
    
    struct {
      __IOM uint32_t UDRDR      : 32;           /*!< [31..0] Data at slave underrun condition                                  */
    } UDRDR_b;
  } ;
  
  union {
    __IOM uint32_t CGFR;                        /*!< (@ 0x00000050) configuration register                                     */
    
    struct {
      __IOM uint32_t I2SMOD     : 1;            /*!< [0..0] I2S mode selection                                                 */
      __IOM uint32_t I2SCFG     : 3;            /*!< [3..1] I2S configuration mode                                             */
      __IOM uint32_t I2SSTD     : 2;            /*!< [5..4] I2S standard selection                                             */
            uint32_t            : 1;
      __IOM uint32_t PCMSYNC    : 1;            /*!< [7..7] PCM frame synchronization                                          */
      __IOM uint32_t DATLEN     : 2;            /*!< [9..8] Data length to be transferred                                      */
      __IOM uint32_t CHLEN      : 1;            /*!< [10..10] Channel length (number of bits per audio channel)                */
      __IOM uint32_t CKPOL      : 1;            /*!< [11..11] Serial audio clock polarity                                      */
      __IOM uint32_t FIXCH      : 1;            /*!< [12..12] Word select inversion                                            */
      __IOM uint32_t WSINV      : 1;            /*!< [13..13] Fixed channel length in SLAVE                                    */
      __IOM uint32_t DATFMT     : 1;            /*!< [14..14] Data format                                                      */
            uint32_t            : 1;
      __IOM uint32_t I2SDIV     : 8;            /*!< [23..16] I2S linear prescaler                                             */
      __IOM uint32_t ODD        : 1;            /*!< [24..24] Odd factor for the prescaler                                     */
      __IOM uint32_t MCKOE      : 1;            /*!< [25..25] Master clock output enable                                       */
            uint32_t            : 6;
    } CGFR_b;
  } ;
} SPI1_Type;                                    /*!< Size = 84 (0x54)                                                          */



/* =========================================================================================================================== */
/* ================                                           LTDC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief LCD-TFT Controller (LTDC)
  */

typedef struct {                                /*!< (@ 0x50001000) LTDC Structure                                             */
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t SSCR;                        /*!< (@ 0x00000008) Synchronization Size Configuration Register                */
    
    struct {
      __IOM uint32_t VSH        : 11;           /*!< [10..0] Vertical Synchronization Height (in units of horizontal
                                                     scan line)                                                                */
            uint32_t            : 5;
      __IOM uint32_t HSW        : 10;           /*!< [25..16] Horizontal Synchronization Width (in units of pixel
                                                     clock period)                                                             */
            uint32_t            : 6;
    } SSCR_b;
  } ;
  
  union {
    __IOM uint32_t BPCR;                        /*!< (@ 0x0000000C) Back Porch Configuration Register                          */
    
    struct {
      __IOM uint32_t AVBP       : 11;           /*!< [10..0] Accumulated Vertical back porch (in units of horizontal
                                                     scan line)                                                                */
            uint32_t            : 5;
      __IOM uint32_t AHBP       : 12;           /*!< [27..16] Accumulated Horizontal back porch (in units of pixel
                                                     clock period)                                                             */
            uint32_t            : 4;
    } BPCR_b;
  } ;
  
  union {
    __IOM uint32_t AWCR;                        /*!< (@ 0x00000010) Active Width Configuration Register                        */
    
    struct {
      __IOM uint32_t AAH        : 11;           /*!< [10..0] Accumulated Active Height (in units of horizontal scan
                                                     line)                                                                     */
            uint32_t            : 5;
      __IOM uint32_t AAV        : 12;           /*!< [27..16] AAV                                                              */
            uint32_t            : 4;
    } AWCR_b;
  } ;
  
  union {
    __IOM uint32_t TWCR;                        /*!< (@ 0x00000014) Total Width Configuration Register                         */
    
    struct {
      __IOM uint32_t TOTALH     : 11;           /*!< [10..0] Total Height (in units of horizontal scan line)                   */
            uint32_t            : 5;
      __IOM uint32_t TOTALW     : 12;           /*!< [27..16] Total Width (in units of pixel clock period)                     */
            uint32_t            : 4;
    } TWCR_b;
  } ;
  
  union {
    __IOM uint32_t GCR;                         /*!< (@ 0x00000018) Global Control Register                                    */
    
    struct {
      __IOM uint32_t LTDCEN     : 1;            /*!< [0..0] LCD-TFT controller enable bit                                      */
            uint32_t            : 3;
      __IM  uint32_t DBW        : 3;            /*!< [6..4] Dither Blue Width                                                  */
            uint32_t            : 1;
      __IM  uint32_t DGW        : 3;            /*!< [10..8] Dither Green Width                                                */
            uint32_t            : 1;
      __IM  uint32_t DRW        : 3;            /*!< [14..12] Dither Red Width                                                 */
            uint32_t            : 1;
      __IOM uint32_t DEN        : 1;            /*!< [16..16] Dither Enable                                                    */
            uint32_t            : 11;
      __IOM uint32_t PCPOL      : 1;            /*!< [28..28] Pixel Clock Polarity                                             */
      __IOM uint32_t DEPOL      : 1;            /*!< [29..29] Data Enable Polarity                                             */
      __IOM uint32_t VSPOL      : 1;            /*!< [30..30] Vertical Synchronization Polarity                                */
      __IOM uint32_t HSPOL      : 1;            /*!< [31..31] Horizontal Synchronization Polarity                              */
    } GCR_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t SRCR;                        /*!< (@ 0x00000024) Shadow Reload Configuration Register                       */
    
    struct {
      __IOM uint32_t IMR        : 1;            /*!< [0..0] Immediate Reload                                                   */
      __IOM uint32_t VBR        : 1;            /*!< [1..1] Vertical Blanking Reload                                           */
            uint32_t            : 30;
    } SRCR_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t BCCR;                        /*!< (@ 0x0000002C) Background Color Configuration Register                    */
    
    struct {
      __IOM uint32_t BCBLUE     : 8;            /*!< [7..0] Background Color Blue value                                        */
      __IOM uint32_t BCGREEN    : 8;            /*!< [15..8] Background Color Green value                                      */
      __IOM uint32_t BCRED      : 8;            /*!< [23..16] Background Color Red value                                       */
            uint32_t            : 8;
    } BCCR_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000034) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t LIE        : 1;            /*!< [0..0] Line Interrupt Enable                                              */
      __IOM uint32_t FUIE       : 1;            /*!< [1..1] FIFO Underrun Interrupt Enable                                     */
      __IOM uint32_t TERRIE     : 1;            /*!< [2..2] Transfer Error Interrupt Enable                                    */
      __IOM uint32_t RRIE       : 1;            /*!< [3..3] Register Reload interrupt enable                                   */
            uint32_t            : 28;
    } IER_b;
  } ;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x00000038) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t LIF        : 1;            /*!< [0..0] Line Interrupt flag                                                */
      __IM  uint32_t FUIF       : 1;            /*!< [1..1] FIFO Underrun Interrupt flag                                       */
      __IM  uint32_t TERRIF     : 1;            /*!< [2..2] Transfer Error interrupt flag                                      */
      __IM  uint32_t RRIF       : 1;            /*!< [3..3] Register Reload Interrupt Flag                                     */
            uint32_t            : 28;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x0000003C) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32_t CLIF       : 1;            /*!< [0..0] Clears the Line Interrupt Flag                                     */
      __OM  uint32_t CFUIF      : 1;            /*!< [1..1] Clears the FIFO Underrun Interrupt flag                            */
      __OM  uint32_t CTERRIF    : 1;            /*!< [2..2] Clears the Transfer Error Interrupt Flag                           */
      __OM  uint32_t CRRIF      : 1;            /*!< [3..3] Clears Register Reload Interrupt Flag                              */
            uint32_t            : 28;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t LIPCR;                       /*!< (@ 0x00000040) Line Interrupt Position Configuration Register             */
    
    struct {
      __IOM uint32_t LIPOS      : 11;           /*!< [10..0] Line Interrupt Position                                           */
            uint32_t            : 21;
    } LIPCR_b;
  } ;
  
  union {
    __IM  uint32_t CPSR;                        /*!< (@ 0x00000044) Current Position Status Register                           */
    
    struct {
      __IM  uint32_t CYPOS      : 16;           /*!< [15..0] Current Y Position                                                */
      __IM  uint32_t CXPOS      : 16;           /*!< [31..16] Current X Position                                               */
    } CPSR_b;
  } ;
  
  union {
    __IM  uint32_t CDSR;                        /*!< (@ 0x00000048) Current Display Status Register                            */
    
    struct {
      __IM  uint32_t VDES       : 1;            /*!< [0..0] Vertical Data Enable display Status                                */
      __IM  uint32_t HDES       : 1;            /*!< [1..1] Horizontal Data Enable display Status                              */
      __IM  uint32_t VSYNCS     : 1;            /*!< [2..2] Vertical Synchronization display Status                            */
      __IM  uint32_t HSYNCS     : 1;            /*!< [3..3] Horizontal Synchronization display Status                          */
            uint32_t            : 28;
    } CDSR_b;
  } ;
  __IM  uint32_t  RESERVED4[14];
  
  union {
    __IOM uint32_t L1CR;                        /*!< (@ 0x00000084) Layerx Control Register                                    */
    
    struct {
      __IOM uint32_t LEN        : 1;            /*!< [0..0] Layer Enable                                                       */
      __IOM uint32_t COLKEN     : 1;            /*!< [1..1] Color Keying Enable                                                */
            uint32_t            : 2;
      __IOM uint32_t CLUTEN     : 1;            /*!< [4..4] Color Look-Up Table Enable                                         */
            uint32_t            : 27;
    } L1CR_b;
  } ;
  
  union {
    __IOM uint32_t L1WHPCR;                     /*!< (@ 0x00000088) Layerx Window Horizontal Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t WHSTPOS    : 12;           /*!< [11..0] Window Horizontal Start Position                                  */
            uint32_t            : 4;
      __IOM uint32_t WHSPPOS    : 12;           /*!< [27..16] Window Horizontal Stop Position                                  */
            uint32_t            : 4;
    } L1WHPCR_b;
  } ;
  
  union {
    __IOM uint32_t L1WVPCR;                     /*!< (@ 0x0000008C) Layerx Window Vertical Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t WVSTPOS    : 11;           /*!< [10..0] Window Vertical Start Position                                    */
            uint32_t            : 5;
      __IOM uint32_t WVSPPOS    : 11;           /*!< [26..16] Window Vertical Stop Position                                    */
            uint32_t            : 5;
    } L1WVPCR_b;
  } ;
  
  union {
    __IOM uint32_t L1CKCR;                      /*!< (@ 0x00000090) Layerx Color Keying Configuration Register                 */
    
    struct {
      __IOM uint32_t CKBLUE     : 8;            /*!< [7..0] Color Key Blue value                                               */
      __IOM uint32_t CKGREEN    : 8;            /*!< [15..8] Color Key Green value                                             */
      __IOM uint32_t CKRED      : 8;            /*!< [23..16] Color Key Red value                                              */
            uint32_t            : 8;
    } L1CKCR_b;
  } ;
  
  union {
    __IOM uint32_t L1PFCR;                      /*!< (@ 0x00000094) Layerx Pixel Format Configuration Register                 */
    
    struct {
      __IOM uint32_t PF         : 3;            /*!< [2..0] Pixel Format                                                       */
            uint32_t            : 29;
    } L1PFCR_b;
  } ;
  
  union {
    __IOM uint32_t L1CACR;                      /*!< (@ 0x00000098) Layerx Constant Alpha Configuration Register               */
    
    struct {
      __IOM uint32_t CONSTA     : 8;            /*!< [7..0] Constant Alpha                                                     */
            uint32_t            : 24;
    } L1CACR_b;
  } ;
  
  union {
    __IOM uint32_t L1DCCR;                      /*!< (@ 0x0000009C) Layerx Default Color Configuration Register                */
    
    struct {
      __IOM uint32_t DCBLUE     : 8;            /*!< [7..0] Default Color Blue                                                 */
      __IOM uint32_t DCGREEN    : 8;            /*!< [15..8] Default Color Green                                               */
      __IOM uint32_t DCRED      : 8;            /*!< [23..16] Default Color Red                                                */
      __IOM uint32_t DCALPHA    : 8;            /*!< [31..24] Default Color Alpha                                              */
    } L1DCCR_b;
  } ;
  
  union {
    __IOM uint32_t L1BFCR;                      /*!< (@ 0x000000A0) Layerx Blending Factors Configuration Register             */
    
    struct {
      __IOM uint32_t BF2        : 3;            /*!< [2..0] Blending Factor 2                                                  */
            uint32_t            : 5;
      __IOM uint32_t BF1        : 3;            /*!< [10..8] Blending Factor 1                                                 */
            uint32_t            : 21;
    } L1BFCR_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t L1CFBAR;                     /*!< (@ 0x000000AC) Layerx Color Frame Buffer Address Register                 */
    
    struct {
      __IOM uint32_t CFBADD     : 32;           /*!< [31..0] Color Frame Buffer Start Address                                  */
    } L1CFBAR_b;
  } ;
  
  union {
    __IOM uint32_t L1CFBLR;                     /*!< (@ 0x000000B0) Layerx Color Frame Buffer Length Register                  */
    
    struct {
      __IOM uint32_t CFBLL      : 13;           /*!< [12..0] Color Frame Buffer Line Length                                    */
            uint32_t            : 3;
      __IOM uint32_t CFBP       : 13;           /*!< [28..16] Color Frame Buffer Pitch in bytes                                */
            uint32_t            : 3;
    } L1CFBLR_b;
  } ;
  
  union {
    __IOM uint32_t L1CFBLNR;                    /*!< (@ 0x000000B4) Layerx ColorFrame Buffer Line Number Register              */
    
    struct {
      __IOM uint32_t CFBLNBR    : 11;           /*!< [10..0] Frame Buffer Line Number                                          */
            uint32_t            : 21;
    } L1CFBLNR_b;
  } ;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __OM  uint32_t L1CLUTWR;                    /*!< (@ 0x000000C4) Layerx CLUT Write Register                                 */
    
    struct {
      __OM  uint32_t BLUE       : 8;            /*!< [7..0] Blue value                                                         */
      __OM  uint32_t GREEN      : 8;            /*!< [15..8] Green value                                                       */
      __OM  uint32_t RED        : 8;            /*!< [23..16] Red value                                                        */
      __OM  uint32_t CLUTADD    : 8;            /*!< [31..24] CLUT Address                                                     */
    } L1CLUTWR_b;
  } ;
  __IM  uint32_t  RESERVED7[15];
  
  union {
    __IOM uint32_t L2CR;                        /*!< (@ 0x00000104) Layerx Control Register                                    */
    
    struct {
      __IOM uint32_t LEN        : 1;            /*!< [0..0] Layer Enable                                                       */
      __IOM uint32_t COLKEN     : 1;            /*!< [1..1] Color Keying Enable                                                */
            uint32_t            : 2;
      __IOM uint32_t CLUTEN     : 1;            /*!< [4..4] Color Look-Up Table Enable                                         */
            uint32_t            : 27;
    } L2CR_b;
  } ;
  
  union {
    __IOM uint32_t L2WHPCR;                     /*!< (@ 0x00000108) Layerx Window Horizontal Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t WHSTPOS    : 12;           /*!< [11..0] Window Horizontal Start Position                                  */
            uint32_t            : 4;
      __IOM uint32_t WHSPPOS    : 12;           /*!< [27..16] Window Horizontal Stop Position                                  */
            uint32_t            : 4;
    } L2WHPCR_b;
  } ;
  
  union {
    __IOM uint32_t L2WVPCR;                     /*!< (@ 0x0000010C) Layerx Window Vertical Position Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t WVSTPOS    : 11;           /*!< [10..0] Window Vertical Start Position                                    */
            uint32_t            : 5;
      __IOM uint32_t WVSPPOS    : 11;           /*!< [26..16] Window Vertical Stop Position                                    */
            uint32_t            : 5;
    } L2WVPCR_b;
  } ;
  
  union {
    __IOM uint32_t L2CKCR;                      /*!< (@ 0x00000110) Layerx Color Keying Configuration Register                 */
    
    struct {
      __IOM uint32_t CKBLUE     : 8;            /*!< [7..0] Color Key Blue value                                               */
      __IOM uint32_t CKGREEN    : 8;            /*!< [15..8] Color Key Green value                                             */
      __IOM uint32_t CKRED      : 8;            /*!< [23..16] Color Key Red value                                              */
            uint32_t            : 8;
    } L2CKCR_b;
  } ;
  
  union {
    __IOM uint32_t L2PFCR;                      /*!< (@ 0x00000114) Layerx Pixel Format Configuration Register                 */
    
    struct {
      __IOM uint32_t PF         : 3;            /*!< [2..0] Pixel Format                                                       */
            uint32_t            : 29;
    } L2PFCR_b;
  } ;
  
  union {
    __IOM uint32_t L2CACR;                      /*!< (@ 0x00000118) Layerx Constant Alpha Configuration Register               */
    
    struct {
      __IOM uint32_t CONSTA     : 8;            /*!< [7..0] Constant Alpha                                                     */
            uint32_t            : 24;
    } L2CACR_b;
  } ;
  
  union {
    __IOM uint32_t L2DCCR;                      /*!< (@ 0x0000011C) Layerx Default Color Configuration Register                */
    
    struct {
      __IOM uint32_t DCBLUE     : 8;            /*!< [7..0] Default Color Blue                                                 */
      __IOM uint32_t DCGREEN    : 8;            /*!< [15..8] Default Color Green                                               */
      __IOM uint32_t DCRED      : 8;            /*!< [23..16] Default Color Red                                                */
      __IOM uint32_t DCALPHA    : 8;            /*!< [31..24] Default Color Alpha                                              */
    } L2DCCR_b;
  } ;
  
  union {
    __IOM uint32_t L2BFCR;                      /*!< (@ 0x00000120) Layerx Blending Factors Configuration Register             */
    
    struct {
      __IOM uint32_t BF2        : 3;            /*!< [2..0] Blending Factor 2                                                  */
            uint32_t            : 5;
      __IOM uint32_t BF1        : 3;            /*!< [10..8] Blending Factor 1                                                 */
            uint32_t            : 21;
    } L2BFCR_b;
  } ;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IOM uint32_t L2CFBAR;                     /*!< (@ 0x0000012C) Layerx Color Frame Buffer Address Register                 */
    
    struct {
      __IOM uint32_t CFBADD     : 32;           /*!< [31..0] Color Frame Buffer Start Address                                  */
    } L2CFBAR_b;
  } ;
  
  union {
    __IOM uint32_t L2CFBLR;                     /*!< (@ 0x00000130) Layerx Color Frame Buffer Length Register                  */
    
    struct {
      __IOM uint32_t CFBLL      : 13;           /*!< [12..0] Color Frame Buffer Line Length                                    */
            uint32_t            : 3;
      __IOM uint32_t CFBP       : 13;           /*!< [28..16] Color Frame Buffer Pitch in bytes                                */
            uint32_t            : 3;
    } L2CFBLR_b;
  } ;
  
  union {
    __IOM uint32_t L2CFBLNR;                    /*!< (@ 0x00000134) Layerx ColorFrame Buffer Line Number Register              */
    
    struct {
      __IOM uint32_t CFBLNBR    : 11;           /*!< [10..0] Frame Buffer Line Number                                          */
            uint32_t            : 21;
    } L2CFBLNR_b;
  } ;
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __OM  uint32_t L2CLUTWR;                    /*!< (@ 0x00000144) Layerx CLUT Write Register                                 */
    
    struct {
      __OM  uint32_t BLUE       : 8;            /*!< [7..0] Blue value                                                         */
      __OM  uint32_t GREEN      : 8;            /*!< [15..8] Green value                                                       */
      __OM  uint32_t RED        : 8;            /*!< [23..16] Red value                                                        */
      __OM  uint32_t CLUTADD    : 8;            /*!< [31..24] CLUT Address                                                     */
    } L2CLUTWR_b;
  } ;
} LTDC_Type;                                    /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                          SPDIFRX                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Receiver Interface (SPDIFRX)
  */

typedef struct {                                /*!< (@ 0x40004000) SPDIFRX Structure                                          */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) Control register                                           */
    
    struct {
      __IOM uint32_t SPDIFRXEN  : 2;            /*!< [1..0] Peripheral Block Enable                                            */
      __IOM uint32_t RXDMAEN    : 1;            /*!< [2..2] Receiver DMA ENable for data flow                                  */
      __IOM uint32_t RXSTEO     : 1;            /*!< [3..3] STerEO Mode                                                        */
      __IOM uint32_t DRFMT      : 2;            /*!< [5..4] RX Data format                                                     */
      __IOM uint32_t PMSK       : 1;            /*!< [6..6] Mask Parity error bit                                              */
      __IOM uint32_t VMSK       : 1;            /*!< [7..7] Mask of Validity bit                                               */
      __IOM uint32_t CUMSK      : 1;            /*!< [8..8] Mask of channel status and user bits                               */
      __IOM uint32_t PTMSK      : 1;            /*!< [9..9] Mask of Preamble Type bits                                         */
      __IOM uint32_t CBDMAEN    : 1;            /*!< [10..10] Control Buffer DMA ENable for control flow                       */
      __IOM uint32_t CHSEL      : 1;            /*!< [11..11] Channel Selection                                                */
      __IOM uint32_t NBTR       : 2;            /*!< [13..12] Maximum allowed re-tries during synchronization phase            */
      __IOM uint32_t WFA        : 1;            /*!< [14..14] Wait For Activity                                                */
            uint32_t            : 1;
      __IOM uint32_t INSEL      : 3;            /*!< [18..16] input selection                                                  */
            uint32_t            : 1;
      __IOM uint32_t CKSEN      : 1;            /*!< [20..20] Symbol Clock Enable                                              */
      __IOM uint32_t CKSBKPEN   : 1;            /*!< [21..21] Backup Symbol Clock Enable                                       */
            uint32_t            : 10;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t IMR;                         /*!< (@ 0x00000004) Interrupt mask register                                    */
    
    struct {
      __IOM uint32_t RXNEIE     : 1;            /*!< [0..0] RXNE interrupt enable                                              */
      __IOM uint32_t CSRNEIE    : 1;            /*!< [1..1] Control Buffer Ready Interrupt Enable                              */
      __IOM uint32_t PERRIE     : 1;            /*!< [2..2] Parity error interrupt enable                                      */
      __IOM uint32_t OVRIE      : 1;            /*!< [3..3] Overrun error Interrupt Enable                                     */
      __IOM uint32_t SBLKIE     : 1;            /*!< [4..4] Synchronization Block Detected Interrupt Enable                    */
      __IOM uint32_t SYNCDIE    : 1;            /*!< [5..5] Synchronization Done                                               */
      __IOM uint32_t IFEIE      : 1;            /*!< [6..6] Serial Interface Error Interrupt Enable                            */
            uint32_t            : 25;
    } IMR_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000008) Status register                                            */
    
    struct {
      __IM  uint32_t RXNE       : 1;            /*!< [0..0] Read data register not empty                                       */
      __IM  uint32_t CSRNE      : 1;            /*!< [1..1] Control Buffer register is not empty                               */
      __IM  uint32_t PERR       : 1;            /*!< [2..2] Parity error                                                       */
      __IM  uint32_t OVR        : 1;            /*!< [3..3] Overrun error                                                      */
      __IM  uint32_t SBD        : 1;            /*!< [4..4] Synchronization Block Detected                                     */
      __IM  uint32_t SYNCD      : 1;            /*!< [5..5] Synchronization Done                                               */
      __IM  uint32_t FERR       : 1;            /*!< [6..6] Framing error                                                      */
      __IM  uint32_t SERR       : 1;            /*!< [7..7] Synchronization error                                              */
      __IM  uint32_t TERR       : 1;            /*!< [8..8] Time-out error                                                     */
            uint32_t            : 7;
      __IM  uint32_t WIDTH5     : 15;           /*!< [30..16] Duration of 5 symbols counted with SPDIF_CLK                     */
            uint32_t            : 1;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t IFCR;                        /*!< (@ 0x0000000C) Interrupt Flag Clear register                              */
    
    struct {
            uint32_t            : 2;
      __OM  uint32_t PERRCF     : 1;            /*!< [2..2] Clears the Parity error flag                                       */
      __OM  uint32_t OVRCF      : 1;            /*!< [3..3] Clears the Overrun error flag                                      */
      __OM  uint32_t SBDCF      : 1;            /*!< [4..4] Clears the Synchronization Block Detected flag                     */
      __OM  uint32_t SYNCDCF    : 1;            /*!< [5..5] Clears the Synchronization Done flag                               */
            uint32_t            : 26;
    } IFCR_b;
  } ;
  
  union {
    union {
      __IM  uint32_t DR_00;                     /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32_t DR       : 24;           /*!< [23..0] Parity Error bit                                                  */
        __IM  uint32_t PE       : 1;            /*!< [24..24] Parity Error bit                                                 */
        __IM  uint32_t V        : 1;            /*!< [25..25] Validity bit                                                     */
        __IM  uint32_t U        : 1;            /*!< [26..26] User bit                                                         */
        __IM  uint32_t C        : 1;            /*!< [27..27] Channel Status bit                                               */
        __IM  uint32_t PT       : 2;            /*!< [29..28] Preamble Type                                                    */
              uint32_t          : 2;
      } DR_00_b;
    } ;
    
    union {
      __IM  uint32_t DR_01;                     /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32_t PE       : 1;            /*!< [0..0] Parity Error bit                                                   */
        __IM  uint32_t V        : 1;            /*!< [1..1] Validity bit                                                       */
        __IM  uint32_t U        : 1;            /*!< [2..2] User bit                                                           */
        __IM  uint32_t C        : 1;            /*!< [3..3] Channel Status bit                                                 */
        __IM  uint32_t PT       : 2;            /*!< [5..4] Preamble Type                                                      */
              uint32_t          : 2;
        __IM  uint32_t DR       : 24;           /*!< [31..8] Data value                                                        */
      } DR_01_b;
    } ;
    
    union {
      __IM  uint32_t DR_10;                     /*!< (@ 0x00000010) Data input register                                        */
      
      struct {
        __IM  uint32_t DRNL1    : 16;           /*!< [15..0] Data value                                                        */
        __IM  uint32_t DRNL2    : 16;           /*!< [31..16] Data value                                                       */
      } DR_10_b;
    } ;
  };
  
  union {
    __IM  uint32_t CSR;                         /*!< (@ 0x00000014) Channel Status register                                    */
    
    struct {
      __IM  uint32_t USR        : 16;           /*!< [15..0] User data information                                             */
      __IM  uint32_t CS         : 8;            /*!< [23..16] Channel A status information                                     */
      __IM  uint32_t SOB        : 1;            /*!< [24..24] Start Of Block                                                   */
            uint32_t            : 7;
    } CSR_b;
  } ;
  
  union {
    __IM  uint32_t DIR;                         /*!< (@ 0x00000018) Debug Information register                                 */
    
    struct {
      __IM  uint32_t THI        : 13;           /*!< [12..0] Threshold HIGH                                                    */
            uint32_t            : 3;
      __IM  uint32_t TLO        : 13;           /*!< [28..16] Threshold LOW                                                    */
            uint32_t            : 3;
    } DIR_b;
  } ;
  __IM  uint32_t  RESERVED[246];
  
  union {
    __IM  uint32_t VERR;                        /*!< (@ 0x000003F4) SPDIFRX version register                                   */
    
    struct {
      __IM  uint32_t MINREV     : 4;            /*!< [3..0] Minor revision                                                     */
      __IM  uint32_t MAJREV     : 4;            /*!< [7..4] Major revision                                                     */
            uint32_t            : 24;
    } VERR_b;
  } ;
  
  union {
    __IM  uint32_t IDR;                         /*!< (@ 0x000003F8) SPDIFRX identification register                            */
    
    struct {
      __IM  uint32_t ID         : 32;           /*!< [31..0] SPDIFRX identifier                                                */
    } IDR_b;
  } ;
  
  union {
    __IM  uint32_t SIDR;                        /*!< (@ 0x000003FC) SPDIFRX size identification register                       */
    
    struct {
      __IM  uint32_t SID        : 32;           /*!< [31..0] Size identification                                               */
    } SIDR_b;
  } ;
} SPDIFRX_Type;                                 /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                           ADC3                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter (ADC3)
  */

typedef struct {                                /*!< (@ 0x58026000) ADC3 Structure                                             */
  
  union {
    __IOM uint32_t ISR;                         /*!< (@ 0x00000000) ADC interrupt and status register                          */
    
    struct {
      __IOM uint32_t ADRDY      : 1;            /*!< [0..0] ADC ready flag                                                     */
      __IOM uint32_t EOSMP      : 1;            /*!< [1..1] ADC group regular end of sampling flag                             */
      __IOM uint32_t EOC        : 1;            /*!< [2..2] ADC group regular end of unitary conversion flag                   */
      __IOM uint32_t EOS        : 1;            /*!< [3..3] ADC group regular end of sequence conversions flag                 */
      __IOM uint32_t OVR        : 1;            /*!< [4..4] ADC group regular overrun flag                                     */
      __IOM uint32_t JEOC       : 1;            /*!< [5..5] ADC group injected end of unitary conversion flag                  */
      __IOM uint32_t JEOS       : 1;            /*!< [6..6] ADC group injected end of sequence conversions flag                */
      __IOM uint32_t AWD1       : 1;            /*!< [7..7] ADC analog watchdog 1 flag                                         */
      __IOM uint32_t AWD2       : 1;            /*!< [8..8] ADC analog watchdog 2 flag                                         */
      __IOM uint32_t AWD3       : 1;            /*!< [9..9] ADC analog watchdog 3 flag                                         */
      __IOM uint32_t JQOVF      : 1;            /*!< [10..10] ADC group injected contexts queue overflow flag                  */
            uint32_t            : 21;
    } ISR_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000004) ADC interrupt enable register                              */
    
    struct {
      __IOM uint32_t ADRDYIE    : 1;            /*!< [0..0] ADC ready interrupt                                                */
      __IOM uint32_t EOSMPIE    : 1;            /*!< [1..1] ADC group regular end of sampling interrupt                        */
      __IOM uint32_t EOCIE      : 1;            /*!< [2..2] ADC group regular end of unitary conversion interrupt              */
      __IOM uint32_t EOSIE      : 1;            /*!< [3..3] ADC group regular end of sequence conversions interrupt            */
      __IOM uint32_t OVRIE      : 1;            /*!< [4..4] ADC group regular overrun interrupt                                */
      __IOM uint32_t JEOCIE     : 1;            /*!< [5..5] ADC group injected end of unitary conversion interrupt             */
      __IOM uint32_t JEOSIE     : 1;            /*!< [6..6] ADC group injected end of sequence conversions interrupt           */
      __IOM uint32_t AWD1IE     : 1;            /*!< [7..7] ADC analog watchdog 1 interrupt                                    */
      __IOM uint32_t AWD2IE     : 1;            /*!< [8..8] ADC analog watchdog 2 interrupt                                    */
      __IOM uint32_t AWD3IE     : 1;            /*!< [9..9] ADC analog watchdog 3 interrupt                                    */
      __IOM uint32_t JQOVFIE    : 1;            /*!< [10..10] ADC group injected contexts queue overflow interrupt             */
            uint32_t            : 21;
    } IER_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CR;                        /*!< (@ 0x00000008) ADC control register                                       */
      
      struct {
        __IOM uint32_t ADEN     : 1;            /*!< [0..0] ADC enable                                                         */
        __IOM uint32_t ADDIS    : 1;            /*!< [1..1] ADC disable                                                        */
        __IOM uint32_t ADSTART  : 1;            /*!< [2..2] ADC group regular conversion start                                 */
        __IOM uint32_t JADSTART : 1;            /*!< [3..3] ADC group injected conversion start                                */
        __IOM uint32_t ADSTP    : 1;            /*!< [4..4] ADC group regular conversion stop                                  */
        __IOM uint32_t JADSTP   : 1;            /*!< [5..5] ADC group injected conversion stop                                 */
              uint32_t          : 2;
        __IOM uint32_t BOOST    : 1;            /*!< [8..8] Boost mode control                                                 */
              uint32_t          : 7;
        __IOM uint32_t ADCALLIN : 1;            /*!< [16..16] Linearity calibration                                            */
              uint32_t          : 5;
        __IOM uint32_t LINCALRDYW1 : 1;         /*!< [22..22] Linearity calibration ready Word 1                               */
        __IOM uint32_t LINCALRDYW2 : 1;         /*!< [23..23] Linearity calibration ready Word 2                               */
        __IOM uint32_t LINCALRDYW3 : 1;         /*!< [24..24] Linearity calibration ready Word 3                               */
        __IOM uint32_t LINCALRDYW4 : 1;         /*!< [25..25] Linearity calibration ready Word 4                               */
        __IOM uint32_t LINCALRDYW5 : 1;         /*!< [26..26] Linearity calibration ready Word 5                               */
        __IOM uint32_t LINCALRDYW6 : 1;         /*!< [27..27] Linearity calibration ready Word 6                               */
        __IOM uint32_t ADVREGEN : 1;            /*!< [28..28] ADC voltage regulator enable                                     */
        __IOM uint32_t DEEPPWD  : 1;            /*!< [29..29] ADC deep power down enable                                       */
        __IOM uint32_t ADCALDIF : 1;            /*!< [30..30] ADC differential mode for calibration                            */
        __IOM uint32_t ADCAL    : 1;            /*!< [31..31] ADC calibration                                                  */
      } CR_b;
    } ;
    
    union {
      __IOM uint32_t CCR;                       /*!< (@ 0x00000008) ADC common control register                                */
      
      struct {
              uint32_t          : 16;
        __IOM uint32_t CKMODE   : 2;            /*!< [17..16] ADC clock mode                                                   */
        __IOM uint32_t PRESC    : 4;            /*!< [21..18] ADC prescaler                                                    */
        __IOM uint32_t VREFEN   : 1;            /*!< [22..22] VREFINT enable                                                   */
        __IOM uint32_t VSENSEEN : 1;            /*!< [23..23] Temperature sensor enable                                        */
        __IOM uint32_t VBATEN   : 1;            /*!< [24..24] VBAT enable                                                      */
              uint32_t          : 7;
      } CCR_b;
    } ;
  };
  
  union {
    __IOM uint32_t CFGR;                        /*!< (@ 0x0000000C) ADC configuration register 1                               */
    
    struct {
      __IOM uint32_t DMNGT      : 2;            /*!< [1..0] ADC DMA transfer enable                                            */
      __IOM uint32_t RES        : 2;            /*!< [3..2] ADC data resolution                                                */
            uint32_t            : 1;
      __IOM uint32_t EXTSEL     : 5;            /*!< [9..5] ADC group regular external trigger source                          */
      __IOM uint32_t EXTEN      : 2;            /*!< [11..10] ADC group regular external trigger polarity                      */
      __IOM uint32_t OVRMOD     : 1;            /*!< [12..12] ADC group regular overrun configuration                          */
      __IOM uint32_t CONT       : 1;            /*!< [13..13] ADC group regular continuous conversion mode                     */
      __IOM uint32_t AUTDLY     : 1;            /*!< [14..14] ADC low power auto wait                                          */
            uint32_t            : 1;
      __IOM uint32_t DISCEN     : 1;            /*!< [16..16] ADC group regular sequencer discontinuous mode                   */
      __IOM uint32_t DISCNUM    : 3;            /*!< [19..17] ADC group regular sequencer discontinuous number of
                                                     ranks                                                                     */
      __IOM uint32_t JDISCEN    : 1;            /*!< [20..20] ADC group injected sequencer discontinuous mode                  */
      __IOM uint32_t JQM        : 1;            /*!< [21..21] ADC group injected contexts queue mode                           */
      __IOM uint32_t AWD1SGL    : 1;            /*!< [22..22] ADC analog watchdog 1 monitoring a single channel or
                                                     all channels                                                              */
      __IOM uint32_t AWD1EN     : 1;            /*!< [23..23] ADC analog watchdog 1 enable on scope ADC group regular          */
      __IOM uint32_t JAWD1EN    : 1;            /*!< [24..24] ADC analog watchdog 1 enable on scope ADC group injected         */
      __IOM uint32_t JAUTO      : 1;            /*!< [25..25] ADC group injected automatic trigger mode                        */
      __IOM uint32_t AWDCH1CH   : 5;            /*!< [30..26] ADC analog watchdog 1 monitored channel selection                */
      __IOM uint32_t JQDIS      : 1;            /*!< [31..31] ADC group injected contexts queue disable                        */
    } CFGR_b;
  } ;
  
  union {
    __IOM uint32_t CFGR2;                       /*!< (@ 0x00000010) ADC configuration register 2                               */
    
    struct {
      __IOM uint32_t ROVSE      : 1;            /*!< [0..0] ADC oversampler enable on scope ADC group regular                  */
      __IOM uint32_t JOVSE      : 1;            /*!< [1..1] ADC oversampler enable on scope ADC group injected                 */
            uint32_t            : 3;
      __IOM uint32_t OVSS       : 4;            /*!< [8..5] ADC oversampling shift                                             */
      __IOM uint32_t TROVS      : 1;            /*!< [9..9] ADC oversampling discontinuous mode (triggered mode)
                                                     for ADC group regular                                                     */
      __IOM uint32_t ROVSM      : 1;            /*!< [10..10] Regular Oversampling mode                                        */
      __IOM uint32_t RSHIFT1    : 1;            /*!< [11..11] Right-shift data after Offset 1 correction                       */
      __IOM uint32_t RSHIFT2    : 1;            /*!< [12..12] Right-shift data after Offset 2 correction                       */
      __IOM uint32_t RSHIFT3    : 1;            /*!< [13..13] Right-shift data after Offset 3 correction                       */
      __IOM uint32_t RSHIFT4    : 1;            /*!< [14..14] Right-shift data after Offset 4 correction                       */
            uint32_t            : 1;
      __IOM uint32_t OSR        : 10;           /*!< [25..16] Oversampling ratio                                               */
            uint32_t            : 2;
      __IOM uint32_t LSHIFT     : 4;            /*!< [31..28] Left shift factor                                                */
    } CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t SMPR1;                       /*!< (@ 0x00000014) ADC sampling time register 1                               */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t SMP1       : 3;            /*!< [5..3] ADC channel 1 sampling time selection                              */
      __IOM uint32_t SMP2       : 3;            /*!< [8..6] ADC channel 2 sampling time selection                              */
      __IOM uint32_t SMP3       : 3;            /*!< [11..9] ADC channel 3 sampling time selection                             */
      __IOM uint32_t SMP4       : 3;            /*!< [14..12] ADC channel 4 sampling time selection                            */
      __IOM uint32_t SMP5       : 3;            /*!< [17..15] ADC channel 5 sampling time selection                            */
      __IOM uint32_t SMP6       : 3;            /*!< [20..18] ADC channel 6 sampling time selection                            */
      __IOM uint32_t SMP7       : 3;            /*!< [23..21] ADC channel 7 sampling time selection                            */
      __IOM uint32_t SMP8       : 3;            /*!< [26..24] ADC channel 8 sampling time selection                            */
      __IOM uint32_t SMP9       : 3;            /*!< [29..27] ADC channel 9 sampling time selection                            */
            uint32_t            : 2;
    } SMPR1_b;
  } ;
  
  union {
    __IOM uint32_t SMPR2;                       /*!< (@ 0x00000018) ADC sampling time register 2                               */
    
    struct {
      __IOM uint32_t SMP10      : 3;            /*!< [2..0] ADC channel 10 sampling time selection                             */
      __IOM uint32_t SMP11      : 3;            /*!< [5..3] ADC channel 11 sampling time selection                             */
      __IOM uint32_t SMP12      : 3;            /*!< [8..6] ADC channel 12 sampling time selection                             */
      __IOM uint32_t SMP13      : 3;            /*!< [11..9] ADC channel 13 sampling time selection                            */
      __IOM uint32_t SMP14      : 3;            /*!< [14..12] ADC channel 14 sampling time selection                           */
      __IOM uint32_t SMP15      : 3;            /*!< [17..15] ADC channel 15 sampling time selection                           */
      __IOM uint32_t SMP16      : 3;            /*!< [20..18] ADC channel 16 sampling time selection                           */
      __IOM uint32_t SMP17      : 3;            /*!< [23..21] ADC channel 17 sampling time selection                           */
      __IOM uint32_t SMP18      : 3;            /*!< [26..24] ADC channel 18 sampling time selection                           */
      __IOM uint32_t SMP19      : 3;            /*!< [29..27] ADC channel 18 sampling time selection                           */
            uint32_t            : 2;
    } SMPR2_b;
  } ;
  
  union {
    __IOM uint32_t PCSEL;                       /*!< (@ 0x0000001C) ADC pre channel selection register                         */
    
    struct {
      __IOM uint32_t PCSEL      : 20;           /*!< [19..0] Channel x (VINP[i]) pre selection                                 */
            uint32_t            : 12;
    } PCSEL_b;
  } ;
  
  union {
    __IOM uint32_t LTR1;                        /*!< (@ 0x00000020) ADC analog watchdog 1 threshold register                   */
    
    struct {
      __IOM uint32_t LTR1       : 26;           /*!< [25..0] ADC analog watchdog 1 threshold low                               */
            uint32_t            : 6;
    } LTR1_b;
  } ;
  
  union {
    __IOM uint32_t LHTR1;                       /*!< (@ 0x00000024) ADC analog watchdog 2 threshold register                   */
    
    struct {
      __IOM uint32_t LHTR1      : 26;           /*!< [25..0] ADC analog watchdog 2 threshold low                               */
            uint32_t            : 6;
    } LHTR1_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t SQR1;                        /*!< (@ 0x00000030) ADC group regular sequencer ranks register 1               */
    
    struct {
      __IOM uint32_t L3         : 4;            /*!< [3..0] L3                                                                 */
            uint32_t            : 2;
      __IOM uint32_t SQ1        : 5;            /*!< [10..6] ADC group regular sequencer rank 1                                */
            uint32_t            : 1;
      __IOM uint32_t SQ2        : 5;            /*!< [16..12] ADC group regular sequencer rank 2                               */
            uint32_t            : 1;
      __IOM uint32_t SQ3        : 5;            /*!< [22..18] ADC group regular sequencer rank 3                               */
            uint32_t            : 1;
      __IOM uint32_t SQ4        : 5;            /*!< [28..24] ADC group regular sequencer rank 4                               */
            uint32_t            : 3;
    } SQR1_b;
  } ;
  
  union {
    __IOM uint32_t SQR2;                        /*!< (@ 0x00000034) ADC group regular sequencer ranks register 2               */
    
    struct {
      __IOM uint32_t SQ5        : 5;            /*!< [4..0] ADC group regular sequencer rank 5                                 */
            uint32_t            : 1;
      __IOM uint32_t SQ6        : 5;            /*!< [10..6] ADC group regular sequencer rank 6                                */
            uint32_t            : 1;
      __IOM uint32_t SQ7        : 5;            /*!< [16..12] ADC group regular sequencer rank 7                               */
            uint32_t            : 1;
      __IOM uint32_t SQ8        : 5;            /*!< [22..18] ADC group regular sequencer rank 8                               */
            uint32_t            : 1;
      __IOM uint32_t SQ9        : 5;            /*!< [28..24] ADC group regular sequencer rank 9                               */
            uint32_t            : 3;
    } SQR2_b;
  } ;
  
  union {
    __IOM uint32_t SQR3;                        /*!< (@ 0x00000038) ADC group regular sequencer ranks register 3               */
    
    struct {
      __IOM uint32_t SQ10       : 5;            /*!< [4..0] ADC group regular sequencer rank 10                                */
            uint32_t            : 1;
      __IOM uint32_t SQ11       : 5;            /*!< [10..6] ADC group regular sequencer rank 11                               */
            uint32_t            : 1;
      __IOM uint32_t SQ12       : 5;            /*!< [16..12] ADC group regular sequencer rank 12                              */
            uint32_t            : 1;
      __IOM uint32_t SQ13       : 5;            /*!< [22..18] ADC group regular sequencer rank 13                              */
            uint32_t            : 1;
      __IOM uint32_t SQ14       : 5;            /*!< [28..24] ADC group regular sequencer rank 14                              */
            uint32_t            : 3;
    } SQR3_b;
  } ;
  
  union {
    __IOM uint32_t SQR4;                        /*!< (@ 0x0000003C) ADC group regular sequencer ranks register 4               */
    
    struct {
      __IOM uint32_t SQ15       : 5;            /*!< [4..0] ADC group regular sequencer rank 15                                */
            uint32_t            : 1;
      __IOM uint32_t SQ16       : 5;            /*!< [10..6] ADC group regular sequencer rank 16                               */
            uint32_t            : 21;
    } SQR4_b;
  } ;
  
  union {
    __IM  uint32_t DR;                          /*!< (@ 0x00000040) ADC group regular conversion data register                 */
    
    struct {
      __IM  uint32_t RDATA      : 16;           /*!< [15..0] ADC group regular conversion data                                 */
            uint32_t            : 16;
    } DR_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t JSQR;                        /*!< (@ 0x0000004C) ADC group injected sequencer register                      */
    
    struct {
      __IOM uint32_t JL         : 2;            /*!< [1..0] ADC group injected sequencer scan length                           */
      __IOM uint32_t JEXTSEL    : 5;            /*!< [6..2] ADC group injected external trigger source                         */
      __IOM uint32_t JEXTEN     : 2;            /*!< [8..7] ADC group injected external trigger polarity                       */
      __IOM uint32_t JSQ1       : 5;            /*!< [13..9] ADC group injected sequencer rank 1                               */
            uint32_t            : 1;
      __IOM uint32_t JSQ2       : 5;            /*!< [19..15] ADC group injected sequencer rank 2                              */
            uint32_t            : 1;
      __IOM uint32_t JSQ3       : 5;            /*!< [25..21] ADC group injected sequencer rank 3                              */
            uint32_t            : 1;
      __IOM uint32_t JSQ4       : 5;            /*!< [31..27] ADC group injected sequencer rank 4                              */
    } JSQR_b;
  } ;
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t OFR1;                        /*!< (@ 0x00000060) ADC offset number 1 register                               */
    
    struct {
      __IOM uint32_t OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32_t OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32_t SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } OFR1_b;
  } ;
  
  union {
    __IOM uint32_t OFR2;                        /*!< (@ 0x00000064) ADC offset number 2 register                               */
    
    struct {
      __IOM uint32_t OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32_t OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32_t SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } OFR2_b;
  } ;
  
  union {
    __IOM uint32_t OFR3;                        /*!< (@ 0x00000068) ADC offset number 3 register                               */
    
    struct {
      __IOM uint32_t OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32_t OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32_t SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } OFR3_b;
  } ;
  
  union {
    __IOM uint32_t OFR4;                        /*!< (@ 0x0000006C) ADC offset number 4 register                               */
    
    struct {
      __IOM uint32_t OFFSET1    : 26;           /*!< [25..0] ADC offset number 1 offset level                                  */
      __IOM uint32_t OFFSET1_CH : 5;            /*!< [30..26] ADC offset number 1 channel selection                            */
      __IOM uint32_t SSATE      : 1;            /*!< [31..31] ADC offset number 1 enable                                       */
    } OFR4_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IM  uint32_t JDR1;                        /*!< (@ 0x00000080) ADC group injected sequencer rank 1 register               */
    
    struct {
      __IM  uint32_t JDATA1     : 32;           /*!< [31..0] ADC group injected sequencer rank 1 conversion data               */
    } JDR1_b;
  } ;
  
  union {
    __IM  uint32_t JDR2;                        /*!< (@ 0x00000084) ADC group injected sequencer rank 2 register               */
    
    struct {
      __IM  uint32_t JDATA2     : 32;           /*!< [31..0] ADC group injected sequencer rank 2 conversion data               */
    } JDR2_b;
  } ;
  
  union {
    __IM  uint32_t JDR3;                        /*!< (@ 0x00000088) ADC group injected sequencer rank 3 register               */
    
    struct {
      __IM  uint32_t JDATA3     : 32;           /*!< [31..0] ADC group injected sequencer rank 3 conversion data               */
    } JDR3_b;
  } ;
  
  union {
    __IM  uint32_t JDR4;                        /*!< (@ 0x0000008C) ADC group injected sequencer rank 4 register               */
    
    struct {
      __IM  uint32_t JDATA4     : 32;           /*!< [31..0] ADC group injected sequencer rank 4 conversion data               */
    } JDR4_b;
  } ;
  __IM  uint32_t  RESERVED4[4];
  
  union {
    __IOM uint32_t AWD2CR;                      /*!< (@ 0x000000A0) ADC analog watchdog 2 configuration register               */
    
    struct {
      __IOM uint32_t AWD2CH     : 20;           /*!< [19..0] ADC analog watchdog 2 monitored channel selection                 */
            uint32_t            : 12;
    } AWD2CR_b;
  } ;
  
  union {
    __IOM uint32_t AWD3CR;                      /*!< (@ 0x000000A4) ADC analog watchdog 3 configuration register               */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t AWD3CH     : 20;           /*!< [20..1] ADC analog watchdog 3 monitored channel selection                 */
            uint32_t            : 11;
    } AWD3CR_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t LTR2;                        /*!< (@ 0x000000B0) ADC watchdog lower threshold register 2                    */
    
    struct {
      __IOM uint32_t LTR2       : 26;           /*!< [25..0] Analog watchdog 2 lower threshold                                 */
            uint32_t            : 6;
    } LTR2_b;
  } ;
  
  union {
    __IOM uint32_t HTR2;                        /*!< (@ 0x000000B4) ADC watchdog higher threshold register 2                   */
    
    struct {
      __IOM uint32_t HTR2       : 26;           /*!< [25..0] Analog watchdog 2 higher threshold                                */
            uint32_t            : 6;
    } HTR2_b;
  } ;
  
  union {
    __IOM uint32_t LTR3;                        /*!< (@ 0x000000B8) ADC watchdog lower threshold register 3                    */
    
    struct {
      __IOM uint32_t LTR3       : 26;           /*!< [25..0] Analog watchdog 3 lower threshold                                 */
            uint32_t            : 6;
    } LTR3_b;
  } ;
  
  union {
    __IOM uint32_t HTR3;                        /*!< (@ 0x000000BC) ADC watchdog higher threshold register 3                   */
    
    struct {
      __IOM uint32_t HTR3       : 26;           /*!< [25..0] Analog watchdog 3 higher threshold                                */
            uint32_t            : 6;
    } HTR3_b;
  } ;
  
  union {
    __IOM uint32_t DIFSEL;                      /*!< (@ 0x000000C0) ADC channel differential or single-ended mode
                                                                    selection register                                         */
    
    struct {
      __IOM uint32_t DIFSEL     : 20;           /*!< [19..0] ADC channel differential or single-ended mode for channel         */
            uint32_t            : 12;
    } DIFSEL_b;
  } ;
  
  union {
    __IOM uint32_t CALFACT;                     /*!< (@ 0x000000C4) ADC calibration factors register                           */
    
    struct {
      __IOM uint32_t CALFACT_S  : 11;           /*!< [10..0] ADC calibration factor in single-ended mode                       */
            uint32_t            : 5;
      __IOM uint32_t CALFACT_D  : 11;           /*!< [26..16] ADC calibration factor in differential mode                      */
            uint32_t            : 5;
    } CALFACT_b;
  } ;
  
  union {
    __IOM uint32_t CALFACT2;                    /*!< (@ 0x000000C8) ADC Calibration Factor register 2                          */
    
    struct {
      __IOM uint32_t LINCALFACT : 30;           /*!< [29..0] Linearity Calibration Factor                                      */
            uint32_t            : 2;
    } CALFACT2_b;
  } ;
} ADC3_Type;                                    /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                        ADC3_Common                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog-to-Digital Converter (ADC3_Common)
  */

typedef struct {                                /*!< (@ 0x58026300) ADC3_Common Structure                                      */
  
  union {
    __IM  uint32_t CSR;                         /*!< (@ 0x00000000) ADC Common status register                                 */
    
    struct {
      __IM  uint32_t ADRDY_MST  : 1;            /*!< [0..0] Master ADC ready                                                   */
      __IM  uint32_t EOSMP_MST  : 1;            /*!< [1..1] End of Sampling phase flag of the master ADC                       */
      __IM  uint32_t EOC_MST    : 1;            /*!< [2..2] End of regular conversion of the master ADC                        */
      __IM  uint32_t EOS_MST    : 1;            /*!< [3..3] End of regular sequence flag of the master ADC                     */
      __IM  uint32_t OVR_MST    : 1;            /*!< [4..4] Overrun flag of the master ADC                                     */
      __IM  uint32_t JEOC_MST   : 1;            /*!< [5..5] End of injected conversion flag of the master ADC                  */
      __IM  uint32_t JEOS_MST   : 1;            /*!< [6..6] End of injected sequence flag of the master ADC                    */
      __IM  uint32_t AWD1_MST   : 1;            /*!< [7..7] Analog watchdog 1 flag of the master ADC                           */
      __IM  uint32_t AWD2_MST   : 1;            /*!< [8..8] Analog watchdog 2 flag of the master ADC                           */
      __IM  uint32_t AWD3_MST   : 1;            /*!< [9..9] Analog watchdog 3 flag of the master ADC                           */
      __IM  uint32_t JQOVF_MST  : 1;            /*!< [10..10] Injected Context Queue Overflow flag of the master
                                                     ADC                                                                       */
            uint32_t            : 5;
      __IM  uint32_t ADRDY_SLV  : 1;            /*!< [16..16] Slave ADC ready                                                  */
      __IM  uint32_t EOSMP_SLV  : 1;            /*!< [17..17] End of Sampling phase flag of the slave ADC                      */
      __IM  uint32_t EOC_SLV    : 1;            /*!< [18..18] End of regular conversion of the slave ADC                       */
      __IM  uint32_t EOS_SLV    : 1;            /*!< [19..19] End of regular sequence flag of the slave ADC                    */
      __IM  uint32_t OVR_SLV    : 1;            /*!< [20..20] Overrun flag of the slave ADC                                    */
      __IM  uint32_t JEOC_SLV   : 1;            /*!< [21..21] End of injected conversion flag of the slave ADC                 */
      __IM  uint32_t JEOS_SLV   : 1;            /*!< [22..22] End of injected sequence flag of the slave ADC                   */
      __IM  uint32_t AWD1_SLV   : 1;            /*!< [23..23] Analog watchdog 1 flag of the slave ADC                          */
      __IM  uint32_t AWD2_SLV   : 1;            /*!< [24..24] Analog watchdog 2 flag of the slave ADC                          */
      __IM  uint32_t AWD3_SLV   : 1;            /*!< [25..25] Analog watchdog 3 flag of the slave ADC                          */
      __IM  uint32_t JQOVF_SLV  : 1;            /*!< [26..26] Injected Context Queue Overflow flag of the slave ADC            */
            uint32_t            : 5;
    } CSR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t CCR;                         /*!< (@ 0x00000008) ADC common control register                                */
    
    struct {
      __IOM uint32_t DUAL       : 5;            /*!< [4..0] Dual ADC mode selection                                            */
            uint32_t            : 3;
      __IOM uint32_t DELAY      : 4;            /*!< [11..8] Delay between 2 sampling phases                                   */
            uint32_t            : 2;
      __IOM uint32_t DAMDF      : 2;            /*!< [15..14] Dual ADC Mode Data Format                                        */
      __IOM uint32_t CKMODE     : 2;            /*!< [17..16] ADC clock mode                                                   */
      __IOM uint32_t PRESC      : 4;            /*!< [21..18] ADC prescaler                                                    */
      __IOM uint32_t VREFEN     : 1;            /*!< [22..22] VREFINT enable                                                   */
      __IOM uint32_t VSENSEEN   : 1;            /*!< [23..23] Temperature sensor enable                                        */
      __IOM uint32_t VBATEN     : 1;            /*!< [24..24] VBAT enable                                                      */
            uint32_t            : 7;
    } CCR_b;
  } ;
  
  union {
    __IM  uint32_t CDR;                         /*!< (@ 0x0000000C) ADC common regular data register for dual and
                                                                    triple modes                                               */
    
    struct {
      __IM  uint32_t RDATA_MST  : 16;           /*!< [15..0] Regular data of the master ADC                                    */
      __IM  uint32_t RDATA_SLV  : 16;           /*!< [31..16] Regular data of the slave ADC                                    */
    } CDR_b;
  } ;
} ADC3_Common_Type;                             /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          DMAMUX1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DMAMUX (DMAMUX1)
  */

typedef struct {                                /*!< (@ 0x40020800) DMAMUX1 Structure                                          */
  
  union {
    __IOM uint32_t DMAMUX1_C0CR;                /*!< (@ 0x00000000) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C0CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C1CR;                /*!< (@ 0x00000004) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C1CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C2CR;                /*!< (@ 0x00000008) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C2CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C3CR;                /*!< (@ 0x0000000C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C3CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C4CR;                /*!< (@ 0x00000010) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C4CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C5CR;                /*!< (@ 0x00000014) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C5CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C6CR;                /*!< (@ 0x00000018) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C6CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C7CR;                /*!< (@ 0x0000001C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C7CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C8CR;                /*!< (@ 0x00000020) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C8CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C9CR;                /*!< (@ 0x00000024) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C9CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C10CR;               /*!< (@ 0x00000028) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C10CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C11CR;               /*!< (@ 0x0000002C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C11CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C12CR;               /*!< (@ 0x00000030) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C12CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C13CR;               /*!< (@ 0x00000034) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C13CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C14CR;               /*!< (@ 0x00000038) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C14CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_C15CR;               /*!< (@ 0x0000003C) DMAMux - DMA request line multiplexer channel
                                                                    x control register                                         */
    
    struct {
      __IOM uint32_t DMAREQ_ID  : 8;            /*!< [7..0] Input DMA request line selected                                    */
      __IOM uint32_t SOIE       : 1;            /*!< [8..8] Interrupt enable at synchronization event overrun                  */
      __IOM uint32_t EGE        : 1;            /*!< [9..9] Event generation enable/disable                                    */
            uint32_t            : 6;
      __IOM uint32_t SE         : 1;            /*!< [16..16] Synchronous operating mode enable/disable                        */
      __IOM uint32_t SPOL       : 2;            /*!< [18..17] Synchronization event type selector Defines the synchronization
                                                     event on the selected synchronization input:                              */
      __IOM uint32_t NBREQ      : 5;            /*!< [23..19] Number of DMA requests to forward Defines the number
                                                     of DMA requests forwarded before output event is generated.
                                                     In synchronous mode, it also defines the number of DMA
                                                     requests to forward after a synchronization event, then
                                                     stop forwarding. The actual number of DMA requests forwarded
                                                     is NBREQ+1. Note: This field can only be written when both
                                                     SE and EGE bits are reset.                                                */
      __IOM uint32_t SYNC_ID    : 5;            /*!< [28..24] Synchronization input selected                                   */
            uint32_t            : 3;
    } DMAMUX1_C15CR_b;
  } ;
  __IM  uint32_t  RESERVED[16];
  
  union {
    __IM  uint32_t DMAMUX1_CSR;                 /*!< (@ 0x00000080) DMAMUX request line multiplexer interrupt channel
                                                                    status register                                            */
    
    struct {
      __IM  uint32_t SOF        : 16;           /*!< [15..0] Synchronization overrun event flag                                */
            uint32_t            : 16;
    } DMAMUX1_CSR_b;
  } ;
  
  union {
    __OM  uint32_t DMAMUX1_CFR;                 /*!< (@ 0x00000084) DMAMUX request line multiplexer interrupt clear
                                                                    flag register                                              */
    
    struct {
      __OM  uint32_t CSOF       : 16;           /*!< [15..0] Clear synchronization overrun event flag                          */
            uint32_t            : 16;
    } DMAMUX1_CFR_b;
  } ;
  __IM  uint32_t  RESERVED1[30];
  
  union {
    __IOM uint32_t DMAMUX1_RG0CR;               /*!< (@ 0x00000100) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG0CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG1CR;               /*!< (@ 0x00000104) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG1CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG2CR;               /*!< (@ 0x00000108) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG2CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG3CR;               /*!< (@ 0x0000010C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG3CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG4CR;               /*!< (@ 0x00000110) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG4CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG5CR;               /*!< (@ 0x00000114) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG5CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG6CR;               /*!< (@ 0x00000118) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG6CR_b;
  } ;
  
  union {
    __IOM uint32_t DMAMUX1_RG7CR;               /*!< (@ 0x0000011C) DMAMux - DMA request generator channel x control
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t SIG_ID     : 5;            /*!< [4..0] DMA request trigger input selected                                 */
            uint32_t            : 3;
      __IOM uint32_t OIE        : 1;            /*!< [8..8] Interrupt enable at trigger event overrun                          */
            uint32_t            : 7;
      __IOM uint32_t GE         : 1;            /*!< [16..16] DMA request generator channel enable/disable                     */
      __IOM uint32_t GPOL       : 2;            /*!< [18..17] DMA request generator trigger event type selection
                                                     Defines the trigger event on the selected DMA request trigger
                                                     input                                                                     */
      __IOM uint32_t GNBREQ     : 5;            /*!< [23..19] Number of DMA requests to generate Defines the number
                                                     of DMA requests generated after a trigger event, then stop
                                                     generating. The actual number of generated DMA requests
                                                     is GNBREQ+1. Note: This field can only be written when
                                                     GE bit is reset.                                                          */
            uint32_t            : 8;
    } DMAMUX1_RG7CR_b;
  } ;
  __IM  uint32_t  RESERVED2[8];
  
  union {
    __IM  uint32_t DMAMUX1_RGSR;                /*!< (@ 0x00000140) DMAMux - DMA request generator status register             */
    
    struct {
      __IM  uint32_t OF         : 8;            /*!< [7..0] Trigger event overrun flag The flag is set when a trigger
                                                     event occurs on DMA request generator channel x, while
                                                     the DMA request generator counter value is lower than GNBREQ.
                                                     The flag is cleared by writing 1 to the corresponding COFx
                                                     bit in DMAMUX_RGCFR register.                                             */
            uint32_t            : 24;
    } DMAMUX1_RGSR_b;
  } ;
  
  union {
    __OM  uint32_t DMAMUX1_RGCFR;               /*!< (@ 0x00000144) DMAMux - DMA request generator clear flag register         */
    
    struct {
      __OM  uint32_t COF        : 8;            /*!< [7..0] Clear trigger event overrun flag Upon setting, this bit
                                                     clears the corresponding overrun flag OFx in the DMAMUX_RGCSR
                                                     register.                                                                 */
            uint32_t            : 24;
    } DMAMUX1_RGCFR_b;
  } ;
} DMAMUX1_Type;                                 /*!< Size = 328 (0x148)                                                        */



/* =========================================================================================================================== */
/* ================                                            CRC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Cryptographic processor (CRC)
  */

typedef struct {                                /*!< (@ 0x58024C00) CRC Structure                                              */
  
  union {
    __IOM uint32_t DR;                          /*!< (@ 0x00000000) Data register                                              */
    
    struct {
      __IOM uint32_t DR         : 32;           /*!< [31..0] Data Register                                                     */
    } DR_b;
  } ;
  
  union {
    __IOM uint32_t IDR;                         /*!< (@ 0x00000004) Independent Data register                                  */
    
    struct {
      __IOM uint32_t IDR        : 32;           /*!< [31..0] Independent Data register                                         */
    } IDR_b;
  } ;
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000008) Control register                                           */
    
    struct {
      __OM  uint32_t RESET      : 1;            /*!< [0..0] RESET bit                                                          */
            uint32_t            : 2;
      __IOM uint32_t POLYSIZE   : 2;            /*!< [4..3] Polynomial size                                                    */
      __IOM uint32_t REV_IN     : 2;            /*!< [6..5] Reverse input data                                                 */
      __IOM uint32_t REV_OUT    : 1;            /*!< [7..7] Reverse output data                                                */
            uint32_t            : 24;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t INIT;                        /*!< (@ 0x0000000C) Initial CRC value                                          */
    
    struct {
      __IOM uint32_t CRC_INIT   : 32;           /*!< [31..0] Programmable initial CRC value                                    */
    } INIT_b;
  } ;
  
  union {
    __IOM uint32_t POL;                         /*!< (@ 0x00000010) CRC polynomial                                             */
    
    struct {
      __IOM uint32_t POL        : 32;           /*!< [31..0] Programmable polynomial                                           */
    } POL_b;
  } ;
} CRC_Type;                                     /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            RCC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset and clock control (RCC)
  */

typedef struct {                                /*!< (@ 0x58024400) RCC Structure                                              */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) clock control register                                     */
    
    struct {
      __IOM uint32_t HSION      : 1;            /*!< [0..0] Internal high-speed clock enable                                   */
      __IOM uint32_t HSIKERON   : 1;            /*!< [1..1] High Speed Internal clock enable in Stop mode                      */
      __IOM uint32_t HSIRDY     : 1;            /*!< [2..2] HSI clock ready flag                                               */
      __IOM uint32_t HSIDIV     : 2;            /*!< [4..3] HSI clock divider                                                  */
      __IOM uint32_t HSIDIVF    : 1;            /*!< [5..5] HSI divider flag                                                   */
            uint32_t            : 1;
      __IOM uint32_t CSION      : 1;            /*!< [7..7] CSI clock enable                                                   */
      __IOM uint32_t CSIRDY     : 1;            /*!< [8..8] CSI clock ready flag                                               */
      __IOM uint32_t CSIKERON   : 1;            /*!< [9..9] CSI clock enable in Stop mode                                      */
            uint32_t            : 2;
      __IOM uint32_t RC48ON     : 1;            /*!< [12..12] RC48 clock enable                                                */
      __IOM uint32_t RC48RDY    : 1;            /*!< [13..13] RC48 clock ready flag                                            */
      __IOM uint32_t D1CKRDY    : 1;            /*!< [14..14] D1 domain clocks ready flag                                      */
      __IOM uint32_t D2CKRDY    : 1;            /*!< [15..15] D2 domain clocks ready flag                                      */
      __IOM uint32_t HSEON      : 1;            /*!< [16..16] HSE clock enable                                                 */
      __IOM uint32_t HSERDY     : 1;            /*!< [17..17] HSE clock ready flag                                             */
      __IOM uint32_t HSEBYP     : 1;            /*!< [18..18] HSE clock bypass                                                 */
      __IOM uint32_t HSECSSON   : 1;            /*!< [19..19] HSE Clock Security System enable                                 */
            uint32_t            : 4;
      __IOM uint32_t PLL1ON     : 1;            /*!< [24..24] PLL1 enable                                                      */
      __IOM uint32_t PLL1RDY    : 1;            /*!< [25..25] PLL1 clock ready flag                                            */
      __IOM uint32_t PLL2ON     : 1;            /*!< [26..26] PLL2 enable                                                      */
      __IOM uint32_t PLL2RDY    : 1;            /*!< [27..27] PLL2 clock ready flag                                            */
      __IOM uint32_t PLL3ON     : 1;            /*!< [28..28] PLL3 enable                                                      */
      __IOM uint32_t PLL3RDY    : 1;            /*!< [29..29] PLL3 clock ready flag                                            */
            uint32_t            : 2;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t ICSCR;                       /*!< (@ 0x00000004) RCC Internal Clock Source Calibration Register             */
    
    struct {
      __IM  uint32_t HSICAL     : 12;           /*!< [11..0] HSI clock calibration                                             */
      __IOM uint32_t HSITRIM    : 6;            /*!< [17..12] HSI clock trimming                                               */
      __IM  uint32_t CSICAL     : 8;            /*!< [25..18] CSI clock calibration                                            */
      __IOM uint32_t CSITRIM    : 5;            /*!< [30..26] CSI clock trimming                                               */
            uint32_t            : 1;
    } ICSCR_b;
  } ;
  
  union {
    __IM  uint32_t CRRCR;                       /*!< (@ 0x00000008) RCC Clock Recovery RC Register                             */
    
    struct {
      __IM  uint32_t RC48CAL    : 10;           /*!< [9..0] Internal RC 48 MHz clock calibration                               */
            uint32_t            : 22;
    } CRRCR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t CFGR;                        /*!< (@ 0x00000010) RCC Clock Configuration Register                           */
    
    struct {
      __IOM uint32_t SW         : 3;            /*!< [2..0] System clock switch                                                */
      __IOM uint32_t SWS        : 3;            /*!< [5..3] System clock switch status                                         */
      __IOM uint32_t STOPWUCK   : 1;            /*!< [6..6] System clock selection after a wake up from system Stop            */
      __IOM uint32_t STOPKERWUCK : 1;           /*!< [7..7] Kernel clock selection after a wake up from system Stop            */
      __IOM uint32_t RTCPRE     : 6;            /*!< [13..8] HSE division factor for RTC clock                                 */
      __IOM uint32_t HRTIMSEL   : 1;            /*!< [14..14] High Resolution Timer clock prescaler selection                  */
      __IOM uint32_t TIMPRE     : 1;            /*!< [15..15] Timers clocks prescaler selection                                */
            uint32_t            : 2;
      __IOM uint32_t MCO1PRE    : 4;            /*!< [21..18] MCO1 prescaler                                                   */
      __IOM uint32_t MCO1SEL    : 3;            /*!< [24..22] Micro-controller clock output 1                                  */
      __IOM uint32_t MCO2PRE    : 4;            /*!< [28..25] MCO2 prescaler                                                   */
      __IOM uint32_t MCO2SEL    : 3;            /*!< [31..29] Micro-controller clock output 2                                  */
    } CFGR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t D1CFGR;                      /*!< (@ 0x00000018) RCC Domain 1 Clock Configuration Register                  */
    
    struct {
      __IOM uint32_t HPRE       : 4;            /*!< [3..0] D1 domain AHB prescaler                                            */
      __IOM uint32_t D1PPRE     : 3;            /*!< [6..4] D1 domain APB3 prescaler                                           */
            uint32_t            : 1;
      __IOM uint32_t D1CPRE     : 4;            /*!< [11..8] D1 domain Core prescaler                                          */
            uint32_t            : 20;
    } D1CFGR_b;
  } ;
  
  union {
    __IOM uint32_t D2CFGR;                      /*!< (@ 0x0000001C) RCC Domain 2 Clock Configuration Register                  */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t D2PPRE1    : 3;            /*!< [6..4] D2 domain APB1 prescaler                                           */
            uint32_t            : 1;
      __IOM uint32_t D2PPRE2    : 3;            /*!< [10..8] D2 domain APB2 prescaler                                          */
            uint32_t            : 21;
    } D2CFGR_b;
  } ;
  
  union {
    __IOM uint32_t D3CFGR;                      /*!< (@ 0x00000020) RCC Domain 3 Clock Configuration Register                  */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t D3PPRE     : 3;            /*!< [6..4] D3 domain APB4 prescaler                                           */
            uint32_t            : 25;
    } D3CFGR_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t PLLCKSELR;                   /*!< (@ 0x00000028) RCC PLLs Clock Source Selection Register                   */
    
    struct {
      __IOM uint32_t PLLSRC     : 2;            /*!< [1..0] DIVMx and PLLs clock source selection                              */
            uint32_t            : 2;
      __IOM uint32_t DIVM1      : 6;            /*!< [9..4] Prescaler for PLL1                                                 */
            uint32_t            : 2;
      __IOM uint32_t DIVM2      : 6;            /*!< [17..12] Prescaler for PLL2                                               */
            uint32_t            : 2;
      __IOM uint32_t DIVM3      : 6;            /*!< [25..20] Prescaler for PLL3                                               */
            uint32_t            : 6;
    } PLLCKSELR_b;
  } ;
  
  union {
    __IOM uint32_t PLLCFGR;                     /*!< (@ 0x0000002C) RCC PLLs Configuration Register                            */
    
    struct {
      __IOM uint32_t PLL1FRACEN : 1;            /*!< [0..0] PLL1 fractional latch enable                                       */
      __IOM uint32_t PLL1VCOSEL : 1;            /*!< [1..1] PLL1 VCO selection                                                 */
      __IOM uint32_t PLL1RGE    : 2;            /*!< [3..2] PLL1 input frequency range                                         */
      __IOM uint32_t PLL2FRACEN : 1;            /*!< [4..4] PLL2 fractional latch enable                                       */
      __IOM uint32_t PLL2VCOSEL : 1;            /*!< [5..5] PLL2 VCO selection                                                 */
      __IOM uint32_t PLL2RGE    : 2;            /*!< [7..6] PLL2 input frequency range                                         */
      __IOM uint32_t PLL3FRACEN : 1;            /*!< [8..8] PLL3 fractional latch enable                                       */
      __IOM uint32_t PLL3VCOSEL : 1;            /*!< [9..9] PLL3 VCO selection                                                 */
      __IOM uint32_t PLL3RGE    : 2;            /*!< [11..10] PLL3 input frequency range                                       */
            uint32_t            : 4;
      __IOM uint32_t DIVP1EN    : 1;            /*!< [16..16] PLL1 DIVP divider output enable                                  */
      __IOM uint32_t DIVQ1EN    : 1;            /*!< [17..17] PLL1 DIVQ divider output enable                                  */
      __IOM uint32_t DIVR1EN    : 1;            /*!< [18..18] PLL1 DIVR divider output enable                                  */
      __IOM uint32_t DIVP2EN    : 1;            /*!< [19..19] PLL2 DIVP divider output enable                                  */
      __IOM uint32_t DIVQ2EN    : 1;            /*!< [20..20] PLL2 DIVQ divider output enable                                  */
      __IOM uint32_t DIVR2EN    : 1;            /*!< [21..21] PLL2 DIVR divider output enable                                  */
      __IOM uint32_t DIVP3EN    : 1;            /*!< [22..22] PLL3 DIVP divider output enable                                  */
      __IOM uint32_t DIVQ3EN    : 1;            /*!< [23..23] PLL3 DIVQ divider output enable                                  */
      __IOM uint32_t DIVR3EN    : 1;            /*!< [24..24] PLL3 DIVR divider output enable                                  */
            uint32_t            : 7;
    } PLLCFGR_b;
  } ;
  
  union {
    __IOM uint32_t PLL1DIVR;                    /*!< (@ 0x00000030) RCC PLL1 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32_t DIVN1      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32_t DIVP1      : 7;            /*!< [15..9] PLL1 DIVP division factor                                         */
      __IOM uint32_t DIVQ1      : 7;            /*!< [22..16] PLL1 DIVQ division factor                                        */
            uint32_t            : 1;
      __IOM uint32_t DIVR1      : 7;            /*!< [30..24] PLL1 DIVR division factor                                        */
            uint32_t            : 1;
    } PLL1DIVR_b;
  } ;
  
  union {
    __IOM uint32_t PLL1FRACR;                   /*!< (@ 0x00000034) RCC PLL1 Fractional Divider Register                       */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t FRACN1     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL1
                                                     VCO                                                                       */
            uint32_t            : 16;
    } PLL1FRACR_b;
  } ;
  
  union {
    __IOM uint32_t PLL2DIVR;                    /*!< (@ 0x00000038) RCC PLL2 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32_t DIVN1      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32_t DIVP1      : 7;            /*!< [15..9] PLL1 DIVP division factor                                         */
      __IOM uint32_t DIVQ1      : 7;            /*!< [22..16] PLL1 DIVQ division factor                                        */
            uint32_t            : 1;
      __IOM uint32_t DIVR1      : 7;            /*!< [30..24] PLL1 DIVR division factor                                        */
            uint32_t            : 1;
    } PLL2DIVR_b;
  } ;
  
  union {
    __IOM uint32_t PLL2FRACR;                   /*!< (@ 0x0000003C) RCC PLL2 Fractional Divider Register                       */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t FRACN2     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL
                                                     VCO                                                                       */
            uint32_t            : 16;
    } PLL2FRACR_b;
  } ;
  
  union {
    __IOM uint32_t PLL3DIVR;                    /*!< (@ 0x00000040) RCC PLL3 Dividers Configuration Register                   */
    
    struct {
      __IOM uint32_t DIVN3      : 9;            /*!< [8..0] Multiplication factor for PLL1 VCO                                 */
      __IOM uint32_t DIVP3      : 7;            /*!< [15..9] PLL DIVP division factor                                          */
      __IOM uint32_t DIVQ3      : 7;            /*!< [22..16] PLL DIVQ division factor                                         */
            uint32_t            : 1;
      __IOM uint32_t DIVR3      : 7;            /*!< [30..24] PLL DIVR division factor                                         */
            uint32_t            : 1;
    } PLL3DIVR_b;
  } ;
  
  union {
    __IOM uint32_t PLL3FRACR;                   /*!< (@ 0x00000044) RCC PLL3 Fractional Divider Register                       */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t FRACN3     : 13;           /*!< [15..3] Fractional part of the multiplication factor for PLL3
                                                     VCO                                                                       */
            uint32_t            : 16;
    } PLL3FRACR_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t D1CCIPR;                     /*!< (@ 0x0000004C) RCC Domain 1 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32_t FMCSRC     : 2;            /*!< [1..0] FMC kernel clock source selection                                  */
            uint32_t            : 2;
      __IOM uint32_t QSPISRC    : 2;            /*!< [5..4] QUADSPI kernel clock source selection                              */
            uint32_t            : 10;
      __IOM uint32_t SDMMCSRC   : 1;            /*!< [16..16] SDMMC kernel clock source selection                              */
            uint32_t            : 11;
      __IOM uint32_t CKPERSRC   : 2;            /*!< [29..28] per_ck clock source selection                                    */
            uint32_t            : 2;
    } D1CCIPR_b;
  } ;
  
  union {
    __IOM uint32_t D2CCIP1R;                    /*!< (@ 0x00000050) RCC Domain 2 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32_t SAI1SRC    : 3;            /*!< [2..0] SAI1 and DFSDM1 kernel Aclk clock source selection                 */
            uint32_t            : 3;
      __IOM uint32_t SAI23SRC   : 3;            /*!< [8..6] SAI2 and SAI3 kernel clock source selection                        */
            uint32_t            : 3;
      __IOM uint32_t SPI123SRC  : 3;            /*!< [14..12] SPI/I2S1,2 and 3 kernel clock source selection                   */
            uint32_t            : 1;
      __IOM uint32_t SPI45SRC   : 3;            /*!< [18..16] SPI4 and 5 kernel clock source selection                         */
            uint32_t            : 1;
      __IOM uint32_t SPDIFSRC   : 2;            /*!< [21..20] SPDIFRX kernel clock source selection                            */
            uint32_t            : 2;
      __IOM uint32_t DFSDM1SRC  : 1;            /*!< [24..24] DFSDM1 kernel Clk clock source selection                         */
            uint32_t            : 3;
      __IOM uint32_t FDCANSRC   : 2;            /*!< [29..28] FDCAN kernel clock source selection                              */
            uint32_t            : 1;
      __IOM uint32_t SWPSRC     : 1;            /*!< [31..31] SWPMI kernel clock source selection                              */
    } D2CCIP1R_b;
  } ;
  
  union {
    __IOM uint32_t D2CCIP2R;                    /*!< (@ 0x00000054) RCC Domain 2 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32_t USART234578SRC : 3;        /*!< [2..0] USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection        */
      __IOM uint32_t USART16SRC : 3;            /*!< [5..3] USART1 and 6 kernel clock source selection                         */
            uint32_t            : 2;
      __IOM uint32_t RNGSRC     : 2;            /*!< [9..8] RNG kernel clock source selection                                  */
            uint32_t            : 2;
      __IOM uint32_t I2C123SRC  : 2;            /*!< [13..12] I2C1,2,3 kernel clock source selection                           */
            uint32_t            : 6;
      __IOM uint32_t USBSRC     : 2;            /*!< [21..20] USBOTG 1 and 2 kernel clock source selection                     */
      __IOM uint32_t CECSRC     : 2;            /*!< [23..22] HDMI-CEC kernel clock source selection                           */
            uint32_t            : 4;
      __IOM uint32_t LPTIM1SRC  : 3;            /*!< [30..28] LPTIM1 kernel clock source selection                             */
            uint32_t            : 1;
    } D2CCIP2R_b;
  } ;
  
  union {
    __IOM uint32_t D3CCIPR;                     /*!< (@ 0x00000058) RCC Domain 3 Kernel Clock Configuration Register           */
    
    struct {
      __IOM uint32_t LPUART1SRC : 3;            /*!< [2..0] LPUART1 kernel clock source selection                              */
            uint32_t            : 5;
      __IOM uint32_t I2C4SRC    : 2;            /*!< [9..8] I2C4 kernel clock source selection                                 */
      __IOM uint32_t LPTIM2SRC  : 3;            /*!< [12..10] LPTIM2 kernel clock source selection                             */
      __IOM uint32_t LPTIM345SRC : 3;           /*!< [15..13] LPTIM3,4,5 kernel clock source selection                         */
      __IOM uint32_t ADCSRC     : 2;            /*!< [17..16] SAR ADC kernel clock source selection                            */
            uint32_t            : 3;
      __IOM uint32_t SAI4ASRC   : 3;            /*!< [23..21] Sub-Block A of SAI4 kernel clock source selection                */
      __IOM uint32_t SAI4BSRC   : 3;            /*!< [26..24] Sub-Block B of SAI4 kernel clock source selection                */
            uint32_t            : 1;
      __IOM uint32_t SPI6SRC    : 3;            /*!< [30..28] SPI6 kernel clock source selection                               */
            uint32_t            : 1;
    } D3CCIPR_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t CIER;                        /*!< (@ 0x00000060) RCC Clock Source Interrupt Enable Register                 */
    
    struct {
      __IOM uint32_t LSIRDYIE   : 1;            /*!< [0..0] LSI ready Interrupt Enable                                         */
      __IOM uint32_t LSERDYIE   : 1;            /*!< [1..1] LSE ready Interrupt Enable                                         */
      __IOM uint32_t HSIRDYIE   : 1;            /*!< [2..2] HSI ready Interrupt Enable                                         */
      __IOM uint32_t HSERDYIE   : 1;            /*!< [3..3] HSE ready Interrupt Enable                                         */
      __IOM uint32_t CSIRDYIE   : 1;            /*!< [4..4] CSI ready Interrupt Enable                                         */
      __IOM uint32_t RC48RDYIE  : 1;            /*!< [5..5] RC48 ready Interrupt Enable                                        */
      __IOM uint32_t PLL1RDYIE  : 1;            /*!< [6..6] PLL1 ready Interrupt Enable                                        */
      __IOM uint32_t PLL2RDYIE  : 1;            /*!< [7..7] PLL2 ready Interrupt Enable                                        */
      __IOM uint32_t PLL3RDYIE  : 1;            /*!< [8..8] PLL3 ready Interrupt Enable                                        */
      __IOM uint32_t LSECSSIE   : 1;            /*!< [9..9] LSE clock security system Interrupt Enable                         */
            uint32_t            : 22;
    } CIER_b;
  } ;
  
  union {
    __IOM uint32_t CIFR;                        /*!< (@ 0x00000064) RCC Clock Source Interrupt Flag Register                   */
    
    struct {
      __IOM uint32_t LSIRDYF    : 1;            /*!< [0..0] LSI ready Interrupt Flag                                           */
      __IOM uint32_t LSERDYF    : 1;            /*!< [1..1] LSE ready Interrupt Flag                                           */
      __IOM uint32_t HSIRDYF    : 1;            /*!< [2..2] HSI ready Interrupt Flag                                           */
      __IOM uint32_t HSERDYF    : 1;            /*!< [3..3] HSE ready Interrupt Flag                                           */
      __IOM uint32_t CSIRDY     : 1;            /*!< [4..4] CSI ready Interrupt Flag                                           */
      __IOM uint32_t RC48RDYF   : 1;            /*!< [5..5] RC48 ready Interrupt Flag                                          */
      __IOM uint32_t PLL1RDYF   : 1;            /*!< [6..6] PLL1 ready Interrupt Flag                                          */
      __IOM uint32_t PLL2RDYF   : 1;            /*!< [7..7] PLL2 ready Interrupt Flag                                          */
      __IOM uint32_t PLL3RDYF   : 1;            /*!< [8..8] PLL3 ready Interrupt Flag                                          */
      __IOM uint32_t LSECSSF    : 1;            /*!< [9..9] LSE clock security system Interrupt Flag                           */
      __IOM uint32_t HSECSSF    : 1;            /*!< [10..10] HSE clock security system Interrupt Flag                         */
            uint32_t            : 21;
    } CIFR_b;
  } ;
  
  union {
    __IOM uint32_t CICR;                        /*!< (@ 0x00000068) RCC Clock Source Interrupt Clear Register                  */
    
    struct {
      __IOM uint32_t LSIRDYC    : 1;            /*!< [0..0] LSI ready Interrupt Clear                                          */
      __IOM uint32_t LSERDYC    : 1;            /*!< [1..1] LSE ready Interrupt Clear                                          */
      __IOM uint32_t HSIRDYC    : 1;            /*!< [2..2] HSI ready Interrupt Clear                                          */
      __IOM uint32_t HSERDYC    : 1;            /*!< [3..3] HSE ready Interrupt Clear                                          */
      __IOM uint32_t HSE_ready_Interrupt_Clear : 1;/*!< [4..4] CSI ready Interrupt Clear                                       */
      __IOM uint32_t RC48RDYC   : 1;            /*!< [5..5] RC48 ready Interrupt Clear                                         */
      __IOM uint32_t PLL1RDYC   : 1;            /*!< [6..6] PLL1 ready Interrupt Clear                                         */
      __IOM uint32_t PLL2RDYC   : 1;            /*!< [7..7] PLL2 ready Interrupt Clear                                         */
      __IOM uint32_t PLL3RDYC   : 1;            /*!< [8..8] PLL3 ready Interrupt Clear                                         */
      __IOM uint32_t LSECSSC    : 1;            /*!< [9..9] LSE clock security system Interrupt Clear                          */
      __IOM uint32_t HSECSSC    : 1;            /*!< [10..10] HSE clock security system Interrupt Clear                        */
            uint32_t            : 21;
    } CICR_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t BDCR;                        /*!< (@ 0x00000070) RCC Backup Domain Control Register                         */
    
    struct {
      __IOM uint32_t LSEON      : 1;            /*!< [0..0] LSE oscillator enabled                                             */
      __IOM uint32_t LSERDY     : 1;            /*!< [1..1] LSE oscillator ready                                               */
      __IOM uint32_t LSEBYP     : 1;            /*!< [2..2] LSE oscillator bypass                                              */
      __IOM uint32_t LSEDRV     : 2;            /*!< [4..3] LSE oscillator driving capability                                  */
      __IOM uint32_t LSECSSON   : 1;            /*!< [5..5] LSE clock security system enable                                   */
      __IOM uint32_t LSECSSD    : 1;            /*!< [6..6] LSE clock security system failure detection                        */
            uint32_t            : 1;
      __IOM uint32_t RTCSRC     : 2;            /*!< [9..8] RTC clock source selection                                         */
            uint32_t            : 5;
      __IOM uint32_t RTCEN      : 1;            /*!< [15..15] RTC clock enable                                                 */
      __IOM uint32_t VSWRST     : 1;            /*!< [16..16] VSwitch domain software reset                                    */
            uint32_t            : 15;
    } BDCR_b;
  } ;
  
  union {
    __IOM uint32_t CSR;                         /*!< (@ 0x00000074) RCC Clock Control and Status Register                      */
    
    struct {
      __IOM uint32_t LSION      : 1;            /*!< [0..0] LSI oscillator enable                                              */
      __IOM uint32_t LSIRDY     : 1;            /*!< [1..1] LSI oscillator ready                                               */
            uint32_t            : 30;
    } CSR_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t AHB3RSTR;                    /*!< (@ 0x0000007C) RCC AHB3 Reset Register                                    */
    
    struct {
      __IOM uint32_t MDMARST    : 1;            /*!< [0..0] MDMA block reset                                                   */
            uint32_t            : 3;
      __IOM uint32_t DMA2DRST   : 1;            /*!< [4..4] DMA2D block reset                                                  */
      __IOM uint32_t JPGDECRST  : 1;            /*!< [5..5] JPGDEC block reset                                                 */
            uint32_t            : 6;
      __IOM uint32_t FMCRST     : 1;            /*!< [12..12] FMC block reset                                                  */
            uint32_t            : 1;
      __IOM uint32_t QSPIRST    : 1;            /*!< [14..14] QUADSPI and QUADSPI delay block reset                            */
            uint32_t            : 1;
      __IOM uint32_t SDMMC1RST  : 1;            /*!< [16..16] SDMMC1 and SDMMC1 delay block reset                              */
            uint32_t            : 14;
      __IOM uint32_t CPURST     : 1;            /*!< [31..31] CPU reset                                                        */
    } AHB3RSTR_b;
  } ;
  
  union {
    __IOM uint32_t AHB1RSTR;                    /*!< (@ 0x00000080) RCC AHB1 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32_t DMA1RST    : 1;            /*!< [0..0] DMA1 block reset                                                   */
      __IOM uint32_t DMA2RST    : 1;            /*!< [1..1] DMA2 block reset                                                   */
            uint32_t            : 3;
      __IOM uint32_t ADC12RST   : 1;            /*!< [5..5] ADC1&2 block reset                                                 */
            uint32_t            : 9;
      __IOM uint32_t ETH1MACRST : 1;            /*!< [15..15] ETH1MAC block reset                                              */
            uint32_t            : 9;
      __IOM uint32_t USB1OTGRST : 1;            /*!< [25..25] USB1OTG block reset                                              */
            uint32_t            : 1;
      __IOM uint32_t USB2OTGRST : 1;            /*!< [27..27] USB2OTG block reset                                              */
            uint32_t            : 4;
    } AHB1RSTR_b;
  } ;
  
  union {
    __IOM uint32_t AHB2RSTR;                    /*!< (@ 0x00000084) RCC AHB2 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32_t CAMITFRST  : 1;            /*!< [0..0] CAMITF block reset                                                 */
            uint32_t            : 3;
      __IOM uint32_t CRYPTRST   : 1;            /*!< [4..4] Cryptography block reset                                           */
      __IOM uint32_t HASHRST    : 1;            /*!< [5..5] Hash block reset                                                   */
      __IOM uint32_t RNGRST     : 1;            /*!< [6..6] Random Number Generator block reset                                */
            uint32_t            : 2;
      __IOM uint32_t SDMMC2RST  : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay block reset                                */
            uint32_t            : 22;
    } AHB2RSTR_b;
  } ;
  
  union {
    __IOM uint32_t AHB4RSTR;                    /*!< (@ 0x00000088) RCC AHB4 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32_t GPIOARST   : 1;            /*!< [0..0] GPIO block reset                                                   */
      __IOM uint32_t GPIOBRST   : 1;            /*!< [1..1] GPIO block reset                                                   */
      __IOM uint32_t GPIOCRST   : 1;            /*!< [2..2] GPIO block reset                                                   */
      __IOM uint32_t GPIODRST   : 1;            /*!< [3..3] GPIO block reset                                                   */
      __IOM uint32_t GPIOERST   : 1;            /*!< [4..4] GPIO block reset                                                   */
      __IOM uint32_t GPIOFRST   : 1;            /*!< [5..5] GPIO block reset                                                   */
      __IOM uint32_t GPIOGRST   : 1;            /*!< [6..6] GPIO block reset                                                   */
      __IOM uint32_t GPIOHRST   : 1;            /*!< [7..7] GPIO block reset                                                   */
      __IOM uint32_t GPIOIRST   : 1;            /*!< [8..8] GPIO block reset                                                   */
      __IOM uint32_t GPIOJRST   : 1;            /*!< [9..9] GPIO block reset                                                   */
      __IOM uint32_t GPIOKRST   : 1;            /*!< [10..10] GPIO block reset                                                 */
            uint32_t            : 8;
      __IOM uint32_t CRCRST     : 1;            /*!< [19..19] CRC block reset                                                  */
            uint32_t            : 1;
      __IOM uint32_t BDMARST    : 1;            /*!< [21..21] BDMA block reset                                                 */
            uint32_t            : 2;
      __IOM uint32_t ADC3RST    : 1;            /*!< [24..24] ADC3 block reset                                                 */
      __IOM uint32_t HSEMRST    : 1;            /*!< [25..25] HSEM block reset                                                 */
            uint32_t            : 6;
    } AHB4RSTR_b;
  } ;
  
  union {
    __IOM uint32_t APB3RSTR;                    /*!< (@ 0x0000008C) RCC APB3 Peripheral Reset Register                         */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LTDCRST    : 1;            /*!< [3..3] LTDC block reset                                                   */
            uint32_t            : 28;
    } APB3RSTR_b;
  } ;
  
  union {
    __IOM uint32_t APB1LRSTR;                   /*!< (@ 0x00000090) RCC APB1 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32_t TIM2RST    : 1;            /*!< [0..0] TIM block reset                                                    */
      __IOM uint32_t TIM3RST    : 1;            /*!< [1..1] TIM block reset                                                    */
      __IOM uint32_t TIM4RST    : 1;            /*!< [2..2] TIM block reset                                                    */
      __IOM uint32_t TIM5RST    : 1;            /*!< [3..3] TIM block reset                                                    */
      __IOM uint32_t TIM6RST    : 1;            /*!< [4..4] TIM block reset                                                    */
      __IOM uint32_t TIM7RST    : 1;            /*!< [5..5] TIM block reset                                                    */
      __IOM uint32_t TIM12RST   : 1;            /*!< [6..6] TIM block reset                                                    */
      __IOM uint32_t TIM13RST   : 1;            /*!< [7..7] TIM block reset                                                    */
      __IOM uint32_t TIM14RST   : 1;            /*!< [8..8] TIM block reset                                                    */
      __IOM uint32_t LPTIM1RST  : 1;            /*!< [9..9] TIM block reset                                                    */
            uint32_t            : 4;
      __IOM uint32_t SPI2RST    : 1;            /*!< [14..14] SPI2 block reset                                                 */
      __IOM uint32_t SPI3RST    : 1;            /*!< [15..15] SPI3 block reset                                                 */
      __IOM uint32_t SPDIFRXRST : 1;            /*!< [16..16] SPDIFRX block reset                                              */
      __IOM uint32_t USART2RST  : 1;            /*!< [17..17] USART2 block reset                                               */
      __IOM uint32_t USART3RST  : 1;            /*!< [18..18] USART3 block reset                                               */
      __IOM uint32_t UART4RST   : 1;            /*!< [19..19] UART4 block reset                                                */
      __IOM uint32_t UART5RST   : 1;            /*!< [20..20] UART5 block reset                                                */
      __IOM uint32_t I2C1RST    : 1;            /*!< [21..21] I2C1 block reset                                                 */
      __IOM uint32_t I2C2RST    : 1;            /*!< [22..22] I2C2 block reset                                                 */
      __IOM uint32_t I2C3RST    : 1;            /*!< [23..23] I2C3 block reset                                                 */
            uint32_t            : 3;
      __IOM uint32_t HDMICECRST : 1;            /*!< [27..27] HDMI-CEC block reset                                             */
            uint32_t            : 1;
      __IOM uint32_t DAC12RST   : 1;            /*!< [29..29] DAC1 and 2 Blocks Reset                                          */
      __IOM uint32_t USART7RST  : 1;            /*!< [30..30] USART7 block reset                                               */
      __IOM uint32_t USART8RST  : 1;            /*!< [31..31] USART8 block reset                                               */
    } APB1LRSTR_b;
  } ;
  
  union {
    __IOM uint32_t APB1HRSTR;                   /*!< (@ 0x00000094) RCC APB1 Peripheral Reset Register                         */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CRSRST     : 1;            /*!< [1..1] Clock Recovery System reset                                        */
      __IOM uint32_t SWPRST     : 1;            /*!< [2..2] SWPMI block reset                                                  */
            uint32_t            : 1;
      __IOM uint32_t OPAMPRST   : 1;            /*!< [4..4] OPAMP block reset                                                  */
      __IOM uint32_t MDIOSRST   : 1;            /*!< [5..5] MDIOS block reset                                                  */
            uint32_t            : 2;
      __IOM uint32_t FDCANRST   : 1;            /*!< [8..8] FDCAN block reset                                                  */
            uint32_t            : 23;
    } APB1HRSTR_b;
  } ;
  
  union {
    __IOM uint32_t APB2RSTR;                    /*!< (@ 0x00000098) RCC APB2 Peripheral Reset Register                         */
    
    struct {
      __IOM uint32_t TIM1RST    : 1;            /*!< [0..0] TIM1 block reset                                                   */
      __IOM uint32_t TIM8RST    : 1;            /*!< [1..1] TIM8 block reset                                                   */
            uint32_t            : 2;
      __IOM uint32_t USART1RST  : 1;            /*!< [4..4] USART1 block reset                                                 */
      __IOM uint32_t USART6RST  : 1;            /*!< [5..5] USART6 block reset                                                 */
            uint32_t            : 6;
      __IOM uint32_t SPI1RST    : 1;            /*!< [12..12] SPI1 block reset                                                 */
      __IOM uint32_t SPI4RST    : 1;            /*!< [13..13] SPI4 block reset                                                 */
            uint32_t            : 2;
      __IOM uint32_t TIM15RST   : 1;            /*!< [16..16] TIM15 block reset                                                */
      __IOM uint32_t TIM16RST   : 1;            /*!< [17..17] TIM16 block reset                                                */
      __IOM uint32_t TIM17RST   : 1;            /*!< [18..18] TIM17 block reset                                                */
            uint32_t            : 1;
      __IOM uint32_t SPI5RST    : 1;            /*!< [20..20] SPI5 block reset                                                 */
            uint32_t            : 1;
      __IOM uint32_t SAI1RST    : 1;            /*!< [22..22] SAI1 block reset                                                 */
      __IOM uint32_t SAI2RST    : 1;            /*!< [23..23] SAI2 block reset                                                 */
      __IOM uint32_t SAI3RST    : 1;            /*!< [24..24] SAI3 block reset                                                 */
            uint32_t            : 3;
      __IOM uint32_t DFSDM1RST  : 1;            /*!< [28..28] DFSDM1 block reset                                               */
      __IOM uint32_t HRTIMRST   : 1;            /*!< [29..29] HRTIM block reset                                                */
            uint32_t            : 2;
    } APB2RSTR_b;
  } ;
  
  union {
    __IOM uint32_t APB4RSTR;                    /*!< (@ 0x0000009C) RCC APB4 Peripheral Reset Register                         */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SYSCFGRST  : 1;            /*!< [1..1] SYSCFG block reset                                                 */
            uint32_t            : 1;
      __IOM uint32_t LPUART1RST : 1;            /*!< [3..3] LPUART1 block reset                                                */
            uint32_t            : 1;
      __IOM uint32_t SPI6RST    : 1;            /*!< [5..5] SPI6 block reset                                                   */
            uint32_t            : 1;
      __IOM uint32_t I2C4RST    : 1;            /*!< [7..7] I2C4 block reset                                                   */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2RST  : 1;            /*!< [9..9] LPTIM2 block reset                                                 */
      __IOM uint32_t LPTIM3RST  : 1;            /*!< [10..10] LPTIM3 block reset                                               */
      __IOM uint32_t LPTIM4RST  : 1;            /*!< [11..11] LPTIM4 block reset                                               */
      __IOM uint32_t LPTIM5RST  : 1;            /*!< [12..12] LPTIM5 block reset                                               */
            uint32_t            : 1;
      __IOM uint32_t COMP12RST  : 1;            /*!< [14..14] COMP12 Blocks Reset                                              */
      __IOM uint32_t VREFRST    : 1;            /*!< [15..15] VREF block reset                                                 */
            uint32_t            : 5;
      __IOM uint32_t SAI4RST    : 1;            /*!< [21..21] SAI4 block reset                                                 */
            uint32_t            : 10;
    } APB4RSTR_b;
  } ;
  
  union {
    __IOM uint32_t GCR;                         /*!< (@ 0x000000A0) RCC Global Control Register                                */
    
    struct {
      __IOM uint32_t WW1RSC     : 1;            /*!< [0..0] WWDG1 reset scope control                                          */
            uint32_t            : 31;
    } GCR_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t D3AMR;                       /*!< (@ 0x000000A8) RCC D3 Autonomous mode Register                            */
    
    struct {
      __IOM uint32_t BDMAAMEN   : 1;            /*!< [0..0] BDMA and DMAMUX Autonomous mode enable                             */
            uint32_t            : 2;
      __IOM uint32_t LPUART1AMEN : 1;           /*!< [3..3] LPUART1 Autonomous mode enable                                     */
            uint32_t            : 1;
      __IOM uint32_t SPI6AMEN   : 1;            /*!< [5..5] SPI6 Autonomous mode enable                                        */
            uint32_t            : 1;
      __IOM uint32_t I2C4AMEN   : 1;            /*!< [7..7] I2C4 Autonomous mode enable                                        */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2AMEN : 1;            /*!< [9..9] LPTIM2 Autonomous mode enable                                      */
      __IOM uint32_t LPTIM3AMEN : 1;            /*!< [10..10] LPTIM3 Autonomous mode enable                                    */
      __IOM uint32_t LPTIM4AMEN : 1;            /*!< [11..11] LPTIM4 Autonomous mode enable                                    */
      __IOM uint32_t LPTIM5AMEN : 1;            /*!< [12..12] LPTIM5 Autonomous mode enable                                    */
            uint32_t            : 1;
      __IOM uint32_t COMP12AMEN : 1;            /*!< [14..14] COMP12 Autonomous mode enable                                    */
      __IOM uint32_t VREFAMEN   : 1;            /*!< [15..15] VREF Autonomous mode enable                                      */
      __IOM uint32_t RTCAMEN    : 1;            /*!< [16..16] RTC Autonomous mode enable                                       */
            uint32_t            : 2;
      __IOM uint32_t CRCAMEN    : 1;            /*!< [19..19] CRC Autonomous mode enable                                       */
            uint32_t            : 1;
      __IOM uint32_t SAI4AMEN   : 1;            /*!< [21..21] SAI4 Autonomous mode enable                                      */
            uint32_t            : 2;
      __IOM uint32_t ADC3AMEN   : 1;            /*!< [24..24] ADC3 Autonomous mode enable                                      */
            uint32_t            : 3;
      __IOM uint32_t BKPSRAMAMEN : 1;           /*!< [28..28] Backup RAM Autonomous mode enable                                */
      __IOM uint32_t SRAM4AMEN  : 1;            /*!< [29..29] SRAM4 Autonomous mode enable                                     */
            uint32_t            : 2;
    } D3AMR_b;
  } ;
  __IM  uint32_t  RESERVED8[9];
  
  union {
    __IOM uint32_t RSR;                         /*!< (@ 0x000000D0) RCC Reset Status Register                                  */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t RMVF       : 1;            /*!< [16..16] Remove reset flag                                                */
      __IOM uint32_t CPURSTF    : 1;            /*!< [17..17] CPU reset flag                                                   */
            uint32_t            : 1;
      __IOM uint32_t D1RSTF     : 1;            /*!< [19..19] D1 domain power switch reset flag                                */
      __IOM uint32_t D2RSTF     : 1;            /*!< [20..20] D2 domain power switch reset flag                                */
      __IOM uint32_t BORRSTF    : 1;            /*!< [21..21] BOR reset flag                                                   */
      __IOM uint32_t PINRSTF    : 1;            /*!< [22..22] Pin reset flag (NRST)                                            */
      __IOM uint32_t PORRSTF    : 1;            /*!< [23..23] POR/PDR reset flag                                               */
      __IOM uint32_t SFTRSTF    : 1;            /*!< [24..24] System reset from CPU reset flag                                 */
            uint32_t            : 1;
      __IOM uint32_t IWDG1RSTF  : 1;            /*!< [26..26] Independent Watchdog reset flag                                  */
            uint32_t            : 1;
      __IOM uint32_t WWDG1RSTF  : 1;            /*!< [28..28] Window Watchdog reset flag                                       */
            uint32_t            : 1;
      __IOM uint32_t LPWRRSTF   : 1;            /*!< [30..30] Reset due to illegal D1 DStandby or CPU CStop flag               */
            uint32_t            : 1;
    } RSR_b;
  } ;
  
  union {
    __IOM uint32_t AHB3ENR;                     /*!< (@ 0x000000D4) RCC AHB3 Clock Register                                    */
    
    struct {
      __IOM uint32_t MDMAEN     : 1;            /*!< [0..0] MDMA Peripheral Clock Enable                                       */
            uint32_t            : 3;
      __IOM uint32_t DMA2DEN    : 1;            /*!< [4..4] DMA2D Peripheral Clock Enable                                      */
      __IOM uint32_t JPGDECEN   : 1;            /*!< [5..5] JPGDEC Peripheral Clock Enable                                     */
            uint32_t            : 6;
      __IOM uint32_t FMCEN      : 1;            /*!< [12..12] FMC Peripheral Clocks Enable                                     */
            uint32_t            : 1;
      __IOM uint32_t QSPIEN     : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable                           */
            uint32_t            : 1;
      __IOM uint32_t SDMMC1EN   : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable                             */
            uint32_t            : 15;
    } AHB3ENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB1ENR;                     /*!< (@ 0x000000D8) RCC AHB1 Clock Register                                    */
    
    struct {
      __IOM uint32_t DMA1EN     : 1;            /*!< [0..0] DMA1 Clock Enable                                                  */
      __IOM uint32_t DMA2EN     : 1;            /*!< [1..1] DMA2 Clock Enable                                                  */
            uint32_t            : 3;
      __IOM uint32_t ADC12EN    : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable                                    */
            uint32_t            : 9;
      __IOM uint32_t ETH1MACEN  : 1;            /*!< [15..15] Ethernet MAC bus interface Clock Enable                          */
      __IOM uint32_t ETH1TXEN   : 1;            /*!< [16..16] Ethernet Transmission Clock Enable                               */
      __IOM uint32_t ETH1RXEN   : 1;            /*!< [17..17] Ethernet Reception Clock Enable                                  */
            uint32_t            : 7;
      __IOM uint32_t USB1OTGEN  : 1;            /*!< [25..25] USB1OTG Peripheral Clocks Enable                                 */
      __IOM uint32_t USB1ULPIEN : 1;            /*!< [26..26] USB_PHY1 Clocks Enable                                           */
      __IOM uint32_t USB2OTGEN  : 1;            /*!< [27..27] USB2OTG Peripheral Clocks Enable                                 */
      __IOM uint32_t USB2ULPIEN : 1;            /*!< [28..28] USB_PHY2 Clocks Enable                                           */
            uint32_t            : 3;
    } AHB1ENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB2ENR;                     /*!< (@ 0x000000DC) RCC AHB2 Clock Register                                    */
    
    struct {
      __IOM uint32_t CAMITFEN   : 1;            /*!< [0..0] CAMITF peripheral clock enable                                     */
            uint32_t            : 3;
      __IOM uint32_t CRYPTEN    : 1;            /*!< [4..4] CRYPT peripheral clock enable                                      */
      __IOM uint32_t HASHEN     : 1;            /*!< [5..5] HASH peripheral clock enable                                       */
      __IOM uint32_t RNGEN      : 1;            /*!< [6..6] RNG peripheral clocks enable                                       */
            uint32_t            : 2;
      __IOM uint32_t SDMMC2EN   : 1;            /*!< [9..9] SDMMC2 and SDMMC2 delay clock enable                               */
            uint32_t            : 19;
      __IOM uint32_t SRAM1EN    : 1;            /*!< [29..29] SRAM1 block enable                                               */
      __IOM uint32_t SRAM2EN    : 1;            /*!< [30..30] SRAM2 block enable                                               */
      __IOM uint32_t SRAM3EN    : 1;            /*!< [31..31] SRAM3 block enable                                               */
    } AHB2ENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB4ENR;                     /*!< (@ 0x000000E0) RCC AHB4 Clock Register                                    */
    
    struct {
      __IOM uint32_t GPIOAEN    : 1;            /*!< [0..0] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOBEN    : 1;            /*!< [1..1] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOCEN    : 1;            /*!< [2..2] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIODEN    : 1;            /*!< [3..3] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOEEN    : 1;            /*!< [4..4] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOFEN    : 1;            /*!< [5..5] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOGEN    : 1;            /*!< [6..6] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOHEN    : 1;            /*!< [7..7] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOIEN    : 1;            /*!< [8..8] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOJEN    : 1;            /*!< [9..9] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOKEN    : 1;            /*!< [10..10] 0GPIO peripheral clock enable                                    */
            uint32_t            : 8;
      __IOM uint32_t CRCEN      : 1;            /*!< [19..19] CRC peripheral clock enable                                      */
            uint32_t            : 1;
      __IOM uint32_t BDMAEN     : 1;            /*!< [21..21] BDMA and DMAMUX2 Clock Enable                                    */
            uint32_t            : 2;
      __IOM uint32_t ADC3EN     : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable                                    */
      __IOM uint32_t HSEMEN     : 1;            /*!< [25..25] HSEM peripheral clock enable                                     */
            uint32_t            : 2;
      __IOM uint32_t BKPRAMEN   : 1;            /*!< [28..28] Backup RAM Clock Enable                                          */
            uint32_t            : 3;
    } AHB4ENR_b;
  } ;
  
  union {
    __IOM uint32_t APB3ENR;                     /*!< (@ 0x000000E4) RCC APB3 Clock Register                                    */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LTDCEN     : 1;            /*!< [3..3] LTDC peripheral clock enable                                       */
            uint32_t            : 2;
      __IOM uint32_t WWDG1EN    : 1;            /*!< [6..6] WWDG1 Clock Enable                                                 */
            uint32_t            : 25;
    } APB3ENR_b;
  } ;
  
  union {
    __IOM uint32_t APB1LENR;                    /*!< (@ 0x000000E8) RCC APB1 Clock Register                                    */
    
    struct {
      __IOM uint32_t TIM2EN     : 1;            /*!< [0..0] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM3EN     : 1;            /*!< [1..1] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM4EN     : 1;            /*!< [2..2] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM5EN     : 1;            /*!< [3..3] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM6EN     : 1;            /*!< [4..4] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM7EN     : 1;            /*!< [5..5] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM12EN    : 1;            /*!< [6..6] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM13EN    : 1;            /*!< [7..7] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM14EN    : 1;            /*!< [8..8] TIM peripheral clock enable                                        */
      __IOM uint32_t LPTIM1EN   : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable                                    */
            uint32_t            : 4;
      __IOM uint32_t SPI2EN     : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPI3EN     : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPDIFRXEN  : 1;            /*!< [16..16] SPDIFRX Peripheral Clocks Enable                                 */
      __IOM uint32_t USART2EN   : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable                                  */
      __IOM uint32_t USART3EN   : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable                                  */
      __IOM uint32_t UART4EN    : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable                                   */
      __IOM uint32_t UART5EN    : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable                                   */
      __IOM uint32_t I2C1EN     : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable                                    */
      __IOM uint32_t I2C2EN     : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable                                    */
      __IOM uint32_t I2C3EN     : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable                                    */
            uint32_t            : 3;
      __IOM uint32_t HDMICECEN  : 1;            /*!< [27..27] HDMI-CEC peripheral clock enable                                 */
            uint32_t            : 1;
      __IOM uint32_t DAC12EN    : 1;            /*!< [29..29] DAC1&2 peripheral clock enable                                   */
      __IOM uint32_t USART7EN   : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable                                  */
      __IOM uint32_t USART8EN   : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable                                  */
    } APB1LENR_b;
  } ;
  
  union {
    __IOM uint32_t APB1HENR;                    /*!< (@ 0x000000EC) RCC APB1 Clock Register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CRSEN      : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable                      */
      __IOM uint32_t SWPEN      : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable                                     */
            uint32_t            : 1;
      __IOM uint32_t OPAMPEN    : 1;            /*!< [4..4] OPAMP peripheral clock enable                                      */
      __IOM uint32_t MDIOSEN    : 1;            /*!< [5..5] MDIOS peripheral clock enable                                      */
            uint32_t            : 2;
      __IOM uint32_t FDCANEN    : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable                                     */
            uint32_t            : 23;
    } APB1HENR_b;
  } ;
  
  union {
    __IOM uint32_t APB2ENR;                     /*!< (@ 0x000000F0) RCC APB2 Clock Register                                    */
    
    struct {
      __IOM uint32_t TIM1EN     : 1;            /*!< [0..0] TIM1 peripheral clock enable                                       */
      __IOM uint32_t TIM8EN     : 1;            /*!< [1..1] TIM8 peripheral clock enable                                       */
            uint32_t            : 2;
      __IOM uint32_t USART1EN   : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable                                    */
      __IOM uint32_t USART6EN   : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable                                    */
            uint32_t            : 6;
      __IOM uint32_t SPI1EN     : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPI4EN     : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable                                    */
            uint32_t            : 2;
      __IOM uint32_t TIM15EN    : 1;            /*!< [16..16] TIM15 peripheral clock enable                                    */
      __IOM uint32_t TIM16EN    : 1;            /*!< [17..17] TIM16 peripheral clock enable                                    */
      __IOM uint32_t TIM17EN    : 1;            /*!< [18..18] TIM17 peripheral clock enable                                    */
            uint32_t            : 1;
      __IOM uint32_t SPI5EN     : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable                                    */
            uint32_t            : 1;
      __IOM uint32_t SAI1EN     : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable                                    */
      __IOM uint32_t SAI2EN     : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable                                    */
      __IOM uint32_t SAI3EN     : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable                                    */
            uint32_t            : 3;
      __IOM uint32_t DFSDM1EN   : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable                                  */
      __IOM uint32_t HRTIMEN    : 1;            /*!< [29..29] HRTIM peripheral clock enable                                    */
            uint32_t            : 2;
    } APB2ENR_b;
  } ;
  
  union {
    __IOM uint32_t APB4ENR;                     /*!< (@ 0x000000F4) RCC APB4 Clock Register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SYSCFGEN   : 1;            /*!< [1..1] SYSCFG peripheral clock enable                                     */
            uint32_t            : 1;
      __IOM uint32_t LPUART1EN  : 1;            /*!< [3..3] LPUART1 Peripheral Clocks Enable                                   */
            uint32_t            : 1;
      __IOM uint32_t SPI6EN     : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable                                      */
            uint32_t            : 1;
      __IOM uint32_t I2C4EN     : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable                                      */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2EN   : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable                                    */
      __IOM uint32_t LPTIM3EN   : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable                                  */
      __IOM uint32_t LPTIM4EN   : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable                                  */
      __IOM uint32_t LPTIM5EN   : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable                                  */
            uint32_t            : 1;
      __IOM uint32_t COMP12EN   : 1;            /*!< [14..14] COMP1/2 peripheral clock enable                                  */
      __IOM uint32_t VREFEN     : 1;            /*!< [15..15] VREF peripheral clock enable                                     */
      __IOM uint32_t RTCAPBEN   : 1;            /*!< [16..16] RTC APB Clock Enable                                             */
            uint32_t            : 4;
      __IOM uint32_t SAI4EN     : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable                                    */
            uint32_t            : 10;
    } APB4ENR_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t AHB3LPENR;                   /*!< (@ 0x000000FC) RCC AHB3 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t MDMALPEN   : 1;            /*!< [0..0] MDMA Clock Enable During CSleep Mode                               */
            uint32_t            : 3;
      __IOM uint32_t DMA2DLPEN  : 1;            /*!< [4..4] DMA2D Clock Enable During CSleep Mode                              */
      __IOM uint32_t JPGDECLPEN : 1;            /*!< [5..5] JPGDEC Clock Enable During CSleep Mode                             */
            uint32_t            : 2;
      __IOM uint32_t FLITFLPEN  : 1;            /*!< [8..8] FLITF Clock Enable During CSleep Mode                              */
            uint32_t            : 3;
      __IOM uint32_t FMCLPEN    : 1;            /*!< [12..12] FMC Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 1;
      __IOM uint32_t QSPILPEN   : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32_t            : 1;
      __IOM uint32_t SDMMC1LPEN : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32_t            : 11;
      __IOM uint32_t D1DTCM1LPEN : 1;           /*!< [28..28] D1DTCM1 Block Clock Enable During CSleep mode                    */
      __IOM uint32_t DTCM2LPEN  : 1;            /*!< [29..29] D1 DTCM2 Block Clock Enable During CSleep mode                   */
      __IOM uint32_t ITCMLPEN   : 1;            /*!< [30..30] D1ITCM Block Clock Enable During CSleep mode                     */
      __IOM uint32_t AXISRAMLPEN : 1;           /*!< [31..31] AXISRAM Block Clock Enable During CSleep mode                    */
    } AHB3LPENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB1LPENR;                   /*!< (@ 0x00000100) RCC AHB1 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t DMA1LPEN   : 1;            /*!< [0..0] DMA1 Clock Enable During CSleep Mode                               */
      __IOM uint32_t DMA2LPEN   : 1;            /*!< [1..1] DMA2 Clock Enable During CSleep Mode                               */
            uint32_t            : 3;
      __IOM uint32_t ADC12LPEN  : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 9;
      __IOM uint32_t ETH1MACLPEN : 1;           /*!< [15..15] Ethernet MAC bus interface Clock Enable During CSleep
                                                     Mode                                                                      */
      __IOM uint32_t ETH1TXLPEN : 1;            /*!< [16..16] Ethernet Transmission Clock Enable During CSleep Mode            */
      __IOM uint32_t ETH1RXLPEN : 1;            /*!< [17..17] Ethernet Reception Clock Enable During CSleep Mode               */
            uint32_t            : 7;
      __IOM uint32_t USB1OTGLPEN : 1;           /*!< [25..25] USB1OTG peripheral clock enable during CSleep mode               */
      __IOM uint32_t USB1ULPILPEN : 1;          /*!< [26..26] USB_PHY1 clock enable during CSleep mode                         */
      __IOM uint32_t USB2OTGLPEN : 1;           /*!< [27..27] USB2OTG peripheral clock enable during CSleep mode               */
      __IOM uint32_t USB2ULPILPEN : 1;          /*!< [28..28] USB_PHY2 clocks enable during CSleep mode                        */
            uint32_t            : 3;
    } AHB1LPENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB2LPENR;                   /*!< (@ 0x00000104) RCC AHB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t CAMITFLPEN : 1;            /*!< [0..0] CAMITF peripheral clock enable during CSleep mode                  */
            uint32_t            : 3;
      __IOM uint32_t CRYPTLPEN  : 1;            /*!< [4..4] CRYPT peripheral clock enable during CSleep mode                   */
      __IOM uint32_t HASHLPEN   : 1;            /*!< [5..5] HASH peripheral clock enable during CSleep mode                    */
      __IOM uint32_t RNGLPEN    : 1;            /*!< [6..6] RNG peripheral clock enable during CSleep mode                     */
            uint32_t            : 2;
      __IOM uint32_t SDMMC2LPEN : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode            */
            uint32_t            : 19;
      __IOM uint32_t SRAM1LPEN  : 1;            /*!< [29..29] SRAM1 Clock Enable During CSleep Mode                            */
      __IOM uint32_t SRAM2LPEN  : 1;            /*!< [30..30] SRAM2 Clock Enable During CSleep Mode                            */
      __IOM uint32_t SRAM3LPEN  : 1;            /*!< [31..31] SRAM3 Clock Enable During CSleep Mode                            */
    } AHB2LPENR_b;
  } ;
  
  union {
    __IOM uint32_t AHB4LPENR;                   /*!< (@ 0x00000108) RCC AHB4 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t GPIOALPEN  : 1;            /*!< [0..0] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOBLPEN  : 1;            /*!< [1..1] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOCLPEN  : 1;            /*!< [2..2] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIODLPEN  : 1;            /*!< [3..3] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOELPEN  : 1;            /*!< [4..4] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOFLPEN  : 1;            /*!< [5..5] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOGLPEN  : 1;            /*!< [6..6] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOHLPEN  : 1;            /*!< [7..7] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOILPEN  : 1;            /*!< [8..8] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOJLPEN  : 1;            /*!< [9..9] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOKLPEN  : 1;            /*!< [10..10] GPIO peripheral clock enable during CSleep mode                  */
            uint32_t            : 8;
      __IOM uint32_t CRCLPEN    : 1;            /*!< [19..19] CRC peripheral clock enable during CSleep mode                   */
            uint32_t            : 1;
      __IOM uint32_t BDMALPEN   : 1;            /*!< [21..21] BDMA Clock Enable During CSleep Mode                             */
            uint32_t            : 2;
      __IOM uint32_t ADC3LPEN   : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t BKPRAMLPEN : 1;            /*!< [28..28] Backup RAM Clock Enable During CSleep Mode                       */
      __IOM uint32_t SRAM4LPEN  : 1;            /*!< [29..29] SRAM4 Clock Enable During CSleep Mode                            */
            uint32_t            : 2;
    } AHB4LPENR_b;
  } ;
  
  union {
    __IOM uint32_t APB3LPENR;                   /*!< (@ 0x0000010C) RCC APB3 Sleep Clock Register                              */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LTDCLPEN   : 1;            /*!< [3..3] LTDC peripheral clock enable during CSleep mode                    */
            uint32_t            : 2;
      __IOM uint32_t WWDG1LPEN  : 1;            /*!< [6..6] WWDG1 Clock Enable During CSleep Mode                              */
            uint32_t            : 25;
    } APB3LPENR_b;
  } ;
  
  union {
    __IOM uint32_t APB1LLPENR;                  /*!< (@ 0x00000110) RCC APB1 Low Sleep Clock Register                          */
    
    struct {
      __IOM uint32_t TIM2LPEN   : 1;            /*!< [0..0] TIM2 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM3LPEN   : 1;            /*!< [1..1] TIM3 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM4LPEN   : 1;            /*!< [2..2] TIM4 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM5LPEN   : 1;            /*!< [3..3] TIM5 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM6LPEN   : 1;            /*!< [4..4] TIM6 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM7LPEN   : 1;            /*!< [5..5] TIM7 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM12LPEN  : 1;            /*!< [6..6] TIM12 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t TIM13LPEN  : 1;            /*!< [7..7] TIM13 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t TIM14LPEN  : 1;            /*!< [8..8] TIM14 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t LPTIM1LPEN : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 4;
      __IOM uint32_t SPI2LPEN   : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPI3LPEN   : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPDIFRXLPEN : 1;           /*!< [16..16] SPDIFRX Peripheral Clocks Enable During CSleep Mode              */
      __IOM uint32_t USART2LPEN : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t USART3LPEN : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t UART4LPEN  : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32_t UART5LPEN  : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32_t I2C1LPEN   : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t I2C2LPEN   : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t I2C3LPEN   : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t HDMICECLPEN : 1;           /*!< [27..27] HDMI-CEC Peripheral Clocks Enable During CSleep Mode             */
            uint32_t            : 1;
      __IOM uint32_t DAC12LPEN  : 1;            /*!< [29..29] DAC1/2 peripheral clock enable during CSleep mode                */
      __IOM uint32_t USART7LPEN : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t USART8LPEN : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable During CSleep Mode               */
    } APB1LLPENR_b;
  } ;
  
  union {
    __IOM uint32_t APB1HLPENR;                  /*!< (@ 0x00000114) RCC APB1 High Sleep Clock Register                         */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CRSLPEN    : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable during
                                                     CSleep mode                                                               */
      __IOM uint32_t SWPLPEN    : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 1;
      __IOM uint32_t OPAMPLPEN  : 1;            /*!< [4..4] OPAMP peripheral clock enable during CSleep mode                   */
      __IOM uint32_t MDIOSLPEN  : 1;            /*!< [5..5] MDIOS peripheral clock enable during CSleep mode                   */
            uint32_t            : 2;
      __IOM uint32_t FDCANLPEN  : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 23;
    } APB1HLPENR_b;
  } ;
  
  union {
    __IOM uint32_t APB2LPENR;                   /*!< (@ 0x00000118) RCC APB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t TIM1LPEN   : 1;            /*!< [0..0] TIM1 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM8LPEN   : 1;            /*!< [1..1] TIM8 peripheral clock enable during CSleep mode                    */
            uint32_t            : 2;
      __IOM uint32_t USART1LPEN : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t USART6LPEN : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 6;
      __IOM uint32_t SPI1LPEN   : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPI4LPEN   : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 2;
      __IOM uint32_t TIM15LPEN  : 1;            /*!< [16..16] TIM15 peripheral clock enable during CSleep mode                 */
      __IOM uint32_t TIM16LPEN  : 1;            /*!< [17..17] TIM16 peripheral clock enable during CSleep mode                 */
      __IOM uint32_t TIM17LPEN  : 1;            /*!< [18..18] TIM17 peripheral clock enable during CSleep mode                 */
            uint32_t            : 1;
      __IOM uint32_t SPI5LPEN   : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 1;
      __IOM uint32_t SAI1LPEN   : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SAI2LPEN   : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SAI3LPEN   : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t DFSDM1LPEN : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t HRTIMLPEN  : 1;            /*!< [29..29] HRTIM peripheral clock enable during CSleep mode                 */
            uint32_t            : 2;
    } APB2LPENR_b;
  } ;
  
  union {
    __IOM uint32_t APB4LPENR;                   /*!< (@ 0x0000011C) RCC APB4 Sleep Clock Register                              */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SYSCFGLPEN : 1;            /*!< [1..1] SYSCFG peripheral clock enable during CSleep mode                  */
            uint32_t            : 1;
      __IOM uint32_t LPUART1LPEN : 1;           /*!< [3..3] LPUART1 Peripheral Clocks Enable During CSleep Mode                */
            uint32_t            : 1;
      __IOM uint32_t SPI6LPEN   : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable During CSleep Mode                   */
            uint32_t            : 1;
      __IOM uint32_t I2C4LPEN   : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable During CSleep Mode                   */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2LPEN : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t LPTIM3LPEN : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t LPTIM4LPEN : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t LPTIM5LPEN : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable During CSleep Mode               */
            uint32_t            : 1;
      __IOM uint32_t COMP12LPEN : 1;            /*!< [14..14] COMP1/2 peripheral clock enable during CSleep mode               */
      __IOM uint32_t VREFLPEN   : 1;            /*!< [15..15] VREF peripheral clock enable during CSleep mode                  */
      __IOM uint32_t RTCAPBLPEN : 1;            /*!< [16..16] RTC APB Clock Enable During CSleep Mode                          */
            uint32_t            : 4;
      __IOM uint32_t SAI4LPEN   : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 10;
    } APB4LPENR_b;
  } ;
  __IM  uint32_t  RESERVED10[4];
  
  union {
    __IOM uint32_t C1_RSR;                      /*!< (@ 0x00000130) RCC Reset Status Register                                  */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t RMVF       : 1;            /*!< [16..16] Remove reset flag                                                */
      __IOM uint32_t CPURSTF    : 1;            /*!< [17..17] CPU reset flag                                                   */
            uint32_t            : 1;
      __IOM uint32_t D1RSTF     : 1;            /*!< [19..19] D1 domain power switch reset flag                                */
      __IOM uint32_t D2RSTF     : 1;            /*!< [20..20] D2 domain power switch reset flag                                */
      __IOM uint32_t BORRSTF    : 1;            /*!< [21..21] BOR reset flag                                                   */
      __IOM uint32_t PINRSTF    : 1;            /*!< [22..22] Pin reset flag (NRST)                                            */
      __IOM uint32_t PORRSTF    : 1;            /*!< [23..23] POR/PDR reset flag                                               */
      __IOM uint32_t SFTRSTF    : 1;            /*!< [24..24] System reset from CPU reset flag                                 */
            uint32_t            : 1;
      __IOM uint32_t IWDG1RSTF  : 1;            /*!< [26..26] Independent Watchdog reset flag                                  */
            uint32_t            : 1;
      __IOM uint32_t WWDG1RSTF  : 1;            /*!< [28..28] Window Watchdog reset flag                                       */
            uint32_t            : 1;
      __IOM uint32_t LPWRRSTF   : 1;            /*!< [30..30] Reset due to illegal D1 DStandby or CPU CStop flag               */
            uint32_t            : 1;
    } C1_RSR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB3ENR;                  /*!< (@ 0x00000134) RCC AHB3 Clock Register                                    */
    
    struct {
      __IOM uint32_t MDMAEN     : 1;            /*!< [0..0] MDMA Peripheral Clock Enable                                       */
            uint32_t            : 3;
      __IOM uint32_t DMA2DEN    : 1;            /*!< [4..4] DMA2D Peripheral Clock Enable                                      */
      __IOM uint32_t JPGDECEN   : 1;            /*!< [5..5] JPGDEC Peripheral Clock Enable                                     */
            uint32_t            : 6;
      __IOM uint32_t FMCEN      : 1;            /*!< [12..12] FMC Peripheral Clocks Enable                                     */
            uint32_t            : 1;
      __IOM uint32_t QSPIEN     : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable                           */
            uint32_t            : 1;
      __IOM uint32_t SDMMC1EN   : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable                             */
            uint32_t            : 15;
    } C1_AHB3ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB1ENR;                  /*!< (@ 0x00000138) RCC AHB1 Clock Register                                    */
    
    struct {
      __IOM uint32_t DMA1EN     : 1;            /*!< [0..0] DMA1 Clock Enable                                                  */
      __IOM uint32_t DMA2EN     : 1;            /*!< [1..1] DMA2 Clock Enable                                                  */
            uint32_t            : 3;
      __IOM uint32_t ADC12EN    : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable                                    */
            uint32_t            : 9;
      __IOM uint32_t ETH1MACEN  : 1;            /*!< [15..15] Ethernet MAC bus interface Clock Enable                          */
      __IOM uint32_t ETH1TXEN   : 1;            /*!< [16..16] Ethernet Transmission Clock Enable                               */
      __IOM uint32_t ETH1RXEN   : 1;            /*!< [17..17] Ethernet Reception Clock Enable                                  */
            uint32_t            : 7;
      __IOM uint32_t USB1OTGEN  : 1;            /*!< [25..25] USB1OTG Peripheral Clocks Enable                                 */
      __IOM uint32_t USB1ULPIEN : 1;            /*!< [26..26] USB_PHY1 Clocks Enable                                           */
      __IOM uint32_t USB2OTGEN  : 1;            /*!< [27..27] USB2OTG Peripheral Clocks Enable                                 */
      __IOM uint32_t USB2ULPIEN : 1;            /*!< [28..28] USB_PHY2 Clocks Enable                                           */
            uint32_t            : 3;
    } C1_AHB1ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB2ENR;                  /*!< (@ 0x0000013C) RCC AHB2 Clock Register                                    */
    
    struct {
      __IOM uint32_t CAMITFEN   : 1;            /*!< [0..0] CAMITF peripheral clock enable                                     */
            uint32_t            : 3;
      __IOM uint32_t CRYPTEN    : 1;            /*!< [4..4] CRYPT peripheral clock enable                                      */
      __IOM uint32_t HASHEN     : 1;            /*!< [5..5] HASH peripheral clock enable                                       */
      __IOM uint32_t RNGEN      : 1;            /*!< [6..6] RNG peripheral clocks enable                                       */
            uint32_t            : 2;
      __IOM uint32_t SDMMC2EN   : 1;            /*!< [9..9] SDMMC2 and SDMMC2 delay clock enable                               */
            uint32_t            : 19;
      __IOM uint32_t SRAM1EN    : 1;            /*!< [29..29] SRAM1 block enable                                               */
      __IOM uint32_t SRAM2EN    : 1;            /*!< [30..30] SRAM2 block enable                                               */
      __IOM uint32_t SRAM3EN    : 1;            /*!< [31..31] SRAM3 block enable                                               */
    } C1_AHB2ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB4ENR;                  /*!< (@ 0x00000140) RCC AHB4 Clock Register                                    */
    
    struct {
      __IOM uint32_t GPIOAEN    : 1;            /*!< [0..0] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOBEN    : 1;            /*!< [1..1] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOCEN    : 1;            /*!< [2..2] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIODEN    : 1;            /*!< [3..3] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOEEN    : 1;            /*!< [4..4] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOFEN    : 1;            /*!< [5..5] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOGEN    : 1;            /*!< [6..6] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOHEN    : 1;            /*!< [7..7] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOIEN    : 1;            /*!< [8..8] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOJEN    : 1;            /*!< [9..9] 0GPIO peripheral clock enable                                      */
      __IOM uint32_t GPIOKEN    : 1;            /*!< [10..10] 0GPIO peripheral clock enable                                    */
            uint32_t            : 8;
      __IOM uint32_t CRCEN      : 1;            /*!< [19..19] CRC peripheral clock enable                                      */
            uint32_t            : 1;
      __IOM uint32_t BDMAEN     : 1;            /*!< [21..21] BDMA and DMAMUX2 Clock Enable                                    */
            uint32_t            : 2;
      __IOM uint32_t ADC3EN     : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable                                    */
      __IOM uint32_t HSEMEN     : 1;            /*!< [25..25] HSEM peripheral clock enable                                     */
            uint32_t            : 2;
      __IOM uint32_t BKPRAMEN   : 1;            /*!< [28..28] Backup RAM Clock Enable                                          */
            uint32_t            : 3;
    } C1_AHB4ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB3ENR;                  /*!< (@ 0x00000144) RCC APB3 Clock Register                                    */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LTDCEN     : 1;            /*!< [3..3] LTDC peripheral clock enable                                       */
            uint32_t            : 2;
      __IOM uint32_t WWDG1EN    : 1;            /*!< [6..6] WWDG1 Clock Enable                                                 */
            uint32_t            : 25;
    } C1_APB3ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB1LENR;                 /*!< (@ 0x00000148) RCC APB1 Clock Register                                    */
    
    struct {
      __IOM uint32_t TIM2EN     : 1;            /*!< [0..0] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM3EN     : 1;            /*!< [1..1] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM4EN     : 1;            /*!< [2..2] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM5EN     : 1;            /*!< [3..3] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM6EN     : 1;            /*!< [4..4] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM7EN     : 1;            /*!< [5..5] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM12EN    : 1;            /*!< [6..6] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM13EN    : 1;            /*!< [7..7] TIM peripheral clock enable                                        */
      __IOM uint32_t TIM14EN    : 1;            /*!< [8..8] TIM peripheral clock enable                                        */
      __IOM uint32_t LPTIM1EN   : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable                                    */
            uint32_t            : 4;
      __IOM uint32_t SPI2EN     : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPI3EN     : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPDIFRXEN  : 1;            /*!< [16..16] SPDIFRX Peripheral Clocks Enable                                 */
      __IOM uint32_t USART2EN   : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable                                  */
      __IOM uint32_t USART3EN   : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable                                  */
      __IOM uint32_t UART4EN    : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable                                   */
      __IOM uint32_t UART5EN    : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable                                   */
      __IOM uint32_t I2C1EN     : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable                                    */
      __IOM uint32_t I2C2EN     : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable                                    */
      __IOM uint32_t I2C3EN     : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable                                    */
            uint32_t            : 3;
      __IOM uint32_t HDMICECEN  : 1;            /*!< [27..27] HDMI-CEC peripheral clock enable                                 */
            uint32_t            : 1;
      __IOM uint32_t DAC12EN    : 1;            /*!< [29..29] DAC1&2 peripheral clock enable                                   */
      __IOM uint32_t USART7EN   : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable                                  */
      __IOM uint32_t USART8EN   : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable                                  */
    } C1_APB1LENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB1HENR;                 /*!< (@ 0x0000014C) RCC APB1 Clock Register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CRSEN      : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable                      */
      __IOM uint32_t SWPEN      : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable                                     */
            uint32_t            : 1;
      __IOM uint32_t OPAMPEN    : 1;            /*!< [4..4] OPAMP peripheral clock enable                                      */
      __IOM uint32_t MDIOSEN    : 1;            /*!< [5..5] MDIOS peripheral clock enable                                      */
            uint32_t            : 2;
      __IOM uint32_t FDCANEN    : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable                                     */
            uint32_t            : 23;
    } C1_APB1HENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB2ENR;                  /*!< (@ 0x00000150) RCC APB2 Clock Register                                    */
    
    struct {
      __IOM uint32_t TIM1EN     : 1;            /*!< [0..0] TIM1 peripheral clock enable                                       */
      __IOM uint32_t TIM8EN     : 1;            /*!< [1..1] TIM8 peripheral clock enable                                       */
            uint32_t            : 2;
      __IOM uint32_t USART1EN   : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable                                    */
      __IOM uint32_t USART6EN   : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable                                    */
            uint32_t            : 6;
      __IOM uint32_t SPI1EN     : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable                                    */
      __IOM uint32_t SPI4EN     : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable                                    */
            uint32_t            : 2;
      __IOM uint32_t TIM15EN    : 1;            /*!< [16..16] TIM15 peripheral clock enable                                    */
      __IOM uint32_t TIM16EN    : 1;            /*!< [17..17] TIM16 peripheral clock enable                                    */
      __IOM uint32_t TIM17EN    : 1;            /*!< [18..18] TIM17 peripheral clock enable                                    */
            uint32_t            : 1;
      __IOM uint32_t SPI5EN     : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable                                    */
            uint32_t            : 1;
      __IOM uint32_t SAI1EN     : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable                                    */
      __IOM uint32_t SAI2EN     : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable                                    */
      __IOM uint32_t SAI3EN     : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable                                    */
            uint32_t            : 3;
      __IOM uint32_t DFSDM1EN   : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable                                  */
      __IOM uint32_t HRTIMEN    : 1;            /*!< [29..29] HRTIM peripheral clock enable                                    */
            uint32_t            : 2;
    } C1_APB2ENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB4ENR;                  /*!< (@ 0x00000154) RCC APB4 Clock Register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SYSCFGEN   : 1;            /*!< [1..1] SYSCFG peripheral clock enable                                     */
            uint32_t            : 1;
      __IOM uint32_t LPUART1EN  : 1;            /*!< [3..3] LPUART1 Peripheral Clocks Enable                                   */
            uint32_t            : 1;
      __IOM uint32_t SPI6EN     : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable                                      */
            uint32_t            : 1;
      __IOM uint32_t I2C4EN     : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable                                      */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2EN   : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable                                    */
      __IOM uint32_t LPTIM3EN   : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable                                  */
      __IOM uint32_t LPTIM4EN   : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable                                  */
      __IOM uint32_t LPTIM5EN   : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable                                  */
            uint32_t            : 1;
      __IOM uint32_t COMP12EN   : 1;            /*!< [14..14] COMP1/2 peripheral clock enable                                  */
      __IOM uint32_t VREFEN     : 1;            /*!< [15..15] VREF peripheral clock enable                                     */
      __IOM uint32_t RTCAPBEN   : 1;            /*!< [16..16] RTC APB Clock Enable                                             */
            uint32_t            : 4;
      __IOM uint32_t SAI4EN     : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable                                    */
            uint32_t            : 10;
    } C1_APB4ENR_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t C1_AHB3LPENR;                /*!< (@ 0x0000015C) RCC AHB3 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t MDMALPEN   : 1;            /*!< [0..0] MDMA Clock Enable During CSleep Mode                               */
            uint32_t            : 3;
      __IOM uint32_t DMA2DLPEN  : 1;            /*!< [4..4] DMA2D Clock Enable During CSleep Mode                              */
      __IOM uint32_t JPGDECLPEN : 1;            /*!< [5..5] JPGDEC Clock Enable During CSleep Mode                             */
            uint32_t            : 2;
      __IOM uint32_t FLITFLPEN  : 1;            /*!< [8..8] FLITF Clock Enable During CSleep Mode                              */
            uint32_t            : 3;
      __IOM uint32_t FMCLPEN    : 1;            /*!< [12..12] FMC Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 1;
      __IOM uint32_t QSPILPEN   : 1;            /*!< [14..14] QUADSPI and QUADSPI Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32_t            : 1;
      __IOM uint32_t SDMMC1LPEN : 1;            /*!< [16..16] SDMMC1 and SDMMC1 Delay Clock Enable During CSleep
                                                     Mode                                                                      */
            uint32_t            : 11;
      __IOM uint32_t D1DTCM1LPEN : 1;           /*!< [28..28] D1DTCM1 Block Clock Enable During CSleep mode                    */
      __IOM uint32_t DTCM2LPEN  : 1;            /*!< [29..29] D1 DTCM2 Block Clock Enable During CSleep mode                   */
      __IOM uint32_t ITCMLPEN   : 1;            /*!< [30..30] D1ITCM Block Clock Enable During CSleep mode                     */
      __IOM uint32_t AXISRAMLPEN : 1;           /*!< [31..31] AXISRAM Block Clock Enable During CSleep mode                    */
    } C1_AHB3LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB1LPENR;                /*!< (@ 0x00000160) RCC AHB1 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t DMA1LPEN   : 1;            /*!< [0..0] DMA1 Clock Enable During CSleep Mode                               */
      __IOM uint32_t DMA2LPEN   : 1;            /*!< [1..1] DMA2 Clock Enable During CSleep Mode                               */
            uint32_t            : 3;
      __IOM uint32_t ADC12LPEN  : 1;            /*!< [5..5] ADC1/2 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 9;
      __IOM uint32_t ETH1MACLPEN : 1;           /*!< [15..15] Ethernet MAC bus interface Clock Enable During CSleep
                                                     Mode                                                                      */
      __IOM uint32_t ETH1TXLPEN : 1;            /*!< [16..16] Ethernet Transmission Clock Enable During CSleep Mode            */
      __IOM uint32_t ETH1RXLPEN : 1;            /*!< [17..17] Ethernet Reception Clock Enable During CSleep Mode               */
            uint32_t            : 7;
      __IOM uint32_t USB1OTGLPEN : 1;           /*!< [25..25] USB1OTG peripheral clock enable during CSleep mode               */
      __IOM uint32_t USB1ULPILPEN : 1;          /*!< [26..26] USB_PHY1 clock enable during CSleep mode                         */
      __IOM uint32_t USB2OTGLPEN : 1;           /*!< [27..27] USB2OTG peripheral clock enable during CSleep mode               */
      __IOM uint32_t USB2ULPILPEN : 1;          /*!< [28..28] USB_PHY2 clocks enable during CSleep mode                        */
            uint32_t            : 3;
    } C1_AHB1LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB2LPENR;                /*!< (@ 0x00000164) RCC AHB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t CAMITFLPEN : 1;            /*!< [0..0] CAMITF peripheral clock enable during CSleep mode                  */
            uint32_t            : 3;
      __IOM uint32_t CRYPTLPEN  : 1;            /*!< [4..4] CRYPT peripheral clock enable during CSleep mode                   */
      __IOM uint32_t HASHLPEN   : 1;            /*!< [5..5] HASH peripheral clock enable during CSleep mode                    */
      __IOM uint32_t RNGLPEN    : 1;            /*!< [6..6] RNG peripheral clock enable during CSleep mode                     */
            uint32_t            : 2;
      __IOM uint32_t SDMMC2LPEN : 1;            /*!< [9..9] SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode            */
            uint32_t            : 19;
      __IOM uint32_t SRAM1LPEN  : 1;            /*!< [29..29] SRAM1 Clock Enable During CSleep Mode                            */
      __IOM uint32_t SRAM2LPEN  : 1;            /*!< [30..30] SRAM2 Clock Enable During CSleep Mode                            */
      __IOM uint32_t SRAM3LPEN  : 1;            /*!< [31..31] SRAM3 Clock Enable During CSleep Mode                            */
    } C1_AHB2LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_AHB4LPENR;                /*!< (@ 0x00000168) RCC AHB4 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t GPIOALPEN  : 1;            /*!< [0..0] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOBLPEN  : 1;            /*!< [1..1] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOCLPEN  : 1;            /*!< [2..2] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIODLPEN  : 1;            /*!< [3..3] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOELPEN  : 1;            /*!< [4..4] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOFLPEN  : 1;            /*!< [5..5] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOGLPEN  : 1;            /*!< [6..6] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOHLPEN  : 1;            /*!< [7..7] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOILPEN  : 1;            /*!< [8..8] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOJLPEN  : 1;            /*!< [9..9] GPIO peripheral clock enable during CSleep mode                    */
      __IOM uint32_t GPIOKLPEN  : 1;            /*!< [10..10] GPIO peripheral clock enable during CSleep mode                  */
            uint32_t            : 8;
      __IOM uint32_t CRCLPEN    : 1;            /*!< [19..19] CRC peripheral clock enable during CSleep mode                   */
            uint32_t            : 1;
      __IOM uint32_t BDMALPEN   : 1;            /*!< [21..21] BDMA Clock Enable During CSleep Mode                             */
            uint32_t            : 2;
      __IOM uint32_t ADC3LPEN   : 1;            /*!< [24..24] ADC3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t BKPRAMLPEN : 1;            /*!< [28..28] Backup RAM Clock Enable During CSleep Mode                       */
      __IOM uint32_t SRAM4LPEN  : 1;            /*!< [29..29] SRAM4 Clock Enable During CSleep Mode                            */
            uint32_t            : 2;
    } C1_AHB4LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB3LPENR;                /*!< (@ 0x0000016C) RCC APB3 Sleep Clock Register                              */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LTDCLPEN   : 1;            /*!< [3..3] LTDC peripheral clock enable during CSleep mode                    */
            uint32_t            : 2;
      __IOM uint32_t WWDG1LPEN  : 1;            /*!< [6..6] WWDG1 Clock Enable During CSleep Mode                              */
            uint32_t            : 25;
    } C1_APB3LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB1LLPENR;               /*!< (@ 0x00000170) RCC APB1 Low Sleep Clock Register                          */
    
    struct {
      __IOM uint32_t TIM2LPEN   : 1;            /*!< [0..0] TIM2 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM3LPEN   : 1;            /*!< [1..1] TIM3 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM4LPEN   : 1;            /*!< [2..2] TIM4 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM5LPEN   : 1;            /*!< [3..3] TIM5 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM6LPEN   : 1;            /*!< [4..4] TIM6 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM7LPEN   : 1;            /*!< [5..5] TIM7 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM12LPEN  : 1;            /*!< [6..6] TIM12 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t TIM13LPEN  : 1;            /*!< [7..7] TIM13 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t TIM14LPEN  : 1;            /*!< [8..8] TIM14 peripheral clock enable during CSleep mode                   */
      __IOM uint32_t LPTIM1LPEN : 1;            /*!< [9..9] LPTIM1 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 4;
      __IOM uint32_t SPI2LPEN   : 1;            /*!< [14..14] SPI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPI3LPEN   : 1;            /*!< [15..15] SPI3 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPDIFRXLPEN : 1;           /*!< [16..16] SPDIFRX Peripheral Clocks Enable During CSleep Mode              */
      __IOM uint32_t USART2LPEN : 1;            /*!< [17..17] USART2 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t USART3LPEN : 1;            /*!< [18..18] USART3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t UART4LPEN  : 1;            /*!< [19..19] UART4 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32_t UART5LPEN  : 1;            /*!< [20..20] UART5 Peripheral Clocks Enable During CSleep Mode                */
      __IOM uint32_t I2C1LPEN   : 1;            /*!< [21..21] I2C1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t I2C2LPEN   : 1;            /*!< [22..22] I2C2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t I2C3LPEN   : 1;            /*!< [23..23] I2C3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t HDMICECLPEN : 1;           /*!< [27..27] HDMI-CEC Peripheral Clocks Enable During CSleep Mode             */
            uint32_t            : 1;
      __IOM uint32_t DAC12LPEN  : 1;            /*!< [29..29] DAC1/2 peripheral clock enable during CSleep mode                */
      __IOM uint32_t USART7LPEN : 1;            /*!< [30..30] USART7 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t USART8LPEN : 1;            /*!< [31..31] USART8 Peripheral Clocks Enable During CSleep Mode               */
    } C1_APB1LLPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB1HLPENR;               /*!< (@ 0x00000174) RCC APB1 High Sleep Clock Register                         */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CRSLPEN    : 1;            /*!< [1..1] Clock Recovery System peripheral clock enable during
                                                     CSleep mode                                                               */
      __IOM uint32_t SWPLPEN    : 1;            /*!< [2..2] SWPMI Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 1;
      __IOM uint32_t OPAMPLPEN  : 1;            /*!< [4..4] OPAMP peripheral clock enable during CSleep mode                   */
      __IOM uint32_t MDIOSLPEN  : 1;            /*!< [5..5] MDIOS peripheral clock enable during CSleep mode                   */
            uint32_t            : 2;
      __IOM uint32_t FDCANLPEN  : 1;            /*!< [8..8] FDCAN Peripheral Clocks Enable During CSleep Mode                  */
            uint32_t            : 23;
    } C1_APB1HLPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB2LPENR;                /*!< (@ 0x00000178) RCC APB2 Sleep Clock Register                              */
    
    struct {
      __IOM uint32_t TIM1LPEN   : 1;            /*!< [0..0] TIM1 peripheral clock enable during CSleep mode                    */
      __IOM uint32_t TIM8LPEN   : 1;            /*!< [1..1] TIM8 peripheral clock enable during CSleep mode                    */
            uint32_t            : 2;
      __IOM uint32_t USART1LPEN : 1;            /*!< [4..4] USART1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t USART6LPEN : 1;            /*!< [5..5] USART6 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 6;
      __IOM uint32_t SPI1LPEN   : 1;            /*!< [12..12] SPI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SPI4LPEN   : 1;            /*!< [13..13] SPI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 2;
      __IOM uint32_t TIM15LPEN  : 1;            /*!< [16..16] TIM15 peripheral clock enable during CSleep mode                 */
      __IOM uint32_t TIM16LPEN  : 1;            /*!< [17..17] TIM16 peripheral clock enable during CSleep mode                 */
      __IOM uint32_t TIM17LPEN  : 1;            /*!< [18..18] TIM17 peripheral clock enable during CSleep mode                 */
            uint32_t            : 1;
      __IOM uint32_t SPI5LPEN   : 1;            /*!< [20..20] SPI5 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 1;
      __IOM uint32_t SAI1LPEN   : 1;            /*!< [22..22] SAI1 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SAI2LPEN   : 1;            /*!< [23..23] SAI2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t SAI3LPEN   : 1;            /*!< [24..24] SAI3 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 3;
      __IOM uint32_t DFSDM1LPEN : 1;            /*!< [28..28] DFSDM1 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t HRTIMLPEN  : 1;            /*!< [29..29] HRTIM peripheral clock enable during CSleep mode                 */
            uint32_t            : 2;
    } C1_APB2LPENR_b;
  } ;
  
  union {
    __IOM uint32_t C1_APB4LPENR;                /*!< (@ 0x0000017C) RCC APB4 Sleep Clock Register                              */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SYSCFGLPEN : 1;            /*!< [1..1] SYSCFG peripheral clock enable during CSleep mode                  */
            uint32_t            : 1;
      __IOM uint32_t LPUART1LPEN : 1;           /*!< [3..3] LPUART1 Peripheral Clocks Enable During CSleep Mode                */
            uint32_t            : 1;
      __IOM uint32_t SPI6LPEN   : 1;            /*!< [5..5] SPI6 Peripheral Clocks Enable During CSleep Mode                   */
            uint32_t            : 1;
      __IOM uint32_t I2C4LPEN   : 1;            /*!< [7..7] I2C4 Peripheral Clocks Enable During CSleep Mode                   */
            uint32_t            : 1;
      __IOM uint32_t LPTIM2LPEN : 1;            /*!< [9..9] LPTIM2 Peripheral Clocks Enable During CSleep Mode                 */
      __IOM uint32_t LPTIM3LPEN : 1;            /*!< [10..10] LPTIM3 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t LPTIM4LPEN : 1;            /*!< [11..11] LPTIM4 Peripheral Clocks Enable During CSleep Mode               */
      __IOM uint32_t LPTIM5LPEN : 1;            /*!< [12..12] LPTIM5 Peripheral Clocks Enable During CSleep Mode               */
            uint32_t            : 1;
      __IOM uint32_t COMP12LPEN : 1;            /*!< [14..14] COMP1/2 peripheral clock enable during CSleep mode               */
      __IOM uint32_t VREFLPEN   : 1;            /*!< [15..15] VREF peripheral clock enable during CSleep mode                  */
      __IOM uint32_t RTCAPBLPEN : 1;            /*!< [16..16] RTC APB Clock Enable During CSleep Mode                          */
            uint32_t            : 4;
      __IOM uint32_t SAI4LPEN   : 1;            /*!< [21..21] SAI4 Peripheral Clocks Enable During CSleep Mode                 */
            uint32_t            : 10;
    } C1_APB4LPENR_b;
  } ;
} RCC_Type;                                     /*!< Size = 384 (0x180)                                                        */



/* =========================================================================================================================== */
/* ================                                          LPTIM1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low power timer (LPTIM1)
  */

typedef struct {                                /*!< (@ 0x40002400) LPTIM1 Structure                                           */
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x00000000) Interrupt and Status Register                              */
    
    struct {
      __IM  uint32_t CMPM       : 1;            /*!< [0..0] Compare match                                                      */
      __IM  uint32_t ARRM       : 1;            /*!< [1..1] Autoreload match                                                   */
      __IM  uint32_t EXTTRIG    : 1;            /*!< [2..2] External trigger edge event                                        */
      __IM  uint32_t CMPOK      : 1;            /*!< [3..3] Compare register update OK                                         */
      __IM  uint32_t ARROK      : 1;            /*!< [4..4] Autoreload register update OK                                      */
      __IM  uint32_t UP         : 1;            /*!< [5..5] Counter direction change down to up                                */
      __IM  uint32_t DOWN       : 1;            /*!< [6..6] Counter direction change up to down                                */
            uint32_t            : 25;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000004) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32_t CMPMCF     : 1;            /*!< [0..0] compare match Clear Flag                                           */
      __OM  uint32_t ARRMCF     : 1;            /*!< [1..1] Autoreload match Clear Flag                                        */
      __OM  uint32_t EXTTRIGCF  : 1;            /*!< [2..2] External trigger valid edge Clear Flag                             */
      __OM  uint32_t CMPOKCF    : 1;            /*!< [3..3] Compare register update OK Clear Flag                              */
      __OM  uint32_t ARROKCF    : 1;            /*!< [4..4] Autoreload register update OK Clear Flag                           */
      __OM  uint32_t UPCF       : 1;            /*!< [5..5] Direction change to UP Clear Flag                                  */
      __OM  uint32_t DOWNCF     : 1;            /*!< [6..6] Direction change to down Clear Flag                                */
            uint32_t            : 25;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000008) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t CMPMIE     : 1;            /*!< [0..0] Compare match Interrupt Enable                                     */
      __IOM uint32_t ARRMIE     : 1;            /*!< [1..1] Autoreload match Interrupt Enable                                  */
      __IOM uint32_t EXTTRIGIE  : 1;            /*!< [2..2] External trigger valid edge Interrupt Enable                       */
      __IOM uint32_t CMPOKIE    : 1;            /*!< [3..3] Compare register update OK Interrupt Enable                        */
      __IOM uint32_t ARROKIE    : 1;            /*!< [4..4] Autoreload register update OK Interrupt Enable                     */
      __IOM uint32_t UPIE       : 1;            /*!< [5..5] Direction change to UP Interrupt Enable                            */
      __IOM uint32_t DOWNIE     : 1;            /*!< [6..6] Direction change to down Interrupt Enable                          */
            uint32_t            : 25;
    } IER_b;
  } ;
  
  union {
    __IOM uint32_t CFGR;                        /*!< (@ 0x0000000C) Configuration Register                                     */
    
    struct {
      __IOM uint32_t CKSEL      : 1;            /*!< [0..0] Clock selector                                                     */
      __IOM uint32_t CKPOL      : 2;            /*!< [2..1] Clock Polarity                                                     */
      __IOM uint32_t CKFLT      : 2;            /*!< [4..3] Configurable digital filter for external clock                     */
            uint32_t            : 1;
      __IOM uint32_t TRGFLT     : 2;            /*!< [7..6] Configurable digital filter for trigger                            */
            uint32_t            : 1;
      __IOM uint32_t PRESC      : 3;            /*!< [11..9] Clock prescaler                                                   */
            uint32_t            : 1;
      __IOM uint32_t TRIGSEL    : 3;            /*!< [15..13] Trigger selector                                                 */
            uint32_t            : 1;
      __IOM uint32_t TRIGEN     : 2;            /*!< [18..17] Trigger enable and polarity                                      */
      __IOM uint32_t TIMOUT     : 1;            /*!< [19..19] Timeout enable                                                   */
      __IOM uint32_t WAVE       : 1;            /*!< [20..20] Waveform shape                                                   */
      __IOM uint32_t WAVPOL     : 1;            /*!< [21..21] Waveform shape polarity                                          */
      __IOM uint32_t PRELOAD    : 1;            /*!< [22..22] Registers update mode                                            */
      __IOM uint32_t COUNTMODE  : 1;            /*!< [23..23] counter mode enabled                                             */
      __IOM uint32_t ENC        : 1;            /*!< [24..24] Encoder mode enable                                              */
            uint32_t            : 7;
    } CFGR_b;
  } ;
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000010) Control Register                                           */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] LPTIM Enable                                                       */
      __IOM uint32_t SNGSTRT    : 1;            /*!< [1..1] LPTIM start in single mode                                         */
      __IOM uint32_t CNTSTRT    : 1;            /*!< [2..2] Timer start in continuous mode                                     */
      __IOM uint32_t COUNTRST   : 1;            /*!< [3..3] Counter reset                                                      */
      __IOM uint32_t RSTARE     : 1;            /*!< [4..4] Reset after read enable                                            */
            uint32_t            : 27;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t CMP;                         /*!< (@ 0x00000014) Compare Register                                           */
    
    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Compare value                                                     */
            uint32_t            : 16;
    } CMP_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x00000018) Autoreload Register                                        */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IM  uint32_t CNT;                         /*!< (@ 0x0000001C) Counter Register                                           */
    
    struct {
      __IM  uint32_t CNT        : 16;           /*!< [15..0] Counter value                                                     */
            uint32_t            : 16;
    } CNT_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t LPTIM_CFGR2;                 /*!< (@ 0x00000024) LPTIM configuration register 2                             */
    
    struct {
      __IOM uint32_t IN1SEL     : 2;            /*!< [1..0] LPTIM Input 1 selection                                            */
            uint32_t            : 2;
      __IOM uint32_t IN2SEL     : 2;            /*!< [5..4] LPTIM Input 2 selection                                            */
            uint32_t            : 26;
    } LPTIM_CFGR2_b;
  } ;
} LPTIM1_Type;                                  /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPTIM3                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low power timer (LPTIM3)
  */

typedef struct {                                /*!< (@ 0x58002800) LPTIM3 Structure                                           */
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x00000000) Interrupt and Status Register                              */
    
    struct {
      __IM  uint32_t CMPM       : 1;            /*!< [0..0] Compare match                                                      */
      __IM  uint32_t ARRM       : 1;            /*!< [1..1] Autoreload match                                                   */
      __IM  uint32_t EXTTRIG    : 1;            /*!< [2..2] External trigger edge event                                        */
      __IM  uint32_t CMPOK      : 1;            /*!< [3..3] Compare register update OK                                         */
      __IM  uint32_t ARROK      : 1;            /*!< [4..4] Autoreload register update OK                                      */
      __IM  uint32_t UP         : 1;            /*!< [5..5] Counter direction change down to up                                */
      __IM  uint32_t DOWN       : 1;            /*!< [6..6] Counter direction change up to down                                */
            uint32_t            : 25;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000004) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32_t CMPMCF     : 1;            /*!< [0..0] compare match Clear Flag                                           */
      __OM  uint32_t ARRMCF     : 1;            /*!< [1..1] Autoreload match Clear Flag                                        */
      __OM  uint32_t EXTTRIGCF  : 1;            /*!< [2..2] External trigger valid edge Clear Flag                             */
      __OM  uint32_t CMPOKCF    : 1;            /*!< [3..3] Compare register update OK Clear Flag                              */
      __OM  uint32_t ARROKCF    : 1;            /*!< [4..4] Autoreload register update OK Clear Flag                           */
      __OM  uint32_t UPCF       : 1;            /*!< [5..5] Direction change to UP Clear Flag                                  */
      __OM  uint32_t DOWNCF     : 1;            /*!< [6..6] Direction change to down Clear Flag                                */
            uint32_t            : 25;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000008) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t CMPMIE     : 1;            /*!< [0..0] Compare match Interrupt Enable                                     */
      __IOM uint32_t ARRMIE     : 1;            /*!< [1..1] Autoreload match Interrupt Enable                                  */
      __IOM uint32_t EXTTRIGIE  : 1;            /*!< [2..2] External trigger valid edge Interrupt Enable                       */
      __IOM uint32_t CMPOKIE    : 1;            /*!< [3..3] Compare register update OK Interrupt Enable                        */
      __IOM uint32_t ARROKIE    : 1;            /*!< [4..4] Autoreload register update OK Interrupt Enable                     */
      __IOM uint32_t UPIE       : 1;            /*!< [5..5] Direction change to UP Interrupt Enable                            */
      __IOM uint32_t DOWNIE     : 1;            /*!< [6..6] Direction change to down Interrupt Enable                          */
            uint32_t            : 25;
    } IER_b;
  } ;
  
  union {
    __IOM uint32_t CFGR;                        /*!< (@ 0x0000000C) Configuration Register                                     */
    
    struct {
      __IOM uint32_t CKSEL      : 1;            /*!< [0..0] Clock selector                                                     */
      __IOM uint32_t CKPOL      : 2;            /*!< [2..1] Clock Polarity                                                     */
      __IOM uint32_t CKFLT      : 2;            /*!< [4..3] Configurable digital filter for external clock                     */
            uint32_t            : 1;
      __IOM uint32_t TRGFLT     : 2;            /*!< [7..6] Configurable digital filter for trigger                            */
            uint32_t            : 1;
      __IOM uint32_t PRESC      : 3;            /*!< [11..9] Clock prescaler                                                   */
            uint32_t            : 1;
      __IOM uint32_t TRIGSEL    : 3;            /*!< [15..13] Trigger selector                                                 */
            uint32_t            : 1;
      __IOM uint32_t TRIGEN     : 2;            /*!< [18..17] Trigger enable and polarity                                      */
      __IOM uint32_t TIMOUT     : 1;            /*!< [19..19] Timeout enable                                                   */
      __IOM uint32_t WAVE       : 1;            /*!< [20..20] Waveform shape                                                   */
      __IOM uint32_t WAVPOL     : 1;            /*!< [21..21] Waveform shape polarity                                          */
      __IOM uint32_t PRELOAD    : 1;            /*!< [22..22] Registers update mode                                            */
      __IOM uint32_t COUNTMODE  : 1;            /*!< [23..23] counter mode enabled                                             */
      __IOM uint32_t ENC        : 1;            /*!< [24..24] Encoder mode enable                                              */
            uint32_t            : 7;
    } CFGR_b;
  } ;
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000010) Control Register                                           */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] LPTIM Enable                                                       */
      __IOM uint32_t SNGSTRT    : 1;            /*!< [1..1] LPTIM start in single mode                                         */
      __IOM uint32_t CNTSTRT    : 1;            /*!< [2..2] Timer start in continuous mode                                     */
      __IOM uint32_t COUNTRST   : 1;            /*!< [3..3] Counter reset                                                      */
      __IOM uint32_t RSTARE     : 1;            /*!< [4..4] Reset after read enable                                            */
            uint32_t            : 27;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t CMP;                         /*!< (@ 0x00000014) Compare Register                                           */
    
    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Compare value                                                     */
            uint32_t            : 16;
    } CMP_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x00000018) Autoreload Register                                        */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IM  uint32_t CNT;                         /*!< (@ 0x0000001C) Counter Register                                           */
    
    struct {
      __IM  uint32_t CNT        : 16;           /*!< [15..0] Counter value                                                     */
            uint32_t            : 16;
    } CNT_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t LPTIM_CFGR2;                 /*!< (@ 0x00000024) LPTIM configuration register 2                             */
    
    struct {
      __IOM uint32_t IN1SEL     : 2;            /*!< [1..0] LPTIM Input 1 selection                                            */
            uint32_t            : 30;
    } LPTIM_CFGR2_b;
  } ;
} LPTIM3_Type;                                  /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPUART1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief LPUART1 (LPUART1)
  */

typedef struct {                                /*!< (@ 0x58000C00) LPUART1 Structure                                          */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) Control register 1                                         */
    
    struct {
      __IOM uint32_t UE         : 1;            /*!< [0..0] USART enable                                                       */
      __IOM uint32_t UESM       : 1;            /*!< [1..1] USART enable in Stop mode                                          */
      __IOM uint32_t RE         : 1;            /*!< [2..2] Receiver enable                                                    */
      __IOM uint32_t TE         : 1;            /*!< [3..3] Transmitter enable                                                 */
      __IOM uint32_t IDLEIE     : 1;            /*!< [4..4] IDLE interrupt enable                                              */
      __IOM uint32_t RXNEIE     : 1;            /*!< [5..5] RXNE interrupt enable                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [6..6] Transmission complete interrupt enable                             */
      __IOM uint32_t TXEIE      : 1;            /*!< [7..7] interrupt enable                                                   */
      __IOM uint32_t PEIE       : 1;            /*!< [8..8] PE interrupt enable                                                */
      __IOM uint32_t PS         : 1;            /*!< [9..9] Parity selection                                                   */
      __IOM uint32_t PCE        : 1;            /*!< [10..10] Parity control enable                                            */
      __IOM uint32_t WAKE       : 1;            /*!< [11..11] Receiver wakeup method                                           */
      __IOM uint32_t M0         : 1;            /*!< [12..12] Word length                                                      */
      __IOM uint32_t MME        : 1;            /*!< [13..13] Mute mode enable                                                 */
      __IOM uint32_t CMIE       : 1;            /*!< [14..14] Character match interrupt enable                                 */
            uint32_t            : 1;
      __IOM uint32_t DEDT       : 5;            /*!< [20..16] Driver Enable deassertion time                                   */
      __IOM uint32_t DEAT       : 5;            /*!< [25..21] Driver Enable assertion time                                     */
            uint32_t            : 2;
      __IOM uint32_t M1         : 1;            /*!< [28..28] Word length                                                      */
      __IOM uint32_t FIFOEN     : 1;            /*!< [29..29] FIFO mode enable                                                 */
      __IOM uint32_t TXFEIE     : 1;            /*!< [30..30] TXFIFO empty interrupt enable                                    */
      __IOM uint32_t RXFFIE     : 1;            /*!< [31..31] RXFIFO Full interrupt enable                                     */
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) Control register 2                                         */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t ADDM7      : 1;            /*!< [4..4] 7-bit Address Detection/4-bit Address Detection                    */
            uint32_t            : 7;
      __IOM uint32_t STOP       : 2;            /*!< [13..12] STOP bits                                                        */
            uint32_t            : 1;
      __IOM uint32_t SWAP       : 1;            /*!< [15..15] Swap TX/RX pins                                                  */
      __IOM uint32_t RXINV      : 1;            /*!< [16..16] RX pin active level inversion                                    */
      __IOM uint32_t TXINV      : 1;            /*!< [17..17] TX pin active level inversion                                    */
      __IOM uint32_t DATAINV    : 1;            /*!< [18..18] Binary data inversion                                            */
      __IOM uint32_t MSBFIRST   : 1;            /*!< [19..19] Most significant bit first                                       */
            uint32_t            : 4;
      __IOM uint32_t ADD        : 8;            /*!< [31..24] Address of the USART node                                        */
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t CR3;                         /*!< (@ 0x00000008) Control register 3                                         */
    
    struct {
      __IOM uint32_t EIE        : 1;            /*!< [0..0] Error interrupt enable                                             */
            uint32_t            : 2;
      __IOM uint32_t HDSEL      : 1;            /*!< [3..3] Half-duplex selection                                              */
            uint32_t            : 2;
      __IOM uint32_t DMAR       : 1;            /*!< [6..6] DMA enable receiver                                                */
      __IOM uint32_t DMAT       : 1;            /*!< [7..7] DMA enable transmitter                                             */
      __IOM uint32_t RTSE       : 1;            /*!< [8..8] RTS enable                                                         */
      __IOM uint32_t CTSE       : 1;            /*!< [9..9] CTS enable                                                         */
      __IOM uint32_t CTSIE      : 1;            /*!< [10..10] CTS interrupt enable                                             */
            uint32_t            : 1;
      __IOM uint32_t OVRDIS     : 1;            /*!< [12..12] Overrun Disable                                                  */
      __IOM uint32_t DDRE       : 1;            /*!< [13..13] DMA Disable on Reception Error                                   */
      __IOM uint32_t DEM        : 1;            /*!< [14..14] Driver enable mode                                               */
      __IOM uint32_t DEP        : 1;            /*!< [15..15] Driver enable polarity selection                                 */
            uint32_t            : 4;
      __IOM uint32_t WUS        : 2;            /*!< [21..20] Wakeup from Stop mode interrupt flag selection                   */
      __IOM uint32_t WUFIE      : 1;            /*!< [22..22] Wakeup from Stop mode interrupt enable                           */
      __IOM uint32_t TXFTIE     : 1;            /*!< [23..23] TXFIFO threshold interrupt enable                                */
            uint32_t            : 1;
      __IOM uint32_t RXFTCFG    : 3;            /*!< [27..25] Receive FIFO threshold configuration                             */
      __IOM uint32_t RXFTIE     : 1;            /*!< [28..28] RXFIFO threshold interrupt enable                                */
      __IOM uint32_t TXFTCFG    : 3;            /*!< [31..29] TXFIFO threshold configuration                                   */
    } CR3_b;
  } ;
  
  union {
    __IOM uint32_t BRR;                         /*!< (@ 0x0000000C) Baud rate register                                         */
    
    struct {
      __IOM uint32_t BRR        : 20;           /*!< [19..0] BRR                                                               */
            uint32_t            : 12;
    } BRR_b;
  } ;
  
  union {
    __IOM uint32_t GTPR;                        /*!< (@ 0x00000010) Guard time and prescaler register                          */
    
    struct {
      __IOM uint32_t PSC        : 8;            /*!< [7..0] Prescaler value                                                    */
      __IOM uint32_t GT         : 8;            /*!< [15..8] Guard time value                                                  */
            uint32_t            : 16;
    } GTPR_b;
  } ;
  
  union {
    __IOM uint32_t RTOR;                        /*!< (@ 0x00000014) Receiver timeout register                                  */
    
    struct {
      __IOM uint32_t RTO        : 24;           /*!< [23..0] Receiver timeout value                                            */
      __IOM uint32_t BLEN       : 8;            /*!< [31..24] Block Length                                                     */
    } RTOR_b;
  } ;
  
  union {
    __OM  uint32_t RQR;                         /*!< (@ 0x00000018) Request register                                           */
    
    struct {
      __OM  uint32_t ABRRQ      : 1;            /*!< [0..0] Auto baud rate request                                             */
      __OM  uint32_t SBKRQ      : 1;            /*!< [1..1] Send break request                                                 */
      __OM  uint32_t MMRQ       : 1;            /*!< [2..2] Mute mode request                                                  */
      __OM  uint32_t RXFRQ      : 1;            /*!< [3..3] Receive data flush request                                         */
      __OM  uint32_t TXFRQ      : 1;            /*!< [4..4] Transmit data flush request                                        */
            uint32_t            : 27;
    } RQR_b;
  } ;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x0000001C) Interrupt & status register                                */
    
    struct {
      __IM  uint32_t PE         : 1;            /*!< [0..0] PE                                                                 */
      __IM  uint32_t FE         : 1;            /*!< [1..1] FE                                                                 */
      __IM  uint32_t NE         : 1;            /*!< [2..2] NE                                                                 */
      __IM  uint32_t ORE        : 1;            /*!< [3..3] ORE                                                                */
      __IM  uint32_t IDLE       : 1;            /*!< [4..4] IDLE                                                               */
      __IM  uint32_t RXNE       : 1;            /*!< [5..5] RXNE                                                               */
      __IM  uint32_t TC         : 1;            /*!< [6..6] TC                                                                 */
      __IM  uint32_t TXE        : 1;            /*!< [7..7] TXE                                                                */
            uint32_t            : 1;
      __IM  uint32_t CTSIF      : 1;            /*!< [9..9] CTSIF                                                              */
      __IM  uint32_t CTS        : 1;            /*!< [10..10] CTS                                                              */
            uint32_t            : 5;
      __IM  uint32_t BUSY       : 1;            /*!< [16..16] BUSY                                                             */
      __IM  uint32_t CMF        : 1;            /*!< [17..17] CMF                                                              */
      __IM  uint32_t SBKF       : 1;            /*!< [18..18] SBKF                                                             */
      __IM  uint32_t RWU        : 1;            /*!< [19..19] RWU                                                              */
      __IM  uint32_t WUF        : 1;            /*!< [20..20] WUF                                                              */
      __IM  uint32_t TEACK      : 1;            /*!< [21..21] TEACK                                                            */
      __IM  uint32_t REACK      : 1;            /*!< [22..22] REACK                                                            */
      __IM  uint32_t TXFE       : 1;            /*!< [23..23] TXFIFO Empty                                                     */
      __IM  uint32_t RXFF       : 1;            /*!< [24..24] RXFIFO Full                                                      */
            uint32_t            : 1;
      __IM  uint32_t RXFT       : 1;            /*!< [26..26] RXFIFO threshold flag                                            */
      __IM  uint32_t TXFT       : 1;            /*!< [27..27] TXFIFO threshold flag                                            */
            uint32_t            : 4;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000020) Interrupt flag clear register                              */
    
    struct {
      __OM  uint32_t PECF       : 1;            /*!< [0..0] Parity error clear flag                                            */
      __OM  uint32_t FECF       : 1;            /*!< [1..1] Framing error clear flag                                           */
      __OM  uint32_t NCF        : 1;            /*!< [2..2] Noise detected clear flag                                          */
      __OM  uint32_t ORECF      : 1;            /*!< [3..3] Overrun error clear flag                                           */
      __OM  uint32_t IDLECF     : 1;            /*!< [4..4] Idle line detected clear flag                                      */
            uint32_t            : 1;
      __OM  uint32_t TCCF       : 1;            /*!< [6..6] Transmission complete clear flag                                   */
            uint32_t            : 2;
      __OM  uint32_t CTSCF      : 1;            /*!< [9..9] CTS clear flag                                                     */
            uint32_t            : 7;
      __OM  uint32_t CMCF       : 1;            /*!< [17..17] Character match clear flag                                       */
            uint32_t            : 2;
      __OM  uint32_t WUCF       : 1;            /*!< [20..20] Wakeup from Stop mode clear flag                                 */
            uint32_t            : 11;
    } ICR_b;
  } ;
  
  union {
    __IM  uint32_t RDR;                         /*!< (@ 0x00000024) Receive data register                                      */
    
    struct {
      __IM  uint32_t RDR        : 9;            /*!< [8..0] Receive data value                                                 */
            uint32_t            : 23;
    } RDR_b;
  } ;
  
  union {
    __IOM uint32_t TDR;                         /*!< (@ 0x00000028) Transmit data register                                     */
    
    struct {
      __IOM uint32_t TDR        : 9;            /*!< [8..0] Transmit data value                                                */
            uint32_t            : 23;
    } TDR_b;
  } ;
  
  union {
    __IOM uint32_t PRESC;                       /*!< (@ 0x0000002C) Prescaler register                                         */
    
    struct {
      __IOM uint32_t PRESCALER  : 4;            /*!< [3..0] Clock prescaler                                                    */
            uint32_t            : 28;
    } PRESC_b;
  } ;
} LPUART1_Type;                                 /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System configuration controller (SYSCFG)
  */

typedef struct {                                /*!< (@ 0x58000400) SYSCFG Structure                                           */
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t PMCR;                        /*!< (@ 0x00000004) peripheral mode configuration register                     */
    
    struct {
      __IOM uint32_t I2C1FMP    : 1;            /*!< [0..0] I2C1 Fm+                                                           */
      __IOM uint32_t I2C2FMP    : 1;            /*!< [1..1] I2C2 Fm+                                                           */
      __IOM uint32_t I2C3FMP    : 1;            /*!< [2..2] I2C3 Fm+                                                           */
      __IOM uint32_t I2C4FMP    : 1;            /*!< [3..3] I2C4 Fm+                                                           */
      __IOM uint32_t PB6FMP     : 1;            /*!< [4..4] PB(6) Fm+                                                          */
      __IOM uint32_t PB7FMP     : 1;            /*!< [5..5] PB(7) Fast Mode Plus                                               */
      __IOM uint32_t PB8FMP     : 1;            /*!< [6..6] PB(8) Fast Mode Plus                                               */
      __IOM uint32_t PB9FMP     : 1;            /*!< [7..7] PB(9) Fm+                                                          */
      __IOM uint32_t BOOSTE     : 1;            /*!< [8..8] Booster Enable                                                     */
            uint32_t            : 12;
      __IOM uint32_t EPIS       : 3;            /*!< [23..21] Ethernet PHY Interface Selection                                 */
      __IOM uint32_t PA0SO      : 1;            /*!< [24..24] PA0 Switch Open                                                  */
      __IOM uint32_t PA1SO      : 1;            /*!< [25..25] PA1 Switch Open                                                  */
      __IOM uint32_t PC2SO      : 1;            /*!< [26..26] PC2 Switch Open                                                  */
      __IOM uint32_t PC3SO      : 1;            /*!< [27..27] PC3 Switch Open                                                  */
            uint32_t            : 4;
    } PMCR_b;
  } ;
  
  union {
    __IOM uint32_t EXTICR1;                     /*!< (@ 0x00000008) external interrupt configuration register 1                */
    
    struct {
      __IOM uint32_t EXTI0      : 4;            /*!< [3..0] EXTI x configuration (x = 0 to 3)                                  */
      __IOM uint32_t EXTI1      : 4;            /*!< [7..4] EXTI x configuration (x = 0 to 3)                                  */
      __IOM uint32_t EXTI2      : 4;            /*!< [11..8] EXTI x configuration (x = 0 to 3)                                 */
      __IOM uint32_t EXTI3      : 4;            /*!< [15..12] EXTI x configuration (x = 0 to 3)                                */
            uint32_t            : 16;
    } EXTICR1_b;
  } ;
  
  union {
    __IOM uint32_t EXTICR2;                     /*!< (@ 0x0000000C) external interrupt configuration register 2                */
    
    struct {
      __IOM uint32_t EXTI4      : 4;            /*!< [3..0] EXTI x configuration (x = 4 to 7)                                  */
      __IOM uint32_t EXTI5      : 4;            /*!< [7..4] EXTI x configuration (x = 4 to 7)                                  */
      __IOM uint32_t EXTI6      : 4;            /*!< [11..8] EXTI x configuration (x = 4 to 7)                                 */
      __IOM uint32_t EXTI7      : 4;            /*!< [15..12] EXTI x configuration (x = 4 to 7)                                */
            uint32_t            : 16;
    } EXTICR2_b;
  } ;
  
  union {
    __IOM uint32_t EXTICR3;                     /*!< (@ 0x00000010) external interrupt configuration register 3                */
    
    struct {
      __IOM uint32_t EXTI8      : 4;            /*!< [3..0] EXTI x configuration (x = 8 to 11)                                 */
      __IOM uint32_t EXTI9      : 4;            /*!< [7..4] EXTI x configuration (x = 8 to 11)                                 */
      __IOM uint32_t EXTI10     : 4;            /*!< [11..8] EXTI10                                                            */
      __IOM uint32_t EXTI11     : 4;            /*!< [15..12] EXTI x configuration (x = 8 to 11)                               */
            uint32_t            : 16;
    } EXTICR3_b;
  } ;
  
  union {
    __IOM uint32_t EXTICR4;                     /*!< (@ 0x00000014) external interrupt configuration register 4                */
    
    struct {
      __IOM uint32_t EXTI12     : 4;            /*!< [3..0] EXTI x configuration (x = 12 to 15)                                */
      __IOM uint32_t EXTI13     : 4;            /*!< [7..4] EXTI x configuration (x = 12 to 15)                                */
      __IOM uint32_t EXTI14     : 4;            /*!< [11..8] EXTI x configuration (x = 12 to 15)                               */
      __IOM uint32_t EXTI15     : 4;            /*!< [15..12] EXTI x configuration (x = 12 to 15)                              */
            uint32_t            : 16;
    } EXTICR4_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t CCCSR;                       /*!< (@ 0x00000020) compensation cell control/status register                  */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] enable                                                             */
      __IOM uint32_t CS         : 1;            /*!< [1..1] Code selection                                                     */
            uint32_t            : 6;
      __IOM uint32_t READY      : 1;            /*!< [8..8] Compensation cell ready flag                                       */
            uint32_t            : 7;
      __IOM uint32_t HSLV       : 1;            /*!< [16..16] High-speed at low-voltage                                        */
            uint32_t            : 15;
    } CCCSR_b;
  } ;
  
  union {
    __IM  uint32_t CCVR;                        /*!< (@ 0x00000024) SYSCFG compensation cell value register                    */
    
    struct {
      __IM  uint32_t NCV        : 4;            /*!< [3..0] NMOS compensation value                                            */
      __IM  uint32_t PCV        : 4;            /*!< [7..4] PMOS compensation value                                            */
            uint32_t            : 24;
    } CCVR_b;
  } ;
  
  union {
    __IOM uint32_t CCCR;                        /*!< (@ 0x00000028) SYSCFG compensation cell code register                     */
    
    struct {
      __IOM uint32_t NCC        : 4;            /*!< [3..0] NMOS compensation code                                             */
      __IOM uint32_t PCC        : 4;            /*!< [7..4] PMOS compensation code                                             */
            uint32_t            : 24;
    } CCCR_b;
  } ;
  __IM  uint32_t  RESERVED2[62];
  
  union {
    __IM  uint32_t PKGR;                        /*!< (@ 0x00000124) SYSCFG package register                                    */
    
    struct {
      __IM  uint32_t PKG        : 4;            /*!< [3..0] Package                                                            */
            uint32_t            : 28;
    } PKGR_b;
  } ;
  __IM  uint32_t  RESERVED3[118];
  
  union {
    __IM  uint32_t UR0;                         /*!< (@ 0x00000300) SYSCFG user register 0                                     */
    
    struct {
      __IM  uint32_t BKS        : 1;            /*!< [0..0] Bank Swap                                                          */
            uint32_t            : 15;
      __IM  uint32_t RDP        : 8;            /*!< [23..16] Readout protection                                               */
            uint32_t            : 8;
    } UR0_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t UR2;                         /*!< (@ 0x00000308) SYSCFG user register 2                                     */
    
    struct {
      __IOM uint32_t BORH       : 2;            /*!< [1..0] BOR_LVL Brownout Reset Threshold Level                             */
            uint32_t            : 14;
      __IOM uint32_t BOOT_ADD0  : 16;           /*!< [31..16] Boot Address 0                                                   */
    } UR2_b;
  } ;
  
  union {
    __IOM uint32_t UR3;                         /*!< (@ 0x0000030C) SYSCFG user register 3                                     */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t BOOT_ADD1  : 16;           /*!< [31..16] Boot Address 1                                                   */
    } UR3_b;
  } ;
  
  union {
    __IM  uint32_t UR4;                         /*!< (@ 0x00000310) SYSCFG user register 4                                     */
    
    struct {
            uint32_t            : 16;
      __IM  uint32_t MEPAD_1    : 1;            /*!< [16..16] Mass Erase Protected Area Disabled for bank 1                    */
            uint32_t            : 15;
    } UR4_b;
  } ;
  
  union {
    __IM  uint32_t UR5;                         /*!< (@ 0x00000314) SYSCFG user register 5                                     */
    
    struct {
      __IM  uint32_t MESAD_1    : 1;            /*!< [0..0] Mass erase secured area disabled for bank 1                        */
            uint32_t            : 15;
      __IM  uint32_t WRPN_1     : 8;            /*!< [23..16] Write protection for flash bank 1                                */
            uint32_t            : 8;
    } UR5_b;
  } ;
  
  union {
    __IM  uint32_t UR6;                         /*!< (@ 0x00000318) SYSCFG user register 6                                     */
    
    struct {
      __IM  uint32_t PA_BEG_1   : 12;           /*!< [11..0] Protected area start address for bank 1                           */
            uint32_t            : 4;
      __IM  uint32_t PA_END_1   : 12;           /*!< [27..16] Protected area end address for bank 1                            */
            uint32_t            : 4;
    } UR6_b;
  } ;
  
  union {
    __IM  uint32_t UR7;                         /*!< (@ 0x0000031C) SYSCFG user register 7                                     */
    
    struct {
      __IM  uint32_t SA_BEG_1   : 12;           /*!< [11..0] Secured area start address for bank 1                             */
            uint32_t            : 4;
      __IM  uint32_t SA_END_1   : 12;           /*!< [27..16] Secured area end address for bank 1                              */
            uint32_t            : 4;
    } UR7_b;
  } ;
  
  union {
    __IM  uint32_t UR8;                         /*!< (@ 0x00000320) SYSCFG user register 8                                     */
    
    struct {
      __IM  uint32_t MEPAD_2    : 1;            /*!< [0..0] Mass erase protected area disabled for bank 2                      */
            uint32_t            : 15;
      __IM  uint32_t MESAD_2    : 1;            /*!< [16..16] Mass erase secured area disabled for bank 2                      */
            uint32_t            : 15;
    } UR8_b;
  } ;
  
  union {
    __IM  uint32_t UR9;                         /*!< (@ 0x00000324) SYSCFG user register 9                                     */
    
    struct {
      __IM  uint32_t WRPN_2     : 8;            /*!< [7..0] Write protection for flash bank 2                                  */
            uint32_t            : 8;
      __IM  uint32_t PA_BEG_2   : 12;           /*!< [27..16] Protected area start address for bank 2                          */
            uint32_t            : 4;
    } UR9_b;
  } ;
  
  union {
    __IM  uint32_t UR10;                        /*!< (@ 0x00000328) SYSCFG user register 10                                    */
    
    struct {
      __IM  uint32_t PA_END_2   : 12;           /*!< [11..0] Protected area end address for bank 2                             */
            uint32_t            : 4;
      __IM  uint32_t SA_BEG_2   : 12;           /*!< [27..16] Secured area start address for bank 2                            */
            uint32_t            : 4;
    } UR10_b;
  } ;
  
  union {
    __IM  uint32_t UR11;                        /*!< (@ 0x0000032C) SYSCFG user register 11                                    */
    
    struct {
      __IM  uint32_t SA_END_2   : 12;           /*!< [11..0] Secured area end address for bank 2                               */
            uint32_t            : 4;
      __IM  uint32_t IWDG1M     : 1;            /*!< [16..16] Independent Watchdog 1 mode                                      */
            uint32_t            : 15;
    } UR11_b;
  } ;
  
  union {
    __IM  uint32_t UR12;                        /*!< (@ 0x00000330) SYSCFG user register 12                                    */
    
    struct {
            uint32_t            : 16;
      __IM  uint32_t SECURE     : 1;            /*!< [16..16] Secure mode                                                      */
            uint32_t            : 15;
    } UR12_b;
  } ;
  
  union {
    __IM  uint32_t UR13;                        /*!< (@ 0x00000334) SYSCFG user register 13                                    */
    
    struct {
      __IM  uint32_t SDRS       : 2;            /*!< [1..0] Secured DTCM RAM Size                                              */
            uint32_t            : 14;
      __IM  uint32_t D1SBRST    : 1;            /*!< [16..16] D1 Standby reset                                                 */
            uint32_t            : 15;
    } UR13_b;
  } ;
  
  union {
    __IOM uint32_t UR14;                        /*!< (@ 0x00000338) SYSCFG user register 14                                    */
    
    struct {
      __IOM uint32_t D1STPRST   : 1;            /*!< [0..0] D1 Stop Reset                                                      */
            uint32_t            : 31;
    } UR14_b;
  } ;
  
  union {
    __IM  uint32_t UR15;                        /*!< (@ 0x0000033C) SYSCFG user register 15                                    */
    
    struct {
            uint32_t            : 16;
      __IM  uint32_t FZIWDGSTB  : 1;            /*!< [16..16] Freeze independent watchdog in Standby mode                      */
            uint32_t            : 15;
    } UR15_b;
  } ;
  
  union {
    __IM  uint32_t UR16;                        /*!< (@ 0x00000340) SYSCFG user register 16                                    */
    
    struct {
      __IM  uint32_t FZIWDGSTP  : 1;            /*!< [0..0] Freeze independent watchdog in Stop mode                           */
            uint32_t            : 15;
      __IM  uint32_t PKP        : 1;            /*!< [16..16] Private key programmed                                           */
            uint32_t            : 15;
    } UR16_b;
  } ;
  
  union {
    __IM  uint32_t UR17;                        /*!< (@ 0x00000344) SYSCFG user register 17                                    */
    
    struct {
      __IM  uint32_t IO_HSLV    : 1;            /*!< [0..0] I/O high speed / low voltage                                       */
            uint32_t            : 31;
    } UR17_b;
  } ;
} SYSCFG_Type;                                  /*!< Size = 840 (0x348)                                                        */



/* =========================================================================================================================== */
/* ================                                           EXTI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief External interrupt/event
      controller (EXTI)
  */

typedef struct {                                /*!< (@ 0x58000000) EXTI Structure                                             */
  
  union {
    __IOM uint32_t RTSR1;                       /*!< (@ 0x00000000) EXTI rising trigger selection register                     */
    
    struct {
      __IOM uint32_t TR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 10;
    } RTSR1_b;
  } ;
  
  union {
    __IOM uint32_t FTSR1;                       /*!< (@ 0x00000004) EXTI falling trigger selection register                    */
    
    struct {
      __IOM uint32_t TR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t TR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 10;
    } FTSR1_b;
  } ;
  
  union {
    __IOM uint32_t SWIER1;                      /*!< (@ 0x00000008) EXTI software interrupt event register                     */
    
    struct {
      __IOM uint32_t SWIER0     : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER1     : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER2     : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER3     : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER4     : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER5     : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER6     : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER7     : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER8     : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER9     : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER10    : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER11    : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER12    : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER13    : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER14    : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER15    : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER16    : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER17    : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER18    : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER19    : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER20    : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t SWIER21    : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 10;
    } SWIER1_b;
  } ;
  
  union {
    __IOM uint32_t D3PMR1;                      /*!< (@ 0x0000000C) EXTI D3 pending mask register                              */
    
    struct {
      __IOM uint32_t MR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 3;
      __IOM uint32_t MR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 3;
      __IOM uint32_t MR25       : 1;            /*!< [25..25] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
            uint32_t            : 6;
    } D3PMR1_b;
  } ;
  
  union {
    __IOM uint32_t D3PCR1L;                     /*!< (@ 0x00000010) EXTI D3 pending clear selection register low               */
    
    struct {
      __IOM uint32_t PCS0       : 2;            /*!< [1..0] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32_t PCS1       : 2;            /*!< [3..2] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32_t PCS2       : 2;            /*!< [5..4] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32_t PCS3       : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32_t PCS4       : 2;            /*!< [9..8] D3 Pending request clear input signal selection on Event
                                                     input x = truncate (n/2)                                                  */
      __IOM uint32_t PCS5       : 2;            /*!< [11..10] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS6       : 2;            /*!< [13..12] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS7       : 2;            /*!< [15..14] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS8       : 2;            /*!< [17..16] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS9       : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS10      : 2;            /*!< [21..20] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS11      : 2;            /*!< [23..22] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS12      : 2;            /*!< [25..24] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS13      : 2;            /*!< [27..26] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS14      : 2;            /*!< [29..28] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
      __IOM uint32_t PCS15      : 2;            /*!< [31..30] D3 Pending request clear input signal selection on
                                                     Event input x = truncate (n/2)                                            */
    } D3PCR1L_b;
  } ;
  
  union {
    __IOM uint32_t D3PCR1H;                     /*!< (@ 0x00000014) EXTI D3 pending clear selection register high              */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t PCS19      : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+32)/2)                                             */
      __IOM uint32_t PCS20      : 2;            /*!< [9..8] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+32)/2)                                             */
      __IOM uint32_t PCS21      : 2;            /*!< [11..10] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+32)/2)                                       */
            uint32_t            : 6;
      __IOM uint32_t PCS25      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+32)/2)                                       */
            uint32_t            : 12;
    } D3PCR1H_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t RTSR2;                       /*!< (@ 0x00000020) EXTI rising trigger selection register                     */
    
    struct {
            uint32_t            : 17;
      __IOM uint32_t TR49       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32_t            : 1;
      __IOM uint32_t TR51       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32_t            : 12;
    } RTSR2_b;
  } ;
  
  union {
    __IOM uint32_t FTSR2;                       /*!< (@ 0x00000024) EXTI falling trigger selection register                    */
    
    struct {
            uint32_t            : 17;
      __IOM uint32_t TR49       : 1;            /*!< [17..17] Falling trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32_t            : 1;
      __IOM uint32_t TR51       : 1;            /*!< [19..19] Falling trigger event configuration bit of Configurable
                                                     Event input x+32                                                          */
            uint32_t            : 12;
    } FTSR2_b;
  } ;
  
  union {
    __IOM uint32_t SWIER2;                      /*!< (@ 0x00000028) EXTI software interrupt event register                     */
    
    struct {
            uint32_t            : 17;
      __IOM uint32_t SWIER49    : 1;            /*!< [17..17] Software interrupt on line x+32                                  */
            uint32_t            : 1;
      __IOM uint32_t SWIER51    : 1;            /*!< [19..19] Software interrupt on line x+32                                  */
            uint32_t            : 12;
    } SWIER2_b;
  } ;
  
  union {
    __IOM uint32_t D3PMR2;                      /*!< (@ 0x0000002C) EXTI D3 pending mask register                              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t MR34       : 1;            /*!< [2..2] D3 Pending Mask on Event input x+32                                */
      __IOM uint32_t MR35       : 1;            /*!< [3..3] D3 Pending Mask on Event input x+32                                */
            uint32_t            : 5;
      __IOM uint32_t MR41       : 1;            /*!< [9..9] D3 Pending Mask on Event input x+32                                */
            uint32_t            : 6;
      __IOM uint32_t MR48       : 1;            /*!< [16..16] D3 Pending Mask on Event input x+32                              */
      __IOM uint32_t MR49       : 1;            /*!< [17..17] D3 Pending Mask on Event input x+32                              */
      __IOM uint32_t MR50       : 1;            /*!< [18..18] D3 Pending Mask on Event input x+32                              */
      __IOM uint32_t MR51       : 1;            /*!< [19..19] D3 Pending Mask on Event input x+32                              */
      __IOM uint32_t MR52       : 1;            /*!< [20..20] D3 Pending Mask on Event input x+32                              */
      __IOM uint32_t MR53       : 1;            /*!< [21..21] D3 Pending Mask on Event input x+32                              */
            uint32_t            : 10;
    } D3PMR2_b;
  } ;
  
  union {
    __IOM uint32_t D3PCR2L;                     /*!< (@ 0x00000030) EXTI D3 pending clear selection register low               */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t PCS34      : 2;            /*!< [5..4] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+64)/2)                                             */
      __IOM uint32_t PCS35      : 2;            /*!< [7..6] D3 Pending request clear input signal selection on Event
                                                     input x = truncate ((n+64)/2)                                             */
            uint32_t            : 10;
      __IOM uint32_t PCS41      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x = truncate ((n+64)/2)                                       */
            uint32_t            : 12;
    } D3PCR2L_b;
  } ;
  
  union {
    __IOM uint32_t D3PCR2H;                     /*!< (@ 0x00000034) EXTI D3 pending clear selection register high              */
    
    struct {
      __IOM uint32_t PCS48      : 2;            /*!< [1..0] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32_t PCS49      : 2;            /*!< [3..2] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32_t PCS50      : 2;            /*!< [5..4] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32_t PCS51      : 2;            /*!< [7..6] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32_t PCS52      : 2;            /*!< [9..8] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
      __IOM uint32_t PCS53      : 2;            /*!< [11..10] Pending request clear input signal selection on Event
                                                     input x= truncate ((n+96)/2)                                              */
            uint32_t            : 20;
    } D3PCR2H_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t RTSR3;                       /*!< (@ 0x00000040) EXTI rising trigger selection register                     */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t TR82       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32_t            : 1;
      __IOM uint32_t TR84       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32_t TR85       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32_t TR86       : 1;            /*!< [22..22] Rising trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32_t            : 9;
    } RTSR3_b;
  } ;
  
  union {
    __IOM uint32_t FTSR3;                       /*!< (@ 0x00000044) EXTI falling trigger selection register                    */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t TR82       : 1;            /*!< [18..18] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32_t            : 1;
      __IOM uint32_t TR84       : 1;            /*!< [20..20] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32_t TR85       : 1;            /*!< [21..21] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
      __IOM uint32_t TR86       : 1;            /*!< [22..22] Falling trigger event configuration bit of Configurable
                                                     Event input x+64                                                          */
            uint32_t            : 9;
    } FTSR3_b;
  } ;
  
  union {
    __IOM uint32_t SWIER3;                      /*!< (@ 0x00000048) EXTI software interrupt event register                     */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t SWIER82    : 1;            /*!< [18..18] Software interrupt on line x+64                                  */
            uint32_t            : 1;
      __IOM uint32_t SWIER84    : 1;            /*!< [20..20] Software interrupt on line x+64                                  */
      __IOM uint32_t SWIER85    : 1;            /*!< [21..21] Software interrupt on line x+64                                  */
      __IOM uint32_t SWIER86    : 1;            /*!< [22..22] Software interrupt on line x+64                                  */
            uint32_t            : 9;
    } SWIER3_b;
  } ;
  
  union {
    __IOM uint32_t D3PMR3;                      /*!< (@ 0x0000004C) EXTI D3 pending mask register                              */
    
    struct {
            uint32_t            : 24;
      __IOM uint32_t MR88       : 1;            /*!< [24..24] D3 Pending Mask on Event input x+64                              */
            uint32_t            : 7;
    } D3PMR3_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t D3PCR3H;                     /*!< (@ 0x00000054) EXTI D3 pending clear selection register high              */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t PCS88      : 2;            /*!< [19..18] D3 Pending request clear input signal selection on
                                                     Event input x= truncate N+160/2                                           */
            uint32_t            : 12;
    } D3PCR3H_b;
  } ;
  __IM  uint32_t  RESERVED3[10];
  
  union {
    __IOM uint32_t CPUIMR1;                     /*!< (@ 0x00000080) EXTI interrupt mask register                               */
    
    struct {
      __IOM uint32_t MR0        : 1;            /*!< [0..0] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR1        : 1;            /*!< [1..1] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR2        : 1;            /*!< [2..2] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR3        : 1;            /*!< [3..3] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR4        : 1;            /*!< [4..4] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR5        : 1;            /*!< [5..5] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR6        : 1;            /*!< [6..6] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR7        : 1;            /*!< [7..7] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR8        : 1;            /*!< [8..8] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR9        : 1;            /*!< [9..9] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR10       : 1;            /*!< [10..10] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR11       : 1;            /*!< [11..11] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR12       : 1;            /*!< [12..12] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR13       : 1;            /*!< [13..13] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR14       : 1;            /*!< [14..14] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR15       : 1;            /*!< [15..15] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR16       : 1;            /*!< [16..16] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR17       : 1;            /*!< [17..17] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR18       : 1;            /*!< [18..18] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR19       : 1;            /*!< [19..19] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR20       : 1;            /*!< [20..20] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR21       : 1;            /*!< [21..21] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR22       : 1;            /*!< [22..22] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR23       : 1;            /*!< [23..23] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR24       : 1;            /*!< [24..24] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR25       : 1;            /*!< [25..25] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR26       : 1;            /*!< [26..26] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR27       : 1;            /*!< [27..27] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR28       : 1;            /*!< [28..28] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR29       : 1;            /*!< [29..29] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR30       : 1;            /*!< [30..30] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
      __IOM uint32_t MR31       : 1;            /*!< [31..31] Rising trigger event configuration bit of Configurable
                                                     Event input                                                               */
    } CPUIMR1_b;
  } ;
  
  union {
    __IOM uint32_t CPUEMR1;                     /*!< (@ 0x00000084) EXTI event mask register                                   */
    
    struct {
      __IOM uint32_t MR0        : 1;            /*!< [0..0] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR1        : 1;            /*!< [1..1] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR2        : 1;            /*!< [2..2] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR3        : 1;            /*!< [3..3] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR4        : 1;            /*!< [4..4] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR5        : 1;            /*!< [5..5] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR6        : 1;            /*!< [6..6] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR7        : 1;            /*!< [7..7] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR8        : 1;            /*!< [8..8] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR9        : 1;            /*!< [9..9] CPU Event mask on Event input x                                    */
      __IOM uint32_t MR10       : 1;            /*!< [10..10] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR11       : 1;            /*!< [11..11] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR12       : 1;            /*!< [12..12] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR13       : 1;            /*!< [13..13] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR14       : 1;            /*!< [14..14] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR15       : 1;            /*!< [15..15] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR16       : 1;            /*!< [16..16] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR17       : 1;            /*!< [17..17] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR18       : 1;            /*!< [18..18] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR19       : 1;            /*!< [19..19] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR20       : 1;            /*!< [20..20] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR21       : 1;            /*!< [21..21] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR22       : 1;            /*!< [22..22] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR23       : 1;            /*!< [23..23] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR24       : 1;            /*!< [24..24] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR25       : 1;            /*!< [25..25] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR26       : 1;            /*!< [26..26] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR27       : 1;            /*!< [27..27] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR28       : 1;            /*!< [28..28] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR29       : 1;            /*!< [29..29] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR30       : 1;            /*!< [30..30] CPU Event mask on Event input x                                  */
      __IOM uint32_t MR31       : 1;            /*!< [31..31] CPU Event mask on Event input x                                  */
    } CPUEMR1_b;
  } ;
  
  union {
    __IOM uint32_t CPUPR1;                      /*!< (@ 0x00000088) EXTI pending register                                      */
    
    struct {
      __IOM uint32_t PR0        : 1;            /*!< [0..0] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR1        : 1;            /*!< [1..1] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR2        : 1;            /*!< [2..2] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR3        : 1;            /*!< [3..3] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR4        : 1;            /*!< [4..4] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR5        : 1;            /*!< [5..5] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR6        : 1;            /*!< [6..6] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR7        : 1;            /*!< [7..7] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR8        : 1;            /*!< [8..8] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR9        : 1;            /*!< [9..9] CPU Event mask on Event input x                                    */
      __IOM uint32_t PR10       : 1;            /*!< [10..10] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR11       : 1;            /*!< [11..11] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR12       : 1;            /*!< [12..12] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR13       : 1;            /*!< [13..13] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR14       : 1;            /*!< [14..14] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR15       : 1;            /*!< [15..15] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR16       : 1;            /*!< [16..16] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR17       : 1;            /*!< [17..17] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR18       : 1;            /*!< [18..18] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR19       : 1;            /*!< [19..19] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR20       : 1;            /*!< [20..20] CPU Event mask on Event input x                                  */
      __IOM uint32_t PR21       : 1;            /*!< [21..21] CPU Event mask on Event input x                                  */
            uint32_t            : 10;
    } CPUPR1_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t CPUIMR2;                     /*!< (@ 0x00000090) EXTI interrupt mask register                               */
    
    struct {
      __IOM uint32_t MR0        : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR1        : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR2        : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR3        : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR4        : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR5        : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR6        : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR7        : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR8        : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR9        : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR10       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR11       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR12       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+32                    */
            uint32_t            : 1;
      __IOM uint32_t MR14       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR15       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR16       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR17       : 1;            /*!< [17..17] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR18       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR19       : 1;            /*!< [19..19] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR20       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR21       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR22       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR23       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR24       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR25       : 1;            /*!< [25..25] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR26       : 1;            /*!< [26..26] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR27       : 1;            /*!< [27..27] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR28       : 1;            /*!< [28..28] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR29       : 1;            /*!< [29..29] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR30       : 1;            /*!< [30..30] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR31       : 1;            /*!< [31..31] CPU Interrupt Mask on Direct Event input x+32                    */
    } CPUIMR2_b;
  } ;
  
  union {
    __IOM uint32_t CPUEMR2;                     /*!< (@ 0x00000094) EXTI event mask register                                   */
    
    struct {
      __IOM uint32_t MR32       : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR33       : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR34       : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR35       : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR36       : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR37       : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR38       : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR39       : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR40       : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR41       : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+32                      */
      __IOM uint32_t MR42       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR43       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR44       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+32                    */
            uint32_t            : 1;
      __IOM uint32_t MR46       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR47       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR48       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR49       : 1;            /*!< [17..17] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR50       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR51       : 1;            /*!< [19..19] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR52       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR53       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR54       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR55       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR56       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR57       : 1;            /*!< [25..25] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR58       : 1;            /*!< [26..26] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR59       : 1;            /*!< [27..27] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR60       : 1;            /*!< [28..28] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR61       : 1;            /*!< [29..29] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR62       : 1;            /*!< [30..30] CPU Interrupt Mask on Direct Event input x+32                    */
      __IOM uint32_t MR63       : 1;            /*!< [31..31] CPU Interrupt Mask on Direct Event input x+32                    */
    } CPUEMR2_b;
  } ;
  
  union {
    __IM  uint32_t CPUPR2;                      /*!< (@ 0x00000098) EXTI pending register                                      */
    
    struct {
            uint32_t            : 17;
      __IM  uint32_t PR49       : 1;            /*!< [17..17] Configurable event inputs x+32 Pending bit                       */
            uint32_t            : 1;
      __IM  uint32_t PR51       : 1;            /*!< [19..19] Configurable event inputs x+32 Pending bit                       */
            uint32_t            : 12;
    } CPUPR2_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IM  uint32_t CPUIMR3;                     /*!< (@ 0x000000A0) EXTI interrupt mask register                               */
    
    struct {
      __IM  uint32_t MR64       : 1;            /*!< [0..0] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR65       : 1;            /*!< [1..1] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR66       : 1;            /*!< [2..2] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR67       : 1;            /*!< [3..3] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR68       : 1;            /*!< [4..4] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR69       : 1;            /*!< [5..5] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR70       : 1;            /*!< [6..6] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR71       : 1;            /*!< [7..7] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR72       : 1;            /*!< [8..8] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR73       : 1;            /*!< [9..9] CPU Interrupt Mask on Direct Event input x+64                      */
      __IM  uint32_t MR74       : 1;            /*!< [10..10] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR75       : 1;            /*!< [11..11] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR76       : 1;            /*!< [12..12] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR77       : 1;            /*!< [13..13] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR78       : 1;            /*!< [14..14] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR79       : 1;            /*!< [15..15] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR80       : 1;            /*!< [16..16] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32_t            : 1;
      __IM  uint32_t MR82       : 1;            /*!< [18..18] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32_t            : 1;
      __IM  uint32_t MR84       : 1;            /*!< [20..20] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR85       : 1;            /*!< [21..21] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR86       : 1;            /*!< [22..22] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR87       : 1;            /*!< [23..23] CPU Interrupt Mask on Direct Event input x+64                    */
      __IM  uint32_t MR88       : 1;            /*!< [24..24] CPU Interrupt Mask on Direct Event input x+64                    */
            uint32_t            : 7;
    } CPUIMR3_b;
  } ;
  
  union {
    __IM  uint32_t CPUEMR3;                     /*!< (@ 0x000000A4) EXTI event mask register                                   */
    
    struct {
      __IM  uint32_t MR64       : 1;            /*!< [0..0] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR65       : 1;            /*!< [1..1] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR66       : 1;            /*!< [2..2] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR67       : 1;            /*!< [3..3] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR68       : 1;            /*!< [4..4] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR69       : 1;            /*!< [5..5] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR70       : 1;            /*!< [6..6] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR71       : 1;            /*!< [7..7] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR72       : 1;            /*!< [8..8] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR73       : 1;            /*!< [9..9] CPU Event mask on Event input x+64                                 */
      __IM  uint32_t MR74       : 1;            /*!< [10..10] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR75       : 1;            /*!< [11..11] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR76       : 1;            /*!< [12..12] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR77       : 1;            /*!< [13..13] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR78       : 1;            /*!< [14..14] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR79       : 1;            /*!< [15..15] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR80       : 1;            /*!< [16..16] CPU Event mask on Event input x+64                               */
            uint32_t            : 1;
      __IM  uint32_t MR82       : 1;            /*!< [18..18] CPU Event mask on Event input x+64                               */
            uint32_t            : 1;
      __IM  uint32_t MR84       : 1;            /*!< [20..20] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR85       : 1;            /*!< [21..21] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR86       : 1;            /*!< [22..22] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR87       : 1;            /*!< [23..23] CPU Event mask on Event input x+64                               */
      __IM  uint32_t MR88       : 1;            /*!< [24..24] CPU Event mask on Event input x+64                               */
            uint32_t            : 7;
    } CPUEMR3_b;
  } ;
  
  union {
    __IM  uint32_t CPUPR3;                      /*!< (@ 0x000000A8) EXTI pending register                                      */
    
    struct {
            uint32_t            : 18;
      __IM  uint32_t PR82       : 1;            /*!< [18..18] Configurable event inputs x+64 Pending bit                       */
            uint32_t            : 1;
      __IM  uint32_t PR84       : 1;            /*!< [20..20] Configurable event inputs x+64 Pending bit                       */
      __IM  uint32_t PR85       : 1;            /*!< [21..21] Configurable event inputs x+64 Pending bit                       */
      __IM  uint32_t PR86       : 1;            /*!< [22..22] Configurable event inputs x+64 Pending bit                       */
            uint32_t            : 9;
    } CPUPR3_b;
  } ;
} EXTI_Type;                                    /*!< Size = 172 (0xac)                                                         */



/* =========================================================================================================================== */
/* ================                                    DELAY_Block_SDMMC1                                     ================ */
/* =========================================================================================================================== */


/**
  * @brief DELAY_Block_SDMMC1 (DELAY_Block_SDMMC1)
  */

typedef struct {                                /*!< (@ 0x52008000) DELAY_Block_SDMMC1 Structure                               */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) DLYB control register                                      */
    
    struct {
      __IOM uint32_t DEN        : 1;            /*!< [0..0] Delay block enable bit                                             */
      __IOM uint32_t SEN        : 1;            /*!< [1..1] Sampler length enable bit                                          */
            uint32_t            : 30;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t CFGR;                        /*!< (@ 0x00000004) DLYB configuration register                                */
    
    struct {
      __IOM uint32_t SEL        : 4;            /*!< [3..0] Select the phase for the Output clock                              */
            uint32_t            : 4;
      __IOM uint32_t UNIT       : 7;            /*!< [14..8] Delay Defines the delay of a Unit delay cell                      */
            uint32_t            : 1;
      __IOM uint32_t LNG        : 12;           /*!< [27..16] Delay line length value                                          */
            uint32_t            : 3;
      __IOM uint32_t LNGF       : 1;            /*!< [31..31] Length valid flag                                                */
    } CFGR_b;
  } ;
} DELAY_Block_SDMMC1_Type;                      /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           Flash                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Flash (Flash)
  */

typedef struct {                                /*!< (@ 0x52002000) Flash Structure                                            */
  
  union {
    __IOM uint32_t ACR;                         /*!< (@ 0x00000000) Access control register                                    */
    
    struct {
      __IOM uint32_t LATENCY    : 3;            /*!< [2..0] Read latency                                                       */
            uint32_t            : 1;
      __IOM uint32_t WRHIGHFREQ : 2;            /*!< [5..4] Flash signal delay                                                 */
            uint32_t            : 26;
    } ACR_b;
  } ;
  
  union {
    __IOM uint32_t KEYR1;                       /*!< (@ 0x00000004) FLASH key register for bank 1                              */
    
    struct {
      __IOM uint32_t KEYR1      : 32;           /*!< [31..0] Bank 1 access configuration unlock key                            */
    } KEYR1_b;
  } ;
  
  union {
    __IOM uint32_t OPTKEYR;                     /*!< (@ 0x00000008) FLASH option key register                                  */
    
    struct {
      __IOM uint32_t OPTKEYR    : 32;           /*!< [31..0] Unlock key option bytes                                           */
    } OPTKEYR_b;
  } ;
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x0000000C) FLASH control register for bank 1                          */
    
    struct {
      __IOM uint32_t LOCK1      : 1;            /*!< [0..0] Bank 1 configuration lock bit                                      */
      __IOM uint32_t PG1        : 1;            /*!< [1..1] Bank 1 program enable bit                                          */
      __IOM uint32_t SER1       : 1;            /*!< [2..2] Bank 1 sector erase request                                        */
      __IOM uint32_t BER1       : 1;            /*!< [3..3] Bank 1 erase request                                               */
      __IOM uint32_t PSIZE1     : 2;            /*!< [5..4] Bank 1 program size                                                */
      __IOM uint32_t FW1        : 1;            /*!< [6..6] Bank 1 write forcing control bit                                   */
      __IOM uint32_t START1     : 1;            /*!< [7..7] Bank 1 bank or sector erase start control bit                      */
      __IOM uint32_t SNB1       : 3;            /*!< [10..8] Bank 1 sector erase selection number                              */
            uint32_t            : 4;
      __IOM uint32_t CRC_EN     : 1;            /*!< [15..15] Bank 1 CRC control bit                                           */
      __IOM uint32_t EOPIE1     : 1;            /*!< [16..16] Bank 1 end-of-program interrupt control bit                      */
      __IOM uint32_t WRPERRIE1  : 1;            /*!< [17..17] Bank 1 write protection error interrupt enable bit               */
      __IOM uint32_t PGSERRIE1  : 1;            /*!< [18..18] Bank 1 programming sequence error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t STRBERRIE1 : 1;            /*!< [19..19] Bank 1 strobe error interrupt enable bit                         */
            uint32_t            : 1;
      __IOM uint32_t INCERRIE1  : 1;            /*!< [21..21] Bank 1 inconsistency error interrupt enable bit                  */
      __IOM uint32_t OPERRIE1   : 1;            /*!< [22..22] Bank 1 write/erase error interrupt enable bit                    */
      __IOM uint32_t RDPERRIE1  : 1;            /*!< [23..23] Bank 1 read protection error interrupt enable bit                */
      __IOM uint32_t RDSERRIE1  : 1;            /*!< [24..24] Bank 1 secure error interrupt enable bit                         */
      __IOM uint32_t SNECCERRIE1 : 1;           /*!< [25..25] Bank 1 ECC single correction error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t DBECCERRIE1 : 1;           /*!< [26..26] Bank 1 ECC double detection error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t CRCENDIE1  : 1;            /*!< [27..27] Bank 1 end of CRC calculation interrupt enable bit               */
            uint32_t            : 4;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t SR1;                         /*!< (@ 0x00000010) FLASH status register for bank 1                           */
    
    struct {
      __IOM uint32_t BSY1       : 1;            /*!< [0..0] Bank 1 ongoing program flag                                        */
      __IOM uint32_t WBNE1      : 1;            /*!< [1..1] Bank 1 write buffer not empty flag                                 */
      __IOM uint32_t QW1        : 1;            /*!< [2..2] Bank 1 wait queue flag                                             */
      __IOM uint32_t CRC_BUSY1  : 1;            /*!< [3..3] Bank 1 CRC busy flag                                               */
            uint32_t            : 12;
      __IOM uint32_t EOP1       : 1;            /*!< [16..16] Bank 1 end-of-program flag                                       */
      __IOM uint32_t WRPERR1    : 1;            /*!< [17..17] Bank 1 write protection error flag                               */
      __IOM uint32_t PGSERR1    : 1;            /*!< [18..18] Bank 1 programming sequence error flag                           */
      __IOM uint32_t STRBERR1   : 1;            /*!< [19..19] Bank 1 strobe error flag                                         */
            uint32_t            : 1;
      __IOM uint32_t INCERR1    : 1;            /*!< [21..21] Bank 1 inconsistency error flag                                  */
      __IOM uint32_t OPERR1     : 1;            /*!< [22..22] Bank 1 write/erase error flag                                    */
      __IOM uint32_t RDPERR1    : 1;            /*!< [23..23] Bank 1 read protection error flag                                */
      __IOM uint32_t RDSERR1    : 1;            /*!< [24..24] Bank 1 secure error flag                                         */
      __IOM uint32_t SNECCERR11 : 1;            /*!< [25..25] Bank 1 single correction error flag                              */
      __IOM uint32_t DBECCERR1  : 1;            /*!< [26..26] Bank 1 ECC double detection error flag                           */
      __IOM uint32_t CRCEND1    : 1;            /*!< [27..27] Bank 1 CRC-complete flag                                         */
            uint32_t            : 4;
    } SR1_b;
  } ;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000014) FLASH clear control register for bank 1                    */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t CLR_EOP1   : 1;            /*!< [16..16] Bank 1 EOP1 flag clear bit                                       */
      __IOM uint32_t CLR_WRPERR1 : 1;           /*!< [17..17] Bank 1 WRPERR1 flag clear bit                                    */
      __IOM uint32_t CLR_PGSERR1 : 1;           /*!< [18..18] Bank 1 PGSERR1 flag clear bi                                     */
      __IOM uint32_t CLR_STRBERR1 : 1;          /*!< [19..19] Bank 1 STRBERR1 flag clear bit                                   */
            uint32_t            : 1;
      __IOM uint32_t CLR_INCERR1 : 1;           /*!< [21..21] Bank 1 INCERR1 flag clear bit                                    */
      __IOM uint32_t CLR_OPERR1 : 1;            /*!< [22..22] Bank 1 OPERR1 flag clear bit                                     */
      __IOM uint32_t CLR_RDPERR1 : 1;           /*!< [23..23] Bank 1 RDPERR1 flag clear bit                                    */
      __IOM uint32_t CLR_RDSERR1 : 1;           /*!< [24..24] Bank 1 RDSERR1 flag clear bit                                    */
      __IOM uint32_t CLR_SNECCERR1 : 1;         /*!< [25..25] Bank 1 SNECCERR1 flag clear bit                                  */
      __IOM uint32_t CLR_DBECCERR1 : 1;         /*!< [26..26] Bank 1 DBECCERR1 flag clear bit                                  */
      __IOM uint32_t CLR_CRCEND1 : 1;           /*!< [27..27] Bank 1 CRCEND1 flag clear bit                                    */
            uint32_t            : 4;
    } CCR1_b;
  } ;
  
  union {
    __IOM uint32_t OPTCR;                       /*!< (@ 0x00000018) FLASH option control register                              */
    
    struct {
      __IOM uint32_t OPTLOCK    : 1;            /*!< [0..0] FLASH_OPTCR lock option configuration bit                          */
      __IOM uint32_t OPTSTART   : 1;            /*!< [1..1] Option byte start change option configuration bit                  */
            uint32_t            : 2;
      __IOM uint32_t MER        : 1;            /*!< [4..4] Flash mass erase enable bit                                        */
            uint32_t            : 25;
      __IOM uint32_t OPTCHANGEERRIE : 1;        /*!< [30..30] Option byte change error interrupt enable bit                    */
      __IOM uint32_t SWAP_BANK  : 1;            /*!< [31..31] Bank swapping configuration bit                                  */
    } OPTCR_b;
  } ;
  
  union {
    __IOM uint32_t OPTSR_CUR;                   /*!< (@ 0x0000001C) FLASH option status register                               */
    
    struct {
      __IOM uint32_t OPT_BUSY   : 1;            /*!< [0..0] Option byte change ongoing flag                                    */
            uint32_t            : 1;
      __IOM uint32_t BOR_LEV    : 2;            /*!< [3..2] Brownout level option status bit                                   */
      __IOM uint32_t IWDG1_HW   : 1;            /*!< [4..4] IWDG1 control option status bit                                    */
            uint32_t            : 1;
      __IOM uint32_t nRST_STOP_D1 : 1;          /*!< [6..6] D1 DStop entry reset option status bit                             */
      __IOM uint32_t nRST_STBY_D1 : 1;          /*!< [7..7] D1 DStandby entry reset option status bit                          */
      __IOM uint32_t RDP        : 8;            /*!< [15..8] Readout protection level option status byte                       */
            uint32_t            : 1;
      __IOM uint32_t FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option status bit                          */
      __IOM uint32_t FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option status bit                       */
      __IOM uint32_t ST_RAM_SIZE : 2;           /*!< [20..19] DTCM RAM size option status                                      */
      __IOM uint32_t SECURITY   : 1;            /*!< [21..21] Security enable option status bit                                */
            uint32_t            : 4;
      __IOM uint32_t RSS1       : 1;            /*!< [26..26] User option bit 1                                                */
            uint32_t            : 1;
      __IOM uint32_t PERSO_OK   : 1;            /*!< [28..28] Device personalization status bit                                */
      __IOM uint32_t IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)     */
      __IOM uint32_t OPTCHANGEERR : 1;          /*!< [30..30] Option byte change error flag                                    */
      __IOM uint32_t SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option status bit                                  */
    } OPTSR_CUR_b;
  } ;
  
  union {
    __IOM uint32_t OPTSR_PRG;                   /*!< (@ 0x00000020) FLASH option status register                               */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t BOR_LEV    : 2;            /*!< [3..2] BOR reset level option configuration bits                          */
      __IOM uint32_t IWDG1_HW   : 1;            /*!< [4..4] IWDG1 option configuration bit                                     */
            uint32_t            : 1;
      __IOM uint32_t nRST_STOP_D1 : 1;          /*!< [6..6] Option byte erase after D1 DStop option configuration
                                                     bit                                                                       */
      __IOM uint32_t nRST_STBY_D1 : 1;          /*!< [7..7] Option byte erase after D1 DStandby option configuration
                                                     bit                                                                       */
      __IOM uint32_t RDP        : 8;            /*!< [15..8] Readout protection level option configuration byte                */
            uint32_t            : 1;
      __IOM uint32_t FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option configuration bit                   */
      __IOM uint32_t FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option configuration bit                */
      __IOM uint32_t ST_RAM_SIZE : 2;           /*!< [20..19] DTCM size select option configuration bits                       */
      __IOM uint32_t SECURITY   : 1;            /*!< [21..21] Security option configuration bit                                */
            uint32_t            : 4;
      __IOM uint32_t RSS1       : 1;            /*!< [26..26] User option configuration bit 1                                  */
      __IOM uint32_t RSS2       : 1;            /*!< [27..27] User option configuration bit 2                                  */
            uint32_t            : 1;
      __IOM uint32_t IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage (PRODUCT_BELOW_25V)                */
            uint32_t            : 1;
      __IOM uint32_t SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option configuration bit                           */
    } OPTSR_PRG_b;
  } ;
  
  union {
    __OM  uint32_t OPTCCR;                      /*!< (@ 0x00000024) FLASH option clear control register                        */
    
    struct {
            uint32_t            : 30;
      __OM  uint32_t CLR_OPTCHANGEERR : 1;      /*!< [30..30] OPTCHANGEERR reset bit                                           */
            uint32_t            : 1;
    } OPTCCR_b;
  } ;
  
  union {
    __IM  uint32_t PRAR_CUR1;                   /*!< (@ 0x00000028) FLASH protection address for bank 1                        */
    
    struct {
      __IM  uint32_t PROT_AREA_START1 : 12;     /*!< [11..0] Bank 1 lowest PCROP protected address                             */
            uint32_t            : 4;
      __IM  uint32_t PROT_AREA_END1 : 12;       /*!< [27..16] Bank 1 highest PCROP protected address                           */
            uint32_t            : 3;
      __IM  uint32_t DMEP1      : 1;            /*!< [31..31] Bank 1 PCROP protected erase enable option status bit            */
    } PRAR_CUR1_b;
  } ;
  
  union {
    union {
      __IOM uint32_t PRAR_PRG1;                 /*!< (@ 0x0000002C) FLASH protection address for bank 1                        */
      
      struct {
        __IOM uint32_t PROT_AREA_START1 : 12;   /*!< [11..0] Bank 1 lowest PCROP protected address configuration               */
              uint32_t          : 4;
        __IOM uint32_t PROT_AREA_END1 : 12;     /*!< [27..16] Bank 1 highest PCROP protected address configuration             */
              uint32_t          : 3;
        __IOM uint32_t DMEP1    : 1;            /*!< [31..31] Bank 1 PCROP protected erase enable option configuration
                                                     bit                                                                       */
      } PRAR_PRG1_b;
    } ;
    
    union {
      __IOM uint32_t PRAR_PRG2;                 /*!< (@ 0x0000002C) FLASH protection address for bank 2                        */
      
      struct {
        __IOM uint32_t PROT_AREA_START2 : 12;   /*!< [11..0] Bank 2 lowest PCROP protected address configuration               */
              uint32_t          : 4;
        __IOM uint32_t PROT_AREA_END2 : 12;     /*!< [27..16] Bank 2 highest PCROP protected address configuration             */
              uint32_t          : 3;
        __IOM uint32_t DMEP2    : 1;            /*!< [31..31] Bank 2 PCROP protected erase enable option configuration
                                                     bit                                                                       */
      } PRAR_PRG2_b;
    } ;
  };
  
  union {
    __IOM uint32_t SCAR_CUR1;                   /*!< (@ 0x00000030) FLASH secure address for bank 1                            */
    
    struct {
      __IOM uint32_t SEC_AREA_START1 : 12;      /*!< [11..0] Bank 1 lowest secure protected address                            */
            uint32_t            : 4;
      __IOM uint32_t SEC_AREA_END1 : 12;        /*!< [27..16] Bank 1 highest secure protected address                          */
            uint32_t            : 3;
      __IOM uint32_t DMES1      : 1;            /*!< [31..31] Bank 1 secure protected erase enable option status
                                                     bit                                                                       */
    } SCAR_CUR1_b;
  } ;
  
  union {
    __IOM uint32_t SCAR_PRG1;                   /*!< (@ 0x00000034) FLASH secure address for bank 1                            */
    
    struct {
      __IOM uint32_t SEC_AREA_START1 : 12;      /*!< [11..0] Bank 1 lowest secure protected address configuration              */
            uint32_t            : 4;
      __IOM uint32_t SEC_AREA_END1 : 12;        /*!< [27..16] Bank 1 highest secure protected address configuration            */
            uint32_t            : 3;
      __IOM uint32_t DMES1      : 1;            /*!< [31..31] Bank 1 secure protected erase enable option configuration
                                                     bit                                                                       */
    } SCAR_PRG1_b;
  } ;
  
  union {
    __IM  uint32_t WPSN_CUR1R;                  /*!< (@ 0x00000038) FLASH write sector protection for bank 1                   */
    
    struct {
      __IM  uint32_t WRPSn1     : 8;            /*!< [7..0] Bank 1 sector write protection option status byte                  */
            uint32_t            : 24;
    } WPSN_CUR1R_b;
  } ;
  
  union {
    __IOM uint32_t WPSN_PRG1R;                  /*!< (@ 0x0000003C) FLASH write sector protection for bank 1                   */
    
    struct {
      __IOM uint32_t WRPSn1     : 8;            /*!< [7..0] Bank 1 sector write protection configuration byte                  */
            uint32_t            : 24;
    } WPSN_PRG1R_b;
  } ;
  
  union {
    __IM  uint32_t BOOT_CURR;                   /*!< (@ 0x00000040) FLASH register with boot address                           */
    
    struct {
      __IM  uint32_t BOOT_ADD0  : 16;           /*!< [15..0] Boot address 0                                                    */
      __IM  uint32_t BOOT_ADD1  : 16;           /*!< [31..16] Boot address 1                                                   */
    } BOOT_CURR_b;
  } ;
  
  union {
    __IM  uint32_t BOOT_PRGR;                   /*!< (@ 0x00000044) FLASH register with boot address                           */
    
    struct {
      __IM  uint32_t BOOT_ADD0  : 16;           /*!< [15..0] Boot address 0                                                    */
      __IM  uint32_t BOOT_ADD1  : 16;           /*!< [31..16] Boot address 1                                                   */
    } BOOT_PRGR_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t CRCCR1;                      /*!< (@ 0x00000050) FLASH CRC control register for bank 1                      */
    
    struct {
      __IOM uint32_t CRC_SECT   : 3;            /*!< [2..0] Bank 1 CRC sector number                                           */
            uint32_t            : 4;
      __IOM uint32_t ALL_BANK   : 1;            /*!< [7..7] Bank 1 CRC select bit                                              */
      __IOM uint32_t CRC_BY_SECT : 1;           /*!< [8..8] Bank 1 CRC sector mode select bit                                  */
      __IOM uint32_t ADD_SECT   : 1;            /*!< [9..9] Bank 1 CRC sector select bit                                       */
      __IOM uint32_t CLEAN_SECT : 1;            /*!< [10..10] Bank 1 CRC sector list clear bit                                 */
            uint32_t            : 5;
      __IOM uint32_t START_CRC  : 1;            /*!< [16..16] Bank 1 CRC start bit                                             */
      __IOM uint32_t CLEAN_CRC  : 1;            /*!< [17..17] Bank 1 CRC clear bit                                             */
            uint32_t            : 2;
      __IOM uint32_t CRC_BURST  : 2;            /*!< [21..20] Bank 1 CRC burst size                                            */
            uint32_t            : 10;
    } CRCCR1_b;
  } ;
  
  union {
    __IOM uint32_t CRCSADD1R;                   /*!< (@ 0x00000054) FLASH CRC start address register for bank 1                */
    
    struct {
      __IOM uint32_t CRC_START_ADDR : 32;       /*!< [31..0] CRC start address on bank 1                                       */
    } CRCSADD1R_b;
  } ;
  
  union {
    __IOM uint32_t CRCEADD1R;                   /*!< (@ 0x00000058) FLASH CRC end address register for bank 1                  */
    
    struct {
      __IOM uint32_t CRC_END_ADDR : 32;         /*!< [31..0] CRC end address on bank 1                                         */
    } CRCEADD1R_b;
  } ;
  
  union {
    __IOM uint32_t CRCDATAR;                    /*!< (@ 0x0000005C) FLASH CRC data register                                    */
    
    struct {
      __IOM uint32_t CRC_DATA   : 32;           /*!< [31..0] CRC result                                                        */
    } CRCDATAR_b;
  } ;
  
  union {
    __IM  uint32_t ECC_FA1R;                    /*!< (@ 0x00000060) FLASH ECC fail address for bank 1                          */
    
    struct {
      __IM  uint32_t FAIL_ECC_ADDR1 : 15;       /*!< [14..0] Bank 1 ECC error address                                          */
            uint32_t            : 17;
    } ECC_FA1R_b;
  } ;
  __IM  uint32_t  RESERVED1[39];
  
  union {
    __IOM uint32_t ACR_;                        /*!< (@ 0x00000100) Access control register                                    */
    
    struct {
      __IOM uint32_t LATENCY    : 3;            /*!< [2..0] Read latency                                                       */
            uint32_t            : 1;
      __IOM uint32_t WRHIGHFREQ : 2;            /*!< [5..4] Flash signal delay                                                 */
            uint32_t            : 26;
    } ACR__b;
  } ;
  
  union {
    __IM  uint32_t KEYR2;                       /*!< (@ 0x00000104) FLASH key register for bank 2                              */
    
    struct {
      __IM  uint32_t KEYR2      : 32;           /*!< [31..0] Bank 2 access configuration unlock key                            */
    } KEYR2_b;
  } ;
  
  union {
    __IOM uint32_t OPTKEYR_;                    /*!< (@ 0x00000108) FLASH option key register                                  */
    
    struct {
      __IOM uint32_t OPTKEYR    : 32;           /*!< [31..0] Unlock key option bytes                                           */
    } OPTKEYR__b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x0000010C) FLASH control register for bank 2                          */
    
    struct {
      __IOM uint32_t LOCK2      : 1;            /*!< [0..0] Bank 2 configuration lock bit                                      */
      __IOM uint32_t PG2        : 1;            /*!< [1..1] Bank 2 program enable bit                                          */
      __IOM uint32_t SER2       : 1;            /*!< [2..2] Bank 2 sector erase request                                        */
      __IOM uint32_t BER2       : 1;            /*!< [3..3] Bank 2 erase request                                               */
      __IOM uint32_t PSIZE2     : 2;            /*!< [5..4] Bank 2 program size                                                */
      __IOM uint32_t FW2        : 1;            /*!< [6..6] Bank 2 write forcing control bit                                   */
      __IOM uint32_t START2     : 1;            /*!< [7..7] Bank 2 bank or sector erase start control bit                      */
      __IOM uint32_t SNB2       : 3;            /*!< [10..8] Bank 2 sector erase selection number                              */
            uint32_t            : 4;
      __IOM uint32_t CRC_EN     : 1;            /*!< [15..15] Bank 2 CRC control bit                                           */
      __IOM uint32_t EOPIE2     : 1;            /*!< [16..16] Bank 2 end-of-program interrupt control bit                      */
      __IOM uint32_t WRPERRIE2  : 1;            /*!< [17..17] Bank 2 write protection error interrupt enable bit               */
      __IOM uint32_t PGSERRIE2  : 1;            /*!< [18..18] Bank 2 programming sequence error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t STRBERRIE2 : 1;            /*!< [19..19] Bank 2 strobe error interrupt enable bit                         */
            uint32_t            : 1;
      __IOM uint32_t INCERRIE2  : 1;            /*!< [21..21] Bank 2 inconsistency error interrupt enable bit                  */
      __IOM uint32_t OPERRIE2   : 1;            /*!< [22..22] Bank 2 write/erase error interrupt enable bit                    */
      __IOM uint32_t RDPERRIE2  : 1;            /*!< [23..23] Bank 2 read protection error interrupt enable bit                */
      __IOM uint32_t RDSERRIE2  : 1;            /*!< [24..24] Bank 2 secure error interrupt enable bit                         */
      __IOM uint32_t SNECCERRIE2 : 1;           /*!< [25..25] Bank 2 ECC single correction error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t DBECCERRIE2 : 1;           /*!< [26..26] Bank 2 ECC double detection error interrupt enable
                                                     bit                                                                       */
      __IOM uint32_t CRCENDIE2  : 1;            /*!< [27..27] Bank 2 end of CRC calculation interrupt enable bit               */
            uint32_t            : 4;
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t SR2;                         /*!< (@ 0x00000110) FLASH status register for bank 2                           */
    
    struct {
      __IOM uint32_t BSY2       : 1;            /*!< [0..0] Bank 2 ongoing program flag                                        */
      __IOM uint32_t WBNE2      : 1;            /*!< [1..1] Bank 2 write buffer not empty flag                                 */
      __IOM uint32_t QW2        : 1;            /*!< [2..2] Bank 2 wait queue flag                                             */
      __IOM uint32_t CRC_BUSY2  : 1;            /*!< [3..3] Bank 2 CRC busy flag                                               */
            uint32_t            : 12;
      __IOM uint32_t EOP2       : 1;            /*!< [16..16] Bank 2 end-of-program flag                                       */
      __IOM uint32_t WRPERR2    : 1;            /*!< [17..17] Bank 2 write protection error flag                               */
      __IOM uint32_t PGSERR2    : 1;            /*!< [18..18] Bank 2 programming sequence error flag                           */
      __IOM uint32_t STRBERR2   : 1;            /*!< [19..19] Bank 2 strobe error flag                                         */
            uint32_t            : 1;
      __IOM uint32_t INCERR2    : 1;            /*!< [21..21] Bank 2 inconsistency error flag                                  */
      __IOM uint32_t OPERR2     : 1;            /*!< [22..22] Bank 2 write/erase error flag                                    */
      __IOM uint32_t RDPERR2    : 1;            /*!< [23..23] Bank 2 read protection error flag                                */
      __IOM uint32_t RDSERR2    : 1;            /*!< [24..24] Bank 2 secure error flag                                         */
      __IOM uint32_t SNECCERR2  : 1;            /*!< [25..25] Bank 2 single correction error flag                              */
      __IOM uint32_t DBECCERR2  : 1;            /*!< [26..26] Bank 2 ECC double detection error flag                           */
      __IOM uint32_t CRCEND2    : 1;            /*!< [27..27] Bank 2 CRC-complete flag                                         */
            uint32_t            : 4;
    } SR2_b;
  } ;
  
  union {
    __IOM uint32_t CCR2;                        /*!< (@ 0x00000114) FLASH clear control register for bank 2                    */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t CLR_EOP2   : 1;            /*!< [16..16] Bank 1 EOP1 flag clear bit                                       */
      __IOM uint32_t CLR_WRPERR2 : 1;           /*!< [17..17] Bank 2 WRPERR1 flag clear bit                                    */
      __IOM uint32_t CLR_PGSERR2 : 1;           /*!< [18..18] Bank 2 PGSERR1 flag clear bi                                     */
      __IOM uint32_t CLR_STRBERR2 : 1;          /*!< [19..19] Bank 2 STRBERR1 flag clear bit                                   */
            uint32_t            : 1;
      __IOM uint32_t CLR_INCERR2 : 1;           /*!< [21..21] Bank 2 INCERR1 flag clear bit                                    */
      __IOM uint32_t CLR_OPERR2 : 1;            /*!< [22..22] Bank 2 OPERR1 flag clear bit                                     */
      __IOM uint32_t CLR_RDPERR2 : 1;           /*!< [23..23] Bank 2 RDPERR1 flag clear bit                                    */
      __IOM uint32_t CLR_RDSERR1 : 1;           /*!< [24..24] Bank 1 RDSERR1 flag clear bit                                    */
      __IOM uint32_t CLR_SNECCERR2 : 1;         /*!< [25..25] Bank 2 SNECCERR1 flag clear bit                                  */
      __IOM uint32_t CLR_DBECCERR1 : 1;         /*!< [26..26] Bank 1 DBECCERR1 flag clear bit                                  */
      __IOM uint32_t CLR_CRCEND2 : 1;           /*!< [27..27] Bank 2 CRCEND1 flag clear bit                                    */
            uint32_t            : 4;
    } CCR2_b;
  } ;
  
  union {
    __IOM uint32_t OPTCR_;                      /*!< (@ 0x00000118) FLASH option control register                              */
    
    struct {
      __IOM uint32_t OPTLOCK    : 1;            /*!< [0..0] FLASH_OPTCR lock option configuration bit                          */
      __IOM uint32_t OPTSTART   : 1;            /*!< [1..1] Option byte start change option configuration bit                  */
            uint32_t            : 2;
      __IOM uint32_t MER        : 1;            /*!< [4..4] Flash mass erase enable bit                                        */
            uint32_t            : 25;
      __IOM uint32_t OPTCHANGEERRIE : 1;        /*!< [30..30] Option byte change error interrupt enable bit                    */
      __IOM uint32_t SWAP_BANK  : 1;            /*!< [31..31] Bank swapping configuration bit                                  */
    } OPTCR__b;
  } ;
  
  union {
    __IOM uint32_t OPTSR_CUR_;                  /*!< (@ 0x0000011C) FLASH option status register                               */
    
    struct {
      __IOM uint32_t OPT_BUSY   : 1;            /*!< [0..0] Option byte change ongoing flag                                    */
            uint32_t            : 1;
      __IOM uint32_t BOR_LEV    : 2;            /*!< [3..2] Brownout level option status bit                                   */
      __IOM uint32_t IWDG1_HW   : 1;            /*!< [4..4] IWDG1 control option status bit                                    */
            uint32_t            : 1;
      __IOM uint32_t nRST_STOP_D1 : 1;          /*!< [6..6] D1 DStop entry reset option status bit                             */
      __IOM uint32_t nRST_STBY_D1 : 1;          /*!< [7..7] D1 DStandby entry reset option status bit                          */
      __IOM uint32_t RDP        : 8;            /*!< [15..8] Readout protection level option status byte                       */
            uint32_t            : 1;
      __IOM uint32_t FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option status bit                          */
      __IOM uint32_t FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option status bit                       */
      __IOM uint32_t ST_RAM_SIZE : 2;           /*!< [20..19] DTCM RAM size option status                                      */
      __IOM uint32_t SECURITY   : 1;            /*!< [21..21] Security enable option status bit                                */
            uint32_t            : 4;
      __IOM uint32_t RSS1       : 1;            /*!< [26..26] User option bit 1                                                */
            uint32_t            : 1;
      __IOM uint32_t PERSO_OK   : 1;            /*!< [28..28] Device personalization status bit                                */
      __IOM uint32_t IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)     */
      __IOM uint32_t OPTCHANGEERR : 1;          /*!< [30..30] Option byte change error flag                                    */
      __IOM uint32_t SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option status bit                                  */
    } OPTSR_CUR__b;
  } ;
  
  union {
    __IOM uint32_t OPTSR_PRG_;                  /*!< (@ 0x00000120) FLASH option status register                               */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t BOR_LEV    : 2;            /*!< [3..2] BOR reset level option configuration bits                          */
      __IOM uint32_t IWDG1_HW   : 1;            /*!< [4..4] IWDG1 option configuration bit                                     */
            uint32_t            : 1;
      __IOM uint32_t nRST_STOP_D1 : 1;          /*!< [6..6] Option byte erase after D1 DStop option configuration
                                                     bit                                                                       */
      __IOM uint32_t nRST_STBY_D1 : 1;          /*!< [7..7] Option byte erase after D1 DStandby option configuration
                                                     bit                                                                       */
      __IOM uint32_t RDP        : 8;            /*!< [15..8] Readout protection level option configuration byte                */
            uint32_t            : 1;
      __IOM uint32_t FZ_IWDG_STOP : 1;          /*!< [17..17] IWDG Stop mode freeze option configuration bit                   */
      __IOM uint32_t FZ_IWDG_SDBY : 1;          /*!< [18..18] IWDG Standby mode freeze option configuration bit                */
      __IOM uint32_t ST_RAM_SIZE : 2;           /*!< [20..19] DTCM size select option configuration bits                       */
      __IOM uint32_t SECURITY   : 1;            /*!< [21..21] Security option configuration bit                                */
            uint32_t            : 4;
      __IOM uint32_t RSS1       : 1;            /*!< [26..26] User option configuration bit 1                                  */
      __IOM uint32_t RSS2       : 1;            /*!< [27..27] User option configuration bit 2                                  */
            uint32_t            : 1;
      __IOM uint32_t IO_HSLV    : 1;            /*!< [29..29] I/O high-speed at low-voltage (PRODUCT_BELOW_25V)                */
            uint32_t            : 1;
      __IOM uint32_t SWAP_BANK_OPT : 1;         /*!< [31..31] Bank swapping option configuration bit                           */
    } OPTSR_PRG__b;
  } ;
  
  union {
    __OM  uint32_t OPTCCR_;                     /*!< (@ 0x00000124) FLASH option clear control register                        */
    
    struct {
            uint32_t            : 30;
      __OM  uint32_t CLR_OPTCHANGEERR : 1;      /*!< [30..30] OPTCHANGEERR reset bit                                           */
            uint32_t            : 1;
    } OPTCCR__b;
  } ;
  
  union {
    __IM  uint32_t PRAR_CUR2;                   /*!< (@ 0x00000128) FLASH protection address for bank 1                        */
    
    struct {
      __IM  uint32_t PROT_AREA_START2 : 12;     /*!< [11..0] Bank 2 lowest PCROP protected address                             */
            uint32_t            : 4;
      __IM  uint32_t PROT_AREA_END2 : 12;       /*!< [27..16] Bank 2 highest PCROP protected address                           */
            uint32_t            : 3;
      __IM  uint32_t DMEP2      : 1;            /*!< [31..31] Bank 2 PCROP protected erase enable option status bit            */
    } PRAR_CUR2_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t SCAR_CUR2;                   /*!< (@ 0x00000130) FLASH secure address for bank 2                            */
    
    struct {
      __IOM uint32_t SEC_AREA_START2 : 12;      /*!< [11..0] Bank 2 lowest secure protected address                            */
            uint32_t            : 4;
      __IOM uint32_t SEC_AREA_END2 : 12;        /*!< [27..16] Bank 2 highest secure protected address                          */
            uint32_t            : 3;
      __IOM uint32_t DMES2      : 1;            /*!< [31..31] Bank 2 secure protected erase enable option status
                                                     bit                                                                       */
    } SCAR_CUR2_b;
  } ;
  
  union {
    __IOM uint32_t SCAR_PRG2;                   /*!< (@ 0x00000134) FLASH secure address for bank 2                            */
    
    struct {
      __IOM uint32_t SEC_AREA_START2 : 12;      /*!< [11..0] Bank 2 lowest secure protected address configuration              */
            uint32_t            : 4;
      __IOM uint32_t SEC_AREA_END2 : 12;        /*!< [27..16] Bank 2 highest secure protected address configuration            */
            uint32_t            : 3;
      __IOM uint32_t DMES2      : 1;            /*!< [31..31] Bank 2 secure protected erase enable option configuration
                                                     bit                                                                       */
    } SCAR_PRG2_b;
  } ;
  
  union {
    __IM  uint32_t WPSN_CUR2R;                  /*!< (@ 0x00000138) FLASH write sector protection for bank 2                   */
    
    struct {
      __IM  uint32_t WRPSn2     : 8;            /*!< [7..0] Bank 2 sector write protection option status byte                  */
            uint32_t            : 24;
    } WPSN_CUR2R_b;
  } ;
  
  union {
    __IOM uint32_t WPSN_PRG2R;                  /*!< (@ 0x0000013C) FLASH write sector protection for bank 2                   */
    
    struct {
      __IOM uint32_t WRPSn2     : 8;            /*!< [7..0] Bank 2 sector write protection configuration byte                  */
            uint32_t            : 24;
    } WPSN_PRG2R_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t CRCCR2;                      /*!< (@ 0x00000150) FLASH CRC control register for bank 1                      */
    
    struct {
      __IOM uint32_t CRC_SECT   : 3;            /*!< [2..0] Bank 2 CRC sector number                                           */
            uint32_t            : 4;
      __IOM uint32_t ALL_BANK   : 1;            /*!< [7..7] Bank 2 CRC select bit                                              */
      __IOM uint32_t CRC_BY_SECT : 1;           /*!< [8..8] Bank 2 CRC sector mode select bit                                  */
      __IOM uint32_t ADD_SECT   : 1;            /*!< [9..9] Bank 2 CRC sector select bit                                       */
      __IOM uint32_t CLEAN_SECT : 1;            /*!< [10..10] Bank 2 CRC sector list clear bit                                 */
            uint32_t            : 5;
      __IOM uint32_t START_CRC  : 1;            /*!< [16..16] Bank 2 CRC start bit                                             */
      __IOM uint32_t CLEAN_CRC  : 1;            /*!< [17..17] Bank 2 CRC clear bit                                             */
            uint32_t            : 2;
      __IOM uint32_t CRC_BURST  : 2;            /*!< [21..20] Bank 2 CRC burst size                                            */
            uint32_t            : 10;
    } CRCCR2_b;
  } ;
  
  union {
    __IOM uint32_t CRCSADD2R;                   /*!< (@ 0x00000154) FLASH CRC start address register for bank 2                */
    
    struct {
      __IOM uint32_t CRC_START_ADDR : 32;       /*!< [31..0] CRC start address on bank 2                                       */
    } CRCSADD2R_b;
  } ;
  
  union {
    __IOM uint32_t CRCEADD2R;                   /*!< (@ 0x00000158) FLASH CRC end address register for bank 2                  */
    
    struct {
      __IOM uint32_t CRC_END_ADDR : 32;         /*!< [31..0] CRC end address on bank 2                                         */
    } CRCEADD2R_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IM  uint32_t ECC_FA2R;                    /*!< (@ 0x00000160) FLASH ECC fail address for bank 2                          */
    
    struct {
      __IM  uint32_t FAIL_ECC_ADDR2 : 15;       /*!< [14..0] Bank 2 ECC error address                                          */
            uint32_t            : 17;
    } ECC_FA2R_b;
  } ;
} Flash_Type;                                   /*!< Size = 356 (0x164)                                                        */



/* =========================================================================================================================== */
/* ================                                            AXI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AXI interconnect registers (AXI)
  */

typedef struct {                                /*!< (@ 0x51000000) AXI Structure                                              */
  __IM  uint32_t  RESERVED[2036];
  
  union {
    __IM  uint32_t AXI_PERIPH_ID_4;             /*!< (@ 0x00001FD0) AXI interconnect - peripheral ID4 register                 */
    
    struct {
      __IM  uint32_t JEP106CON  : 4;            /*!< [3..0] JEP106 continuation code                                           */
      __IM  uint32_t KCOUNT4    : 4;            /*!< [7..4] Register file size                                                 */
            uint32_t            : 24;
    } AXI_PERIPH_ID_4_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IM  uint32_t AXI_PERIPH_ID_0;             /*!< (@ 0x00001FE0) AXI interconnect - peripheral ID0 register                 */
    
    struct {
      __IM  uint32_t PARTNUM    : 8;            /*!< [7..0] Peripheral part number bits 0 to 7                                 */
            uint32_t            : 24;
    } AXI_PERIPH_ID_0_b;
  } ;
  
  union {
    __IM  uint32_t AXI_PERIPH_ID_1;             /*!< (@ 0x00001FE4) AXI interconnect - peripheral ID1 register                 */
    
    struct {
      __IM  uint32_t PARTNUM    : 4;            /*!< [3..0] Peripheral part number bits 8 to 11                                */
      __IM  uint32_t JEP106I    : 4;            /*!< [7..4] JEP106 identity bits 0 to 3                                        */
            uint32_t            : 24;
    } AXI_PERIPH_ID_1_b;
  } ;
  
  union {
    __IM  uint32_t AXI_PERIPH_ID_2;             /*!< (@ 0x00001FE8) AXI interconnect - peripheral ID2 register                 */
    
    struct {
      __IM  uint32_t JEP106ID   : 3;            /*!< [2..0] JEP106 Identity bits 4 to 6                                        */
      __IM  uint32_t JEDEC      : 1;            /*!< [3..3] JEP106 code flag                                                   */
      __IM  uint32_t REVISION   : 4;            /*!< [7..4] Peripheral revision number                                         */
            uint32_t            : 24;
    } AXI_PERIPH_ID_2_b;
  } ;
  
  union {
    __IM  uint32_t AXI_PERIPH_ID_3;             /*!< (@ 0x00001FEC) AXI interconnect - peripheral ID3 register                 */
    
    struct {
      __IM  uint32_t CUST_MOD_NUM : 4;          /*!< [3..0] Customer modification                                              */
      __IM  uint32_t REV_AND    : 4;            /*!< [7..4] Customer version                                                   */
            uint32_t            : 24;
    } AXI_PERIPH_ID_3_b;
  } ;
  
  union {
    __IM  uint32_t AXI_COMP_ID_0;               /*!< (@ 0x00001FF0) AXI interconnect - component ID0 register                  */
    
    struct {
      __IM  uint32_t PREAMBLE   : 8;            /*!< [7..0] Preamble bits 0 to 7                                               */
            uint32_t            : 24;
    } AXI_COMP_ID_0_b;
  } ;
  
  union {
    __IM  uint32_t AXI_COMP_ID_1;               /*!< (@ 0x00001FF4) AXI interconnect - component ID1 register                  */
    
    struct {
      __IM  uint32_t PREAMBLE   : 4;            /*!< [3..0] Preamble bits 8 to 11                                              */
      __IM  uint32_t CLASS      : 4;            /*!< [7..4] Component class                                                    */
            uint32_t            : 24;
    } AXI_COMP_ID_1_b;
  } ;
  
  union {
    __IM  uint32_t AXI_COMP_ID_2;               /*!< (@ 0x00001FF8) AXI interconnect - component ID2 register                  */
    
    struct {
      __IM  uint32_t PREAMBLE   : 8;            /*!< [7..0] Preamble bits 12 to 19                                             */
            uint32_t            : 24;
    } AXI_COMP_ID_2_b;
  } ;
  
  union {
    __IM  uint32_t AXI_COMP_ID_3;               /*!< (@ 0x00001FFC) AXI interconnect - component ID3 register                  */
    
    struct {
      __IM  uint32_t PREAMBLE   : 8;            /*!< [7..0] Preamble bits 20 to 27                                             */
            uint32_t            : 24;
    } AXI_COMP_ID_3_b;
  } ;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t AXI_TARG1_FN_MOD_ISS_BM;     /*!< (@ 0x00002008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG1_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED3[6];
  
  union {
    __IOM uint32_t AXI_TARG1_FN_MOD2;           /*!< (@ 0x00002024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32_t BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32_t            : 31;
    } AXI_TARG1_FN_MOD2_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t AXI_TARG1_FN_MOD_LB;         /*!< (@ 0x0000202C) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32_t FN_MOD_LB  : 1;            /*!< [0..0] Controls burst breaking of long bursts                             */
            uint32_t            : 31;
    } AXI_TARG1_FN_MOD_LB_b;
  } ;
  __IM  uint32_t  RESERVED5[54];
  
  union {
    __IOM uint32_t AXI_TARG1_FN_MOD;            /*!< (@ 0x00002108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_TARG1_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED6[959];
  
  union {
    __IOM uint32_t AXI_TARG2_FN_MOD_ISS_BM;     /*!< (@ 0x00003008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG2_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED7[6];
  
  union {
    __IOM uint32_t AXI_TARG2_FN_MOD2;           /*!< (@ 0x00003024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32_t BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32_t            : 31;
    } AXI_TARG2_FN_MOD2_b;
  } ;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IOM uint32_t AXI_TARG2_FN_MOD_LB;         /*!< (@ 0x0000302C) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32_t FN_MOD_LB  : 1;            /*!< [0..0] Controls burst breaking of long bursts                             */
            uint32_t            : 31;
    } AXI_TARG2_FN_MOD_LB_b;
  } ;
  __IM  uint32_t  RESERVED9[54];
  
  union {
    __IOM uint32_t AXI_TARG2_FN_MOD;            /*!< (@ 0x00003108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_TARG2_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED10[959];
  
  union {
    __IOM uint32_t AXI_TARG3_FN_MOD_ISS_BM;     /*!< (@ 0x00004008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG3_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED11[1023];
  
  union {
    __IOM uint32_t AXI_TARG4_FN_MOD_ISS_BM;     /*!< (@ 0x00005008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG4_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED12[1023];
  
  union {
    __IOM uint32_t AXI_TARG5_FN_MOD_ISS_BM;     /*!< (@ 0x00006008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG5_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED13[1023];
  
  union {
    __IOM uint32_t AXI_TARG6_FN_MOD_ISS_BM;     /*!< (@ 0x00007008) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG6_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED14[1024];
  
  union {
    __IOM uint32_t AXI_TARG7_FN_MOD_ISS_BM;     /*!< (@ 0x0000800C) AXI interconnect - TARG x bus matrix issuing
                                                                    functionality register                                     */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] READ_ISS_OVERRIDE                                                  */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Switch matrix write issuing override for target                    */
            uint32_t            : 30;
    } AXI_TARG7_FN_MOD_ISS_BM_b;
  } ;
  __IM  uint32_t  RESERVED15[5];
  
  union {
    __IOM uint32_t AXI_TARG7_FN_MOD2;           /*!< (@ 0x00008024) AXI interconnect - TARG x bus matrix functionality
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32_t BYPASS_MERGE : 1;          /*!< [0..0] Disable packing of beats to match the output data width            */
            uint32_t            : 31;
    } AXI_TARG7_FN_MOD2_b;
  } ;
  __IM  uint32_t  RESERVED16[56];
  
  union {
    __IOM uint32_t AXI_TARG7_FN_MOD;            /*!< (@ 0x00008108) AXI interconnect - TARG x long burst functionality
                                                                    modification                                               */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override AMIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override AMIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_TARG7_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED17[59334];
  
  union {
    __IOM uint32_t AXI_INI1_FN_MOD2;            /*!< (@ 0x00042024) AXI interconnect - INI x functionality modification
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32_t BYPASS_MERGE : 1;          /*!< [0..0] Disables alteration of transactions by the up-sizer unless
                                                     required by the protocol                                                  */
            uint32_t            : 31;
    } AXI_INI1_FN_MOD2_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI1_FN_MOD_AHB;         /*!< (@ 0x00042028) AXI interconnect - INI x AHB functionality modification
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t RD_INC_OVERRIDE : 1;       /*!< [0..0] Converts all AHB-Lite write transactions to a series
                                                     of single beat AXI                                                        */
      __IOM uint32_t WR_INC_OVERRIDE : 1;       /*!< [1..1] Converts all AHB-Lite read transactions to a series of
                                                     single beat AXI                                                           */
            uint32_t            : 30;
    } AXI_INI1_FN_MOD_AHB_b;
  } ;
  __IM  uint32_t  RESERVED18[53];
  
  union {
    __IOM uint32_t AXI_INI1_READ_QOS;           /*!< (@ 0x00042100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI1_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI1_WRITE_QOS;          /*!< (@ 0x00042104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI1_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI1_FN_MOD;             /*!< (@ 0x00042108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI1_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED19[1021];
  
  union {
    __IOM uint32_t AXI_INI2_READ_QOS;           /*!< (@ 0x00043100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI2_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI2_WRITE_QOS;          /*!< (@ 0x00043104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI2_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI2_FN_MOD;             /*!< (@ 0x00043108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI2_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED20[966];
  
  union {
    __IOM uint32_t AXI_INI3_FN_MOD2;            /*!< (@ 0x00044024) AXI interconnect - INI x functionality modification
                                                                    2 register                                                 */
    
    struct {
      __IOM uint32_t BYPASS_MERGE : 1;          /*!< [0..0] Disables alteration of transactions by the up-sizer unless
                                                     required by the protocol                                                  */
            uint32_t            : 31;
    } AXI_INI3_FN_MOD2_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI3_FN_MOD_AHB;         /*!< (@ 0x00044028) AXI interconnect - INI x AHB functionality modification
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t RD_INC_OVERRIDE : 1;       /*!< [0..0] Converts all AHB-Lite write transactions to a series
                                                     of single beat AXI                                                        */
      __IOM uint32_t WR_INC_OVERRIDE : 1;       /*!< [1..1] Converts all AHB-Lite read transactions to a series of
                                                     single beat AXI                                                           */
            uint32_t            : 30;
    } AXI_INI3_FN_MOD_AHB_b;
  } ;
  __IM  uint32_t  RESERVED21[53];
  
  union {
    __IOM uint32_t AXI_INI3_READ_QOS;           /*!< (@ 0x00044100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI3_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI3_WRITE_QOS;          /*!< (@ 0x00044104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI3_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI3_FN_MOD;             /*!< (@ 0x00044108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI3_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED22[1021];
  
  union {
    __IOM uint32_t AXI_INI4_READ_QOS;           /*!< (@ 0x00045100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI4_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI4_WRITE_QOS;          /*!< (@ 0x00045104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI4_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI4_FN_MOD;             /*!< (@ 0x00045108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI4_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED23[1021];
  
  union {
    __IOM uint32_t AXI_INI5_READ_QOS;           /*!< (@ 0x00046100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI5_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI5_WRITE_QOS;          /*!< (@ 0x00046104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI5_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI5_FN_MOD;             /*!< (@ 0x00046108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI5_FN_MOD_b;
  } ;
  __IM  uint32_t  RESERVED24[1021];
  
  union {
    __IOM uint32_t AXI_INI6_READ_QOS;           /*!< (@ 0x00047100) AXI interconnect - INI x read QoS register                 */
    
    struct {
      __IOM uint32_t AR_QOS     : 4;            /*!< [3..0] Read channel QoS setting                                           */
            uint32_t            : 28;
    } AXI_INI6_READ_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI6_WRITE_QOS;          /*!< (@ 0x00047104) AXI interconnect - INI x write QoS register                */
    
    struct {
      __IOM uint32_t AW_QOS     : 4;            /*!< [3..0] Write channel QoS setting                                          */
            uint32_t            : 28;
    } AXI_INI6_WRITE_QOS_b;
  } ;
  
  union {
    __IOM uint32_t AXI_INI6_FN_MOD;             /*!< (@ 0x00047108) AXI interconnect - INI x issuing functionality
                                                                    modification register                                      */
    
    struct {
      __IOM uint32_t READ_ISS_OVERRIDE : 1;     /*!< [0..0] Override ASIB read issuing capability                              */
      __IOM uint32_t WRITE_ISS_OVERRIDE : 1;    /*!< [1..1] Override ASIB write issuing capability                             */
            uint32_t            : 30;
    } AXI_INI6_FN_MOD_b;
  } ;
} AXI_Type;                                     /*!< Size = 291084 (0x4710c)                                                   */



/* =========================================================================================================================== */
/* ================                                           HASH                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Hash processor (HASH)
  */

typedef struct {                                /*!< (@ 0x48021400) HASH Structure                                             */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) control register                                           */
    
    struct {
            uint32_t            : 2;
      __OM  uint32_t INIT       : 1;            /*!< [2..2] Initialize message digest calculation                              */
      __IOM uint32_t DMAE       : 1;            /*!< [3..3] DMA enable                                                         */
      __IOM uint32_t DATATYPE   : 2;            /*!< [5..4] Data type selection                                                */
      __IOM uint32_t MODE       : 1;            /*!< [6..6] Mode selection                                                     */
      __IOM uint32_t ALGO0      : 1;            /*!< [7..7] Algorithm selection                                                */
      __IM  uint32_t NBW        : 4;            /*!< [11..8] Number of words already pushed                                    */
      __IM  uint32_t DINNE      : 1;            /*!< [12..12] DIN not empty                                                    */
      __IOM uint32_t MDMAT      : 1;            /*!< [13..13] Multiple DMA Transfers                                           */
            uint32_t            : 2;
      __IOM uint32_t LKEY       : 1;            /*!< [16..16] Long key selection                                               */
            uint32_t            : 1;
      __IOM uint32_t ALGO1      : 1;            /*!< [18..18] ALGO                                                             */
            uint32_t            : 13;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t DIN;                         /*!< (@ 0x00000004) data input register                                        */
    
    struct {
      __IOM uint32_t DATAIN     : 32;           /*!< [31..0] Data input                                                        */
    } DIN_b;
  } ;
  
  union {
    __IOM uint32_t STR;                         /*!< (@ 0x00000008) start register                                             */
    
    struct {
      __IOM uint32_t NBLW       : 5;            /*!< [4..0] Number of valid bits in the last word of the message               */
            uint32_t            : 3;
      __OM  uint32_t DCAL       : 1;            /*!< [8..8] Digest calculation                                                 */
            uint32_t            : 23;
    } STR_b;
  } ;
  
  union {
    __IM  uint32_t HR0;                         /*!< (@ 0x0000000C) digest registers                                           */
    
    struct {
      __IM  uint32_t H0         : 32;           /*!< [31..0] H0                                                                */
    } HR0_b;
  } ;
  
  union {
    __IM  uint32_t HR1;                         /*!< (@ 0x00000010) digest registers                                           */
    
    struct {
      __IM  uint32_t H1         : 32;           /*!< [31..0] H1                                                                */
    } HR1_b;
  } ;
  
  union {
    __IM  uint32_t HR2;                         /*!< (@ 0x00000014) digest registers                                           */
    
    struct {
      __IM  uint32_t H2         : 32;           /*!< [31..0] H2                                                                */
    } HR2_b;
  } ;
  
  union {
    __IM  uint32_t HR3;                         /*!< (@ 0x00000018) digest registers                                           */
    
    struct {
      __IM  uint32_t H3         : 32;           /*!< [31..0] H3                                                                */
    } HR3_b;
  } ;
  
  union {
    __IM  uint32_t HR4;                         /*!< (@ 0x0000001C) digest registers                                           */
    
    struct {
      __IM  uint32_t H4         : 32;           /*!< [31..0] H4                                                                */
    } HR4_b;
  } ;
  
  union {
    __IOM uint32_t IMR;                         /*!< (@ 0x00000020) interrupt enable register                                  */
    
    struct {
      __IOM uint32_t DINIE      : 1;            /*!< [0..0] Data input interrupt enable                                        */
      __IOM uint32_t DCIE       : 1;            /*!< [1..1] Digest calculation completion interrupt enable                     */
            uint32_t            : 30;
    } IMR_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000024) status register                                            */
    
    struct {
      __IOM uint32_t DINIS      : 1;            /*!< [0..0] Data input interrupt status                                        */
      __IOM uint32_t DCIS       : 1;            /*!< [1..1] Digest calculation completion interrupt status                     */
      __IM  uint32_t DMAS       : 1;            /*!< [2..2] DMA Status                                                         */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] Busy bit                                                           */
            uint32_t            : 28;
    } SR_b;
  } ;
  __IM  uint32_t  RESERVED[52];
  
  union {
    __IOM uint32_t CSR0;                        /*!< (@ 0x000000F8) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR0       : 32;           /*!< [31..0] CSR0                                                              */
    } CSR0_b;
  } ;
  
  union {
    __IOM uint32_t CSR1;                        /*!< (@ 0x000000FC) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR1       : 32;           /*!< [31..0] CSR1                                                              */
    } CSR1_b;
  } ;
  
  union {
    __IOM uint32_t CSR2;                        /*!< (@ 0x00000100) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR2       : 32;           /*!< [31..0] CSR2                                                              */
    } CSR2_b;
  } ;
  
  union {
    __IOM uint32_t CSR3;                        /*!< (@ 0x00000104) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR3       : 32;           /*!< [31..0] CSR3                                                              */
    } CSR3_b;
  } ;
  
  union {
    __IOM uint32_t CSR4;                        /*!< (@ 0x00000108) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR4       : 32;           /*!< [31..0] CSR4                                                              */
    } CSR4_b;
  } ;
  
  union {
    __IOM uint32_t CSR5;                        /*!< (@ 0x0000010C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR5       : 32;           /*!< [31..0] CSR5                                                              */
    } CSR5_b;
  } ;
  
  union {
    __IOM uint32_t CSR6;                        /*!< (@ 0x00000110) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR6       : 32;           /*!< [31..0] CSR6                                                              */
    } CSR6_b;
  } ;
  
  union {
    __IOM uint32_t CSR7;                        /*!< (@ 0x00000114) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR7       : 32;           /*!< [31..0] CSR7                                                              */
    } CSR7_b;
  } ;
  
  union {
    __IOM uint32_t CSR8;                        /*!< (@ 0x00000118) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR8       : 32;           /*!< [31..0] CSR8                                                              */
    } CSR8_b;
  } ;
  
  union {
    __IOM uint32_t CSR9;                        /*!< (@ 0x0000011C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR9       : 32;           /*!< [31..0] CSR9                                                              */
    } CSR9_b;
  } ;
  
  union {
    __IOM uint32_t CSR10;                       /*!< (@ 0x00000120) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR10      : 32;           /*!< [31..0] CSR10                                                             */
    } CSR10_b;
  } ;
  
  union {
    __IOM uint32_t CSR11;                       /*!< (@ 0x00000124) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR11      : 32;           /*!< [31..0] CSR11                                                             */
    } CSR11_b;
  } ;
  
  union {
    __IOM uint32_t CSR12;                       /*!< (@ 0x00000128) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR12      : 32;           /*!< [31..0] CSR12                                                             */
    } CSR12_b;
  } ;
  
  union {
    __IOM uint32_t CSR13;                       /*!< (@ 0x0000012C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR13      : 32;           /*!< [31..0] CSR13                                                             */
    } CSR13_b;
  } ;
  
  union {
    __IOM uint32_t CSR14;                       /*!< (@ 0x00000130) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR14      : 32;           /*!< [31..0] CSR14                                                             */
    } CSR14_b;
  } ;
  
  union {
    __IOM uint32_t CSR15;                       /*!< (@ 0x00000134) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR15      : 32;           /*!< [31..0] CSR15                                                             */
    } CSR15_b;
  } ;
  
  union {
    __IOM uint32_t CSR16;                       /*!< (@ 0x00000138) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR16      : 32;           /*!< [31..0] CSR16                                                             */
    } CSR16_b;
  } ;
  
  union {
    __IOM uint32_t CSR17;                       /*!< (@ 0x0000013C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR17      : 32;           /*!< [31..0] CSR17                                                             */
    } CSR17_b;
  } ;
  
  union {
    __IOM uint32_t CSR18;                       /*!< (@ 0x00000140) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR18      : 32;           /*!< [31..0] CSR18                                                             */
    } CSR18_b;
  } ;
  
  union {
    __IOM uint32_t CSR19;                       /*!< (@ 0x00000144) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR19      : 32;           /*!< [31..0] CSR19                                                             */
    } CSR19_b;
  } ;
  
  union {
    __IOM uint32_t CSR20;                       /*!< (@ 0x00000148) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR20      : 32;           /*!< [31..0] CSR20                                                             */
    } CSR20_b;
  } ;
  
  union {
    __IOM uint32_t CSR21;                       /*!< (@ 0x0000014C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR21      : 32;           /*!< [31..0] CSR21                                                             */
    } CSR21_b;
  } ;
  
  union {
    __IOM uint32_t CSR22;                       /*!< (@ 0x00000150) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR22      : 32;           /*!< [31..0] CSR22                                                             */
    } CSR22_b;
  } ;
  
  union {
    __IOM uint32_t CSR23;                       /*!< (@ 0x00000154) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR23      : 32;           /*!< [31..0] CSR23                                                             */
    } CSR23_b;
  } ;
  
  union {
    __IOM uint32_t CSR24;                       /*!< (@ 0x00000158) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR24      : 32;           /*!< [31..0] CSR24                                                             */
    } CSR24_b;
  } ;
  
  union {
    __IOM uint32_t CSR25;                       /*!< (@ 0x0000015C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR25      : 32;           /*!< [31..0] CSR25                                                             */
    } CSR25_b;
  } ;
  
  union {
    __IOM uint32_t CSR26;                       /*!< (@ 0x00000160) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR26      : 32;           /*!< [31..0] CSR26                                                             */
    } CSR26_b;
  } ;
  
  union {
    __IOM uint32_t CSR27;                       /*!< (@ 0x00000164) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR27      : 32;           /*!< [31..0] CSR27                                                             */
    } CSR27_b;
  } ;
  
  union {
    __IOM uint32_t CSR28;                       /*!< (@ 0x00000168) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR28      : 32;           /*!< [31..0] CSR28                                                             */
    } CSR28_b;
  } ;
  
  union {
    __IOM uint32_t CSR29;                       /*!< (@ 0x0000016C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR29      : 32;           /*!< [31..0] CSR29                                                             */
    } CSR29_b;
  } ;
  
  union {
    __IOM uint32_t CSR30;                       /*!< (@ 0x00000170) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR30      : 32;           /*!< [31..0] CSR30                                                             */
    } CSR30_b;
  } ;
  
  union {
    __IOM uint32_t CSR31;                       /*!< (@ 0x00000174) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR31      : 32;           /*!< [31..0] CSR31                                                             */
    } CSR31_b;
  } ;
  
  union {
    __IOM uint32_t CSR32;                       /*!< (@ 0x00000178) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR32      : 32;           /*!< [31..0] CSR32                                                             */
    } CSR32_b;
  } ;
  
  union {
    __IOM uint32_t CSR33;                       /*!< (@ 0x0000017C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR33      : 32;           /*!< [31..0] CSR33                                                             */
    } CSR33_b;
  } ;
  
  union {
    __IOM uint32_t CSR34;                       /*!< (@ 0x00000180) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR34      : 32;           /*!< [31..0] CSR34                                                             */
    } CSR34_b;
  } ;
  
  union {
    __IOM uint32_t CSR35;                       /*!< (@ 0x00000184) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR35      : 32;           /*!< [31..0] CSR35                                                             */
    } CSR35_b;
  } ;
  
  union {
    __IOM uint32_t CSR36;                       /*!< (@ 0x00000188) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR36      : 32;           /*!< [31..0] CSR36                                                             */
    } CSR36_b;
  } ;
  
  union {
    __IOM uint32_t CSR37;                       /*!< (@ 0x0000018C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR37      : 32;           /*!< [31..0] CSR37                                                             */
    } CSR37_b;
  } ;
  
  union {
    __IOM uint32_t CSR38;                       /*!< (@ 0x00000190) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR38      : 32;           /*!< [31..0] CSR38                                                             */
    } CSR38_b;
  } ;
  
  union {
    __IOM uint32_t CSR39;                       /*!< (@ 0x00000194) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR39      : 32;           /*!< [31..0] CSR39                                                             */
    } CSR39_b;
  } ;
  
  union {
    __IOM uint32_t CSR40;                       /*!< (@ 0x00000198) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR40      : 32;           /*!< [31..0] CSR40                                                             */
    } CSR40_b;
  } ;
  
  union {
    __IOM uint32_t CSR41;                       /*!< (@ 0x0000019C) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR41      : 32;           /*!< [31..0] CSR41                                                             */
    } CSR41_b;
  } ;
  
  union {
    __IOM uint32_t CSR42;                       /*!< (@ 0x000001A0) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR42      : 32;           /*!< [31..0] CSR42                                                             */
    } CSR42_b;
  } ;
  
  union {
    __IOM uint32_t CSR43;                       /*!< (@ 0x000001A4) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR43      : 32;           /*!< [31..0] CSR43                                                             */
    } CSR43_b;
  } ;
  
  union {
    __IOM uint32_t CSR44;                       /*!< (@ 0x000001A8) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR44      : 32;           /*!< [31..0] CSR44                                                             */
    } CSR44_b;
  } ;
  
  union {
    __IOM uint32_t CSR45;                       /*!< (@ 0x000001AC) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR45      : 32;           /*!< [31..0] CSR45                                                             */
    } CSR45_b;
  } ;
  
  union {
    __IOM uint32_t CSR46;                       /*!< (@ 0x000001B0) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR46      : 32;           /*!< [31..0] CSR46                                                             */
    } CSR46_b;
  } ;
  
  union {
    __IOM uint32_t CSR47;                       /*!< (@ 0x000001B4) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR47      : 32;           /*!< [31..0] CSR47                                                             */
    } CSR47_b;
  } ;
  
  union {
    __IOM uint32_t CSR48;                       /*!< (@ 0x000001B8) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR48      : 32;           /*!< [31..0] CSR48                                                             */
    } CSR48_b;
  } ;
  
  union {
    __IOM uint32_t CSR49;                       /*!< (@ 0x000001BC) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR49      : 32;           /*!< [31..0] CSR49                                                             */
    } CSR49_b;
  } ;
  
  union {
    __IOM uint32_t CSR50;                       /*!< (@ 0x000001C0) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR50      : 32;           /*!< [31..0] CSR50                                                             */
    } CSR50_b;
  } ;
  
  union {
    __IOM uint32_t CSR51;                       /*!< (@ 0x000001C4) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR51      : 32;           /*!< [31..0] CSR51                                                             */
    } CSR51_b;
  } ;
  
  union {
    __IOM uint32_t CSR52;                       /*!< (@ 0x000001C8) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR52      : 32;           /*!< [31..0] CSR52                                                             */
    } CSR52_b;
  } ;
  
  union {
    __IOM uint32_t CSR53;                       /*!< (@ 0x000001CC) context swap registers                                     */
    
    struct {
      __IOM uint32_t CSR53      : 32;           /*!< [31..0] CSR53                                                             */
    } CSR53_b;
  } ;
  __IM  uint32_t  RESERVED1[80];
  
  union {
    __IM  uint32_t HASH_HR0;                    /*!< (@ 0x00000310) HASH digest register                                       */
    
    struct {
      __IM  uint32_t H0         : 32;           /*!< [31..0] H0                                                                */
    } HASH_HR0_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR1;                    /*!< (@ 0x00000314) read-only                                                  */
    
    struct {
      __IM  uint32_t H1         : 32;           /*!< [31..0] H1                                                                */
    } HASH_HR1_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR2;                    /*!< (@ 0x00000318) read-only                                                  */
    
    struct {
      __IM  uint32_t H2         : 32;           /*!< [31..0] H2                                                                */
    } HASH_HR2_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR3;                    /*!< (@ 0x0000031C) read-only                                                  */
    
    struct {
      __IM  uint32_t H3         : 32;           /*!< [31..0] H3                                                                */
    } HASH_HR3_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR4;                    /*!< (@ 0x00000320) read-only                                                  */
    
    struct {
      __IM  uint32_t H4         : 32;           /*!< [31..0] H4                                                                */
    } HASH_HR4_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR5;                    /*!< (@ 0x00000324) read-only                                                  */
    
    struct {
      __IM  uint32_t H5         : 32;           /*!< [31..0] H5                                                                */
    } HASH_HR5_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR6;                    /*!< (@ 0x00000328) read-only                                                  */
    
    struct {
      __IM  uint32_t H6         : 32;           /*!< [31..0] H6                                                                */
    } HASH_HR6_b;
  } ;
  
  union {
    __IM  uint32_t HASH_HR7;                    /*!< (@ 0x0000032C) read-only                                                  */
    
    struct {
      __IM  uint32_t H7         : 32;           /*!< [31..0] H7                                                                */
    } HASH_HR7_b;
  } ;
} HASH_Type;                                    /*!< Size = 816 (0x330)                                                        */



/* =========================================================================================================================== */
/* ================                                           CRYP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Cryptographic processor (CRYP)
  */

typedef struct {                                /*!< (@ 0x48021000) CRYP Structure                                             */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) control register                                           */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t ALGODIR    : 1;            /*!< [2..2] Algorithm direction                                                */
      __IOM uint32_t ALGOMODE0  : 3;            /*!< [5..3] Algorithm mode                                                     */
      __IOM uint32_t DATATYPE   : 2;            /*!< [7..6] Data type selection                                                */
      __IOM uint32_t KEYSIZE    : 2;            /*!< [9..8] Key size selection (AES mode only)                                 */
            uint32_t            : 4;
      __OM  uint32_t FFLUSH     : 1;            /*!< [14..14] FIFO flush                                                       */
      __IOM uint32_t CRYPEN     : 1;            /*!< [15..15] Cryptographic processor enable                                   */
      __IOM uint32_t GCM_CCMPH  : 2;            /*!< [17..16] GCM_CCMPH                                                        */
            uint32_t            : 1;
      __IOM uint32_t ALGOMODE3  : 1;            /*!< [19..19] ALGOMODE                                                         */
            uint32_t            : 12;
    } CR_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000004) status register                                            */
    
    struct {
      __IM  uint32_t IFEM       : 1;            /*!< [0..0] Input FIFO empty                                                   */
      __IM  uint32_t IFNF       : 1;            /*!< [1..1] Input FIFO not full                                                */
      __IM  uint32_t OFNE       : 1;            /*!< [2..2] Output FIFO not empty                                              */
      __IM  uint32_t OFFU       : 1;            /*!< [3..3] Output FIFO full                                                   */
      __IM  uint32_t BUSY       : 1;            /*!< [4..4] Busy bit                                                           */
            uint32_t            : 27;
    } SR_b;
  } ;
  
  union {
    __IOM uint32_t DIN;                         /*!< (@ 0x00000008) data input register                                        */
    
    struct {
      __IOM uint32_t DATAIN     : 32;           /*!< [31..0] Data input                                                        */
    } DIN_b;
  } ;
  
  union {
    __IM  uint32_t DOUT;                        /*!< (@ 0x0000000C) data output register                                       */
    
    struct {
      __IM  uint32_t DATAOUT    : 32;           /*!< [31..0] Data output                                                       */
    } DOUT_b;
  } ;
  
  union {
    __IOM uint32_t DMACR;                       /*!< (@ 0x00000010) DMA control register                                       */
    
    struct {
      __IOM uint32_t DIEN       : 1;            /*!< [0..0] DMA input enable                                                   */
      __IOM uint32_t DOEN       : 1;            /*!< [1..1] DMA output enable                                                  */
            uint32_t            : 30;
    } DMACR_b;
  } ;
  
  union {
    __IOM uint32_t IMSCR;                       /*!< (@ 0x00000014) interrupt mask set/clear register                          */
    
    struct {
      __IOM uint32_t INIM       : 1;            /*!< [0..0] Input FIFO service interrupt mask                                  */
      __IOM uint32_t OUTIM      : 1;            /*!< [1..1] Output FIFO service interrupt mask                                 */
            uint32_t            : 30;
    } IMSCR_b;
  } ;
  
  union {
    __IM  uint32_t RISR;                        /*!< (@ 0x00000018) raw interrupt status register                              */
    
    struct {
      __IM  uint32_t INRIS      : 1;            /*!< [0..0] Input FIFO service raw interrupt status                            */
      __IM  uint32_t OUTRIS     : 1;            /*!< [1..1] Output FIFO service raw interrupt status                           */
            uint32_t            : 30;
    } RISR_b;
  } ;
  
  union {
    __IM  uint32_t MISR;                        /*!< (@ 0x0000001C) masked interrupt status register                           */
    
    struct {
      __IM  uint32_t INMIS      : 1;            /*!< [0..0] Input FIFO service masked interrupt status                         */
      __IM  uint32_t OUTMIS     : 1;            /*!< [1..1] Output FIFO service masked interrupt status                        */
            uint32_t            : 30;
    } MISR_b;
  } ;
  
  union {
    __OM  uint32_t K0LR;                        /*!< (@ 0x00000020) key registers                                              */
    
    struct {
      __OM  uint32_t b224       : 1;            /*!< [0..0] b224                                                               */
      __OM  uint32_t b225       : 1;            /*!< [1..1] b225                                                               */
      __OM  uint32_t b226       : 1;            /*!< [2..2] b226                                                               */
      __OM  uint32_t b227       : 1;            /*!< [3..3] b227                                                               */
      __OM  uint32_t b228       : 1;            /*!< [4..4] b228                                                               */
      __OM  uint32_t b229       : 1;            /*!< [5..5] b229                                                               */
      __OM  uint32_t b230       : 1;            /*!< [6..6] b230                                                               */
      __OM  uint32_t b231       : 1;            /*!< [7..7] b231                                                               */
      __OM  uint32_t b232       : 1;            /*!< [8..8] b232                                                               */
      __OM  uint32_t b233       : 1;            /*!< [9..9] b233                                                               */
      __OM  uint32_t b234       : 1;            /*!< [10..10] b234                                                             */
      __OM  uint32_t b235       : 1;            /*!< [11..11] b235                                                             */
      __OM  uint32_t b236       : 1;            /*!< [12..12] b236                                                             */
      __OM  uint32_t b237       : 1;            /*!< [13..13] b237                                                             */
      __OM  uint32_t b238       : 1;            /*!< [14..14] b238                                                             */
      __OM  uint32_t b239       : 1;            /*!< [15..15] b239                                                             */
      __OM  uint32_t b240       : 1;            /*!< [16..16] b240                                                             */
      __OM  uint32_t b241       : 1;            /*!< [17..17] b241                                                             */
      __OM  uint32_t b242       : 1;            /*!< [18..18] b242                                                             */
      __OM  uint32_t b243       : 1;            /*!< [19..19] b243                                                             */
      __OM  uint32_t b244       : 1;            /*!< [20..20] b244                                                             */
      __OM  uint32_t b245       : 1;            /*!< [21..21] b245                                                             */
      __OM  uint32_t b246       : 1;            /*!< [22..22] b246                                                             */
      __OM  uint32_t b247       : 1;            /*!< [23..23] b247                                                             */
      __OM  uint32_t b248       : 1;            /*!< [24..24] b248                                                             */
      __OM  uint32_t b249       : 1;            /*!< [25..25] b249                                                             */
      __OM  uint32_t b250       : 1;            /*!< [26..26] b250                                                             */
      __OM  uint32_t b251       : 1;            /*!< [27..27] b251                                                             */
      __OM  uint32_t b252       : 1;            /*!< [28..28] b252                                                             */
      __OM  uint32_t b253       : 1;            /*!< [29..29] b253                                                             */
      __OM  uint32_t b254       : 1;            /*!< [30..30] b254                                                             */
      __OM  uint32_t b255       : 1;            /*!< [31..31] b255                                                             */
    } K0LR_b;
  } ;
  
  union {
    __OM  uint32_t K0RR;                        /*!< (@ 0x00000024) key registers                                              */
    
    struct {
      __OM  uint32_t b192       : 1;            /*!< [0..0] b192                                                               */
      __OM  uint32_t b193       : 1;            /*!< [1..1] b193                                                               */
      __OM  uint32_t b194       : 1;            /*!< [2..2] b194                                                               */
      __OM  uint32_t b195       : 1;            /*!< [3..3] b195                                                               */
      __OM  uint32_t b196       : 1;            /*!< [4..4] b196                                                               */
      __OM  uint32_t b197       : 1;            /*!< [5..5] b197                                                               */
      __OM  uint32_t b198       : 1;            /*!< [6..6] b198                                                               */
      __OM  uint32_t b199       : 1;            /*!< [7..7] b199                                                               */
      __OM  uint32_t b200       : 1;            /*!< [8..8] b200                                                               */
      __OM  uint32_t b201       : 1;            /*!< [9..9] b201                                                               */
      __OM  uint32_t b202       : 1;            /*!< [10..10] b202                                                             */
      __OM  uint32_t b203       : 1;            /*!< [11..11] b203                                                             */
      __OM  uint32_t b204       : 1;            /*!< [12..12] b204                                                             */
      __OM  uint32_t b205       : 1;            /*!< [13..13] b205                                                             */
      __OM  uint32_t b206       : 1;            /*!< [14..14] b206                                                             */
      __OM  uint32_t b207       : 1;            /*!< [15..15] b207                                                             */
      __OM  uint32_t b208       : 1;            /*!< [16..16] b208                                                             */
      __OM  uint32_t b209       : 1;            /*!< [17..17] b209                                                             */
      __OM  uint32_t b210       : 1;            /*!< [18..18] b210                                                             */
      __OM  uint32_t b211       : 1;            /*!< [19..19] b211                                                             */
      __OM  uint32_t b212       : 1;            /*!< [20..20] b212                                                             */
      __OM  uint32_t b213       : 1;            /*!< [21..21] b213                                                             */
      __OM  uint32_t b214       : 1;            /*!< [22..22] b214                                                             */
      __OM  uint32_t b215       : 1;            /*!< [23..23] b215                                                             */
      __OM  uint32_t b216       : 1;            /*!< [24..24] b216                                                             */
      __OM  uint32_t b217       : 1;            /*!< [25..25] b217                                                             */
      __OM  uint32_t b218       : 1;            /*!< [26..26] b218                                                             */
      __OM  uint32_t b219       : 1;            /*!< [27..27] b219                                                             */
      __OM  uint32_t b220       : 1;            /*!< [28..28] b220                                                             */
      __OM  uint32_t b221       : 1;            /*!< [29..29] b221                                                             */
      __OM  uint32_t b222       : 1;            /*!< [30..30] b222                                                             */
      __OM  uint32_t b223       : 1;            /*!< [31..31] b223                                                             */
    } K0RR_b;
  } ;
  
  union {
    __OM  uint32_t K1LR;                        /*!< (@ 0x00000028) key registers                                              */
    
    struct {
      __OM  uint32_t b160       : 1;            /*!< [0..0] b160                                                               */
      __OM  uint32_t b161       : 1;            /*!< [1..1] b161                                                               */
      __OM  uint32_t b162       : 1;            /*!< [2..2] b162                                                               */
      __OM  uint32_t b163       : 1;            /*!< [3..3] b163                                                               */
      __OM  uint32_t b164       : 1;            /*!< [4..4] b164                                                               */
      __OM  uint32_t b165       : 1;            /*!< [5..5] b165                                                               */
      __OM  uint32_t b166       : 1;            /*!< [6..6] b166                                                               */
      __OM  uint32_t b167       : 1;            /*!< [7..7] b167                                                               */
      __OM  uint32_t b168       : 1;            /*!< [8..8] b168                                                               */
      __OM  uint32_t b169       : 1;            /*!< [9..9] b169                                                               */
      __OM  uint32_t b170       : 1;            /*!< [10..10] b170                                                             */
      __OM  uint32_t b171       : 1;            /*!< [11..11] b171                                                             */
      __OM  uint32_t b172       : 1;            /*!< [12..12] b172                                                             */
      __OM  uint32_t b173       : 1;            /*!< [13..13] b173                                                             */
      __OM  uint32_t b174       : 1;            /*!< [14..14] b174                                                             */
      __OM  uint32_t b175       : 1;            /*!< [15..15] b175                                                             */
      __OM  uint32_t b176       : 1;            /*!< [16..16] b176                                                             */
      __OM  uint32_t b177       : 1;            /*!< [17..17] b177                                                             */
      __OM  uint32_t b178       : 1;            /*!< [18..18] b178                                                             */
      __OM  uint32_t b179       : 1;            /*!< [19..19] b179                                                             */
      __OM  uint32_t b180       : 1;            /*!< [20..20] b180                                                             */
      __OM  uint32_t b181       : 1;            /*!< [21..21] b181                                                             */
      __OM  uint32_t b182       : 1;            /*!< [22..22] b182                                                             */
      __OM  uint32_t b183       : 1;            /*!< [23..23] b183                                                             */
      __OM  uint32_t b184       : 1;            /*!< [24..24] b184                                                             */
      __OM  uint32_t b185       : 1;            /*!< [25..25] b185                                                             */
      __OM  uint32_t b186       : 1;            /*!< [26..26] b186                                                             */
      __OM  uint32_t b187       : 1;            /*!< [27..27] b187                                                             */
      __OM  uint32_t b188       : 1;            /*!< [28..28] b188                                                             */
      __OM  uint32_t b189       : 1;            /*!< [29..29] b189                                                             */
      __OM  uint32_t b190       : 1;            /*!< [30..30] b190                                                             */
      __OM  uint32_t b191       : 1;            /*!< [31..31] b191                                                             */
    } K1LR_b;
  } ;
  
  union {
    __OM  uint32_t K1RR;                        /*!< (@ 0x0000002C) key registers                                              */
    
    struct {
      __OM  uint32_t b128       : 1;            /*!< [0..0] b128                                                               */
      __OM  uint32_t b129       : 1;            /*!< [1..1] b129                                                               */
      __OM  uint32_t b130       : 1;            /*!< [2..2] b130                                                               */
      __OM  uint32_t b131       : 1;            /*!< [3..3] b131                                                               */
      __OM  uint32_t b132       : 1;            /*!< [4..4] b132                                                               */
      __OM  uint32_t b133       : 1;            /*!< [5..5] b133                                                               */
      __OM  uint32_t b134       : 1;            /*!< [6..6] b134                                                               */
      __OM  uint32_t b135       : 1;            /*!< [7..7] b135                                                               */
      __OM  uint32_t b136       : 1;            /*!< [8..8] b136                                                               */
      __OM  uint32_t b137       : 1;            /*!< [9..9] b137                                                               */
      __OM  uint32_t b138       : 1;            /*!< [10..10] b138                                                             */
      __OM  uint32_t b139       : 1;            /*!< [11..11] b139                                                             */
      __OM  uint32_t b140       : 1;            /*!< [12..12] b140                                                             */
      __OM  uint32_t b141       : 1;            /*!< [13..13] b141                                                             */
      __OM  uint32_t b142       : 1;            /*!< [14..14] b142                                                             */
      __OM  uint32_t b143       : 1;            /*!< [15..15] b143                                                             */
      __OM  uint32_t b144       : 1;            /*!< [16..16] b144                                                             */
      __OM  uint32_t b145       : 1;            /*!< [17..17] b145                                                             */
      __OM  uint32_t b146       : 1;            /*!< [18..18] b146                                                             */
      __OM  uint32_t b147       : 1;            /*!< [19..19] b147                                                             */
      __OM  uint32_t b148       : 1;            /*!< [20..20] b148                                                             */
      __OM  uint32_t b149       : 1;            /*!< [21..21] b149                                                             */
      __OM  uint32_t b150       : 1;            /*!< [22..22] b150                                                             */
      __OM  uint32_t b151       : 1;            /*!< [23..23] b151                                                             */
      __OM  uint32_t b152       : 1;            /*!< [24..24] b152                                                             */
      __OM  uint32_t b153       : 1;            /*!< [25..25] b153                                                             */
      __OM  uint32_t b154       : 1;            /*!< [26..26] b154                                                             */
      __OM  uint32_t b155       : 1;            /*!< [27..27] b155                                                             */
      __OM  uint32_t b156       : 1;            /*!< [28..28] b156                                                             */
      __OM  uint32_t b157       : 1;            /*!< [29..29] b157                                                             */
      __OM  uint32_t b158       : 1;            /*!< [30..30] b158                                                             */
      __OM  uint32_t b159       : 1;            /*!< [31..31] b159                                                             */
    } K1RR_b;
  } ;
  
  union {
    __OM  uint32_t K2LR;                        /*!< (@ 0x00000030) key registers                                              */
    
    struct {
      __OM  uint32_t b96        : 1;            /*!< [0..0] b96                                                                */
      __OM  uint32_t b97        : 1;            /*!< [1..1] b97                                                                */
      __OM  uint32_t b98        : 1;            /*!< [2..2] b98                                                                */
      __OM  uint32_t b99        : 1;            /*!< [3..3] b99                                                                */
      __OM  uint32_t b100       : 1;            /*!< [4..4] b100                                                               */
      __OM  uint32_t b101       : 1;            /*!< [5..5] b101                                                               */
      __OM  uint32_t b102       : 1;            /*!< [6..6] b102                                                               */
      __OM  uint32_t b103       : 1;            /*!< [7..7] b103                                                               */
      __OM  uint32_t b104       : 1;            /*!< [8..8] b104                                                               */
      __OM  uint32_t b105       : 1;            /*!< [9..9] b105                                                               */
      __OM  uint32_t b106       : 1;            /*!< [10..10] b106                                                             */
      __OM  uint32_t b107       : 1;            /*!< [11..11] b107                                                             */
      __OM  uint32_t b108       : 1;            /*!< [12..12] b108                                                             */
      __OM  uint32_t b109       : 1;            /*!< [13..13] b109                                                             */
      __OM  uint32_t b110       : 1;            /*!< [14..14] b110                                                             */
      __OM  uint32_t b111       : 1;            /*!< [15..15] b111                                                             */
      __OM  uint32_t b112       : 1;            /*!< [16..16] b112                                                             */
      __OM  uint32_t b113       : 1;            /*!< [17..17] b113                                                             */
      __OM  uint32_t b114       : 1;            /*!< [18..18] b114                                                             */
      __OM  uint32_t b115       : 1;            /*!< [19..19] b115                                                             */
      __OM  uint32_t b116       : 1;            /*!< [20..20] b116                                                             */
      __OM  uint32_t b117       : 1;            /*!< [21..21] b117                                                             */
      __OM  uint32_t b118       : 1;            /*!< [22..22] b118                                                             */
      __OM  uint32_t b119       : 1;            /*!< [23..23] b119                                                             */
      __OM  uint32_t b120       : 1;            /*!< [24..24] b120                                                             */
      __OM  uint32_t b121       : 1;            /*!< [25..25] b121                                                             */
      __OM  uint32_t b122       : 1;            /*!< [26..26] b122                                                             */
      __OM  uint32_t b123       : 1;            /*!< [27..27] b123                                                             */
      __OM  uint32_t b124       : 1;            /*!< [28..28] b124                                                             */
      __OM  uint32_t b125       : 1;            /*!< [29..29] b125                                                             */
      __OM  uint32_t b126       : 1;            /*!< [30..30] b126                                                             */
      __OM  uint32_t b127       : 1;            /*!< [31..31] b127                                                             */
    } K2LR_b;
  } ;
  
  union {
    __OM  uint32_t K2RR;                        /*!< (@ 0x00000034) key registers                                              */
    
    struct {
      __OM  uint32_t b64        : 1;            /*!< [0..0] b64                                                                */
      __OM  uint32_t b65        : 1;            /*!< [1..1] b65                                                                */
      __OM  uint32_t b66        : 1;            /*!< [2..2] b66                                                                */
      __OM  uint32_t b67        : 1;            /*!< [3..3] b67                                                                */
      __OM  uint32_t b68        : 1;            /*!< [4..4] b68                                                                */
      __OM  uint32_t b69        : 1;            /*!< [5..5] b69                                                                */
      __OM  uint32_t b70        : 1;            /*!< [6..6] b70                                                                */
      __OM  uint32_t b71        : 1;            /*!< [7..7] b71                                                                */
      __OM  uint32_t b72        : 1;            /*!< [8..8] b72                                                                */
      __OM  uint32_t b73        : 1;            /*!< [9..9] b73                                                                */
      __OM  uint32_t b74        : 1;            /*!< [10..10] b74                                                              */
      __OM  uint32_t b75        : 1;            /*!< [11..11] b75                                                              */
      __OM  uint32_t b76        : 1;            /*!< [12..12] b76                                                              */
      __OM  uint32_t b77        : 1;            /*!< [13..13] b77                                                              */
      __OM  uint32_t b78        : 1;            /*!< [14..14] b78                                                              */
      __OM  uint32_t b79        : 1;            /*!< [15..15] b79                                                              */
      __OM  uint32_t b80        : 1;            /*!< [16..16] b80                                                              */
      __OM  uint32_t b81        : 1;            /*!< [17..17] b81                                                              */
      __OM  uint32_t b82        : 1;            /*!< [18..18] b82                                                              */
      __OM  uint32_t b83        : 1;            /*!< [19..19] b83                                                              */
      __OM  uint32_t b84        : 1;            /*!< [20..20] b84                                                              */
      __OM  uint32_t b85        : 1;            /*!< [21..21] b85                                                              */
      __OM  uint32_t b86        : 1;            /*!< [22..22] b86                                                              */
      __OM  uint32_t b87        : 1;            /*!< [23..23] b87                                                              */
      __OM  uint32_t b88        : 1;            /*!< [24..24] b88                                                              */
      __OM  uint32_t b89        : 1;            /*!< [25..25] b89                                                              */
      __OM  uint32_t b90        : 1;            /*!< [26..26] b90                                                              */
      __OM  uint32_t b91        : 1;            /*!< [27..27] b91                                                              */
      __OM  uint32_t b92        : 1;            /*!< [28..28] b92                                                              */
      __OM  uint32_t b93        : 1;            /*!< [29..29] b93                                                              */
      __OM  uint32_t b94        : 1;            /*!< [30..30] b94                                                              */
      __OM  uint32_t b95        : 1;            /*!< [31..31] b95                                                              */
    } K2RR_b;
  } ;
  
  union {
    __OM  uint32_t K3LR;                        /*!< (@ 0x00000038) key registers                                              */
    
    struct {
      __OM  uint32_t b32        : 1;            /*!< [0..0] b32                                                                */
      __OM  uint32_t b33        : 1;            /*!< [1..1] b33                                                                */
      __OM  uint32_t b34        : 1;            /*!< [2..2] b34                                                                */
      __OM  uint32_t b35        : 1;            /*!< [3..3] b35                                                                */
      __OM  uint32_t b36        : 1;            /*!< [4..4] b36                                                                */
      __OM  uint32_t b37        : 1;            /*!< [5..5] b37                                                                */
      __OM  uint32_t b38        : 1;            /*!< [6..6] b38                                                                */
      __OM  uint32_t b39        : 1;            /*!< [7..7] b39                                                                */
      __OM  uint32_t b40        : 1;            /*!< [8..8] b40                                                                */
      __OM  uint32_t b41        : 1;            /*!< [9..9] b41                                                                */
      __OM  uint32_t b42        : 1;            /*!< [10..10] b42                                                              */
      __OM  uint32_t b43        : 1;            /*!< [11..11] b43                                                              */
      __OM  uint32_t b44        : 1;            /*!< [12..12] b44                                                              */
      __OM  uint32_t b45        : 1;            /*!< [13..13] b45                                                              */
      __OM  uint32_t b46        : 1;            /*!< [14..14] b46                                                              */
      __OM  uint32_t b47        : 1;            /*!< [15..15] b47                                                              */
      __OM  uint32_t b48        : 1;            /*!< [16..16] b48                                                              */
      __OM  uint32_t b49        : 1;            /*!< [17..17] b49                                                              */
      __OM  uint32_t b50        : 1;            /*!< [18..18] b50                                                              */
      __OM  uint32_t b51        : 1;            /*!< [19..19] b51                                                              */
      __OM  uint32_t b52        : 1;            /*!< [20..20] b52                                                              */
      __OM  uint32_t b53        : 1;            /*!< [21..21] b53                                                              */
      __OM  uint32_t b54        : 1;            /*!< [22..22] b54                                                              */
      __OM  uint32_t b55        : 1;            /*!< [23..23] b55                                                              */
      __OM  uint32_t b56        : 1;            /*!< [24..24] b56                                                              */
      __OM  uint32_t b57        : 1;            /*!< [25..25] b57                                                              */
      __OM  uint32_t b58        : 1;            /*!< [26..26] b58                                                              */
      __OM  uint32_t b59        : 1;            /*!< [27..27] b59                                                              */
      __OM  uint32_t b60        : 1;            /*!< [28..28] b60                                                              */
      __OM  uint32_t b61        : 1;            /*!< [29..29] b61                                                              */
      __OM  uint32_t b62        : 1;            /*!< [30..30] b62                                                              */
      __OM  uint32_t b63        : 1;            /*!< [31..31] b63                                                              */
    } K3LR_b;
  } ;
  
  union {
    __OM  uint32_t K3RR;                        /*!< (@ 0x0000003C) key registers                                              */
    
    struct {
      __OM  uint32_t b0         : 1;            /*!< [0..0] b0                                                                 */
      __OM  uint32_t b1         : 1;            /*!< [1..1] b1                                                                 */
      __OM  uint32_t b2         : 1;            /*!< [2..2] b2                                                                 */
      __OM  uint32_t b3         : 1;            /*!< [3..3] b3                                                                 */
      __OM  uint32_t b4         : 1;            /*!< [4..4] b4                                                                 */
      __OM  uint32_t b5         : 1;            /*!< [5..5] b5                                                                 */
      __OM  uint32_t b6         : 1;            /*!< [6..6] b6                                                                 */
      __OM  uint32_t b7         : 1;            /*!< [7..7] b7                                                                 */
      __OM  uint32_t b8         : 1;            /*!< [8..8] b8                                                                 */
      __OM  uint32_t b9         : 1;            /*!< [9..9] b9                                                                 */
      __OM  uint32_t b10        : 1;            /*!< [10..10] b10                                                              */
      __OM  uint32_t b11        : 1;            /*!< [11..11] b11                                                              */
      __OM  uint32_t b12        : 1;            /*!< [12..12] b12                                                              */
      __OM  uint32_t b13        : 1;            /*!< [13..13] b13                                                              */
      __OM  uint32_t b14        : 1;            /*!< [14..14] b14                                                              */
      __OM  uint32_t b15        : 1;            /*!< [15..15] b15                                                              */
      __OM  uint32_t b16        : 1;            /*!< [16..16] b16                                                              */
      __OM  uint32_t b17        : 1;            /*!< [17..17] b17                                                              */
      __OM  uint32_t b18        : 1;            /*!< [18..18] b18                                                              */
      __OM  uint32_t b19        : 1;            /*!< [19..19] b19                                                              */
      __OM  uint32_t b20        : 1;            /*!< [20..20] b20                                                              */
      __OM  uint32_t b21        : 1;            /*!< [21..21] b21                                                              */
      __OM  uint32_t b22        : 1;            /*!< [22..22] b22                                                              */
      __OM  uint32_t b23        : 1;            /*!< [23..23] b23                                                              */
      __OM  uint32_t b24        : 1;            /*!< [24..24] b24                                                              */
      __OM  uint32_t b25        : 1;            /*!< [25..25] b25                                                              */
      __OM  uint32_t b26        : 1;            /*!< [26..26] b26                                                              */
      __OM  uint32_t b27        : 1;            /*!< [27..27] b27                                                              */
      __OM  uint32_t b28        : 1;            /*!< [28..28] b28                                                              */
      __OM  uint32_t b29        : 1;            /*!< [29..29] b29                                                              */
      __OM  uint32_t b30        : 1;            /*!< [30..30] b30                                                              */
      __OM  uint32_t b31        : 1;            /*!< [31..31] b31                                                              */
    } K3RR_b;
  } ;
  
  union {
    __IOM uint32_t IV0LR;                       /*!< (@ 0x00000040) initialization vector registers                            */
    
    struct {
      __IOM uint32_t IV31       : 1;            /*!< [0..0] IV31                                                               */
      __IOM uint32_t IV30       : 1;            /*!< [1..1] IV30                                                               */
      __IOM uint32_t IV29       : 1;            /*!< [2..2] IV29                                                               */
      __IOM uint32_t IV28       : 1;            /*!< [3..3] IV28                                                               */
      __IOM uint32_t IV27       : 1;            /*!< [4..4] IV27                                                               */
      __IOM uint32_t IV26       : 1;            /*!< [5..5] IV26                                                               */
      __IOM uint32_t IV25       : 1;            /*!< [6..6] IV25                                                               */
      __IOM uint32_t IV24       : 1;            /*!< [7..7] IV24                                                               */
      __IOM uint32_t IV23       : 1;            /*!< [8..8] IV23                                                               */
      __IOM uint32_t IV22       : 1;            /*!< [9..9] IV22                                                               */
      __IOM uint32_t IV21       : 1;            /*!< [10..10] IV21                                                             */
      __IOM uint32_t IV20       : 1;            /*!< [11..11] IV20                                                             */
      __IOM uint32_t IV19       : 1;            /*!< [12..12] IV19                                                             */
      __IOM uint32_t IV18       : 1;            /*!< [13..13] IV18                                                             */
      __IOM uint32_t IV17       : 1;            /*!< [14..14] IV17                                                             */
      __IOM uint32_t IV16       : 1;            /*!< [15..15] IV16                                                             */
      __IOM uint32_t IV15       : 1;            /*!< [16..16] IV15                                                             */
      __IOM uint32_t IV14       : 1;            /*!< [17..17] IV14                                                             */
      __IOM uint32_t IV13       : 1;            /*!< [18..18] IV13                                                             */
      __IOM uint32_t IV12       : 1;            /*!< [19..19] IV12                                                             */
      __IOM uint32_t IV11       : 1;            /*!< [20..20] IV11                                                             */
      __IOM uint32_t IV10       : 1;            /*!< [21..21] IV10                                                             */
      __IOM uint32_t IV9        : 1;            /*!< [22..22] IV9                                                              */
      __IOM uint32_t IV8        : 1;            /*!< [23..23] IV8                                                              */
      __IOM uint32_t IV7        : 1;            /*!< [24..24] IV7                                                              */
      __IOM uint32_t IV6        : 1;            /*!< [25..25] IV6                                                              */
      __IOM uint32_t IV5        : 1;            /*!< [26..26] IV5                                                              */
      __IOM uint32_t IV4        : 1;            /*!< [27..27] IV4                                                              */
      __IOM uint32_t IV3        : 1;            /*!< [28..28] IV3                                                              */
      __IOM uint32_t IV2        : 1;            /*!< [29..29] IV2                                                              */
      __IOM uint32_t IV1        : 1;            /*!< [30..30] IV1                                                              */
      __IOM uint32_t IV0        : 1;            /*!< [31..31] IV0                                                              */
    } IV0LR_b;
  } ;
  
  union {
    __IOM uint32_t IV0RR;                       /*!< (@ 0x00000044) initialization vector registers                            */
    
    struct {
      __IOM uint32_t IV63       : 1;            /*!< [0..0] IV63                                                               */
      __IOM uint32_t IV62       : 1;            /*!< [1..1] IV62                                                               */
      __IOM uint32_t IV61       : 1;            /*!< [2..2] IV61                                                               */
      __IOM uint32_t IV60       : 1;            /*!< [3..3] IV60                                                               */
      __IOM uint32_t IV59       : 1;            /*!< [4..4] IV59                                                               */
      __IOM uint32_t IV58       : 1;            /*!< [5..5] IV58                                                               */
      __IOM uint32_t IV57       : 1;            /*!< [6..6] IV57                                                               */
      __IOM uint32_t IV56       : 1;            /*!< [7..7] IV56                                                               */
      __IOM uint32_t IV55       : 1;            /*!< [8..8] IV55                                                               */
      __IOM uint32_t IV54       : 1;            /*!< [9..9] IV54                                                               */
      __IOM uint32_t IV53       : 1;            /*!< [10..10] IV53                                                             */
      __IOM uint32_t IV52       : 1;            /*!< [11..11] IV52                                                             */
      __IOM uint32_t IV51       : 1;            /*!< [12..12] IV51                                                             */
      __IOM uint32_t IV50       : 1;            /*!< [13..13] IV50                                                             */
      __IOM uint32_t IV49       : 1;            /*!< [14..14] IV49                                                             */
      __IOM uint32_t IV48       : 1;            /*!< [15..15] IV48                                                             */
      __IOM uint32_t IV47       : 1;            /*!< [16..16] IV47                                                             */
      __IOM uint32_t IV46       : 1;            /*!< [17..17] IV46                                                             */
      __IOM uint32_t IV45       : 1;            /*!< [18..18] IV45                                                             */
      __IOM uint32_t IV44       : 1;            /*!< [19..19] IV44                                                             */
      __IOM uint32_t IV43       : 1;            /*!< [20..20] IV43                                                             */
      __IOM uint32_t IV42       : 1;            /*!< [21..21] IV42                                                             */
      __IOM uint32_t IV41       : 1;            /*!< [22..22] IV41                                                             */
      __IOM uint32_t IV40       : 1;            /*!< [23..23] IV40                                                             */
      __IOM uint32_t IV39       : 1;            /*!< [24..24] IV39                                                             */
      __IOM uint32_t IV38       : 1;            /*!< [25..25] IV38                                                             */
      __IOM uint32_t IV37       : 1;            /*!< [26..26] IV37                                                             */
      __IOM uint32_t IV36       : 1;            /*!< [27..27] IV36                                                             */
      __IOM uint32_t IV35       : 1;            /*!< [28..28] IV35                                                             */
      __IOM uint32_t IV34       : 1;            /*!< [29..29] IV34                                                             */
      __IOM uint32_t IV33       : 1;            /*!< [30..30] IV33                                                             */
      __IOM uint32_t IV32       : 1;            /*!< [31..31] IV32                                                             */
    } IV0RR_b;
  } ;
  
  union {
    __IOM uint32_t IV1LR;                       /*!< (@ 0x00000048) initialization vector registers                            */
    
    struct {
      __IOM uint32_t IV95       : 1;            /*!< [0..0] IV95                                                               */
      __IOM uint32_t IV94       : 1;            /*!< [1..1] IV94                                                               */
      __IOM uint32_t IV93       : 1;            /*!< [2..2] IV93                                                               */
      __IOM uint32_t IV92       : 1;            /*!< [3..3] IV92                                                               */
      __IOM uint32_t IV91       : 1;            /*!< [4..4] IV91                                                               */
      __IOM uint32_t IV90       : 1;            /*!< [5..5] IV90                                                               */
      __IOM uint32_t IV89       : 1;            /*!< [6..6] IV89                                                               */
      __IOM uint32_t IV88       : 1;            /*!< [7..7] IV88                                                               */
      __IOM uint32_t IV87       : 1;            /*!< [8..8] IV87                                                               */
      __IOM uint32_t IV86       : 1;            /*!< [9..9] IV86                                                               */
      __IOM uint32_t IV85       : 1;            /*!< [10..10] IV85                                                             */
      __IOM uint32_t IV84       : 1;            /*!< [11..11] IV84                                                             */
      __IOM uint32_t IV83       : 1;            /*!< [12..12] IV83                                                             */
      __IOM uint32_t IV82       : 1;            /*!< [13..13] IV82                                                             */
      __IOM uint32_t IV81       : 1;            /*!< [14..14] IV81                                                             */
      __IOM uint32_t IV80       : 1;            /*!< [15..15] IV80                                                             */
      __IOM uint32_t IV79       : 1;            /*!< [16..16] IV79                                                             */
      __IOM uint32_t IV78       : 1;            /*!< [17..17] IV78                                                             */
      __IOM uint32_t IV77       : 1;            /*!< [18..18] IV77                                                             */
      __IOM uint32_t IV76       : 1;            /*!< [19..19] IV76                                                             */
      __IOM uint32_t IV75       : 1;            /*!< [20..20] IV75                                                             */
      __IOM uint32_t IV74       : 1;            /*!< [21..21] IV74                                                             */
      __IOM uint32_t IV73       : 1;            /*!< [22..22] IV73                                                             */
      __IOM uint32_t IV72       : 1;            /*!< [23..23] IV72                                                             */
      __IOM uint32_t IV71       : 1;            /*!< [24..24] IV71                                                             */
      __IOM uint32_t IV70       : 1;            /*!< [25..25] IV70                                                             */
      __IOM uint32_t IV69       : 1;            /*!< [26..26] IV69                                                             */
      __IOM uint32_t IV68       : 1;            /*!< [27..27] IV68                                                             */
      __IOM uint32_t IV67       : 1;            /*!< [28..28] IV67                                                             */
      __IOM uint32_t IV66       : 1;            /*!< [29..29] IV66                                                             */
      __IOM uint32_t IV65       : 1;            /*!< [30..30] IV65                                                             */
      __IOM uint32_t IV64       : 1;            /*!< [31..31] IV64                                                             */
    } IV1LR_b;
  } ;
  
  union {
    __IOM uint32_t IV1RR;                       /*!< (@ 0x0000004C) initialization vector registers                            */
    
    struct {
      __IOM uint32_t IV127      : 1;            /*!< [0..0] IV127                                                              */
      __IOM uint32_t IV126      : 1;            /*!< [1..1] IV126                                                              */
      __IOM uint32_t IV125      : 1;            /*!< [2..2] IV125                                                              */
      __IOM uint32_t IV124      : 1;            /*!< [3..3] IV124                                                              */
      __IOM uint32_t IV123      : 1;            /*!< [4..4] IV123                                                              */
      __IOM uint32_t IV122      : 1;            /*!< [5..5] IV122                                                              */
      __IOM uint32_t IV121      : 1;            /*!< [6..6] IV121                                                              */
      __IOM uint32_t IV120      : 1;            /*!< [7..7] IV120                                                              */
      __IOM uint32_t IV119      : 1;            /*!< [8..8] IV119                                                              */
      __IOM uint32_t IV118      : 1;            /*!< [9..9] IV118                                                              */
      __IOM uint32_t IV117      : 1;            /*!< [10..10] IV117                                                            */
      __IOM uint32_t IV116      : 1;            /*!< [11..11] IV116                                                            */
      __IOM uint32_t IV115      : 1;            /*!< [12..12] IV115                                                            */
      __IOM uint32_t IV114      : 1;            /*!< [13..13] IV114                                                            */
      __IOM uint32_t IV113      : 1;            /*!< [14..14] IV113                                                            */
      __IOM uint32_t IV112      : 1;            /*!< [15..15] IV112                                                            */
      __IOM uint32_t IV111      : 1;            /*!< [16..16] IV111                                                            */
      __IOM uint32_t IV110      : 1;            /*!< [17..17] IV110                                                            */
      __IOM uint32_t IV109      : 1;            /*!< [18..18] IV109                                                            */
      __IOM uint32_t IV108      : 1;            /*!< [19..19] IV108                                                            */
      __IOM uint32_t IV107      : 1;            /*!< [20..20] IV107                                                            */
      __IOM uint32_t IV106      : 1;            /*!< [21..21] IV106                                                            */
      __IOM uint32_t IV105      : 1;            /*!< [22..22] IV105                                                            */
      __IOM uint32_t IV104      : 1;            /*!< [23..23] IV104                                                            */
      __IOM uint32_t IV103      : 1;            /*!< [24..24] IV103                                                            */
      __IOM uint32_t IV102      : 1;            /*!< [25..25] IV102                                                            */
      __IOM uint32_t IV101      : 1;            /*!< [26..26] IV101                                                            */
      __IOM uint32_t IV100      : 1;            /*!< [27..27] IV100                                                            */
      __IOM uint32_t IV99       : 1;            /*!< [28..28] IV99                                                             */
      __IOM uint32_t IV98       : 1;            /*!< [29..29] IV98                                                             */
      __IOM uint32_t IV97       : 1;            /*!< [30..30] IV97                                                             */
      __IOM uint32_t IV96       : 1;            /*!< [31..31] IV96                                                             */
    } IV1RR_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM0R;                  /*!< (@ 0x00000050) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM0R : 32;           /*!< [31..0] CSGCMCCM0R                                                        */
    } CSGCMCCM0R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM1R;                  /*!< (@ 0x00000054) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM1R : 32;           /*!< [31..0] CSGCMCCM1R                                                        */
    } CSGCMCCM1R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM2R;                  /*!< (@ 0x00000058) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM2R : 32;           /*!< [31..0] CSGCMCCM2R                                                        */
    } CSGCMCCM2R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM3R;                  /*!< (@ 0x0000005C) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM3R : 32;           /*!< [31..0] CSGCMCCM3R                                                        */
    } CSGCMCCM3R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM4R;                  /*!< (@ 0x00000060) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM4R : 32;           /*!< [31..0] CSGCMCCM4R                                                        */
    } CSGCMCCM4R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM5R;                  /*!< (@ 0x00000064) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM5R : 32;           /*!< [31..0] CSGCMCCM5R                                                        */
    } CSGCMCCM5R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM6R;                  /*!< (@ 0x00000068) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM6R : 32;           /*!< [31..0] CSGCMCCM6R                                                        */
    } CSGCMCCM6R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCMCCM7R;                  /*!< (@ 0x0000006C) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCMCCM7R : 32;           /*!< [31..0] CSGCMCCM7R                                                        */
    } CSGCMCCM7R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM0R;                     /*!< (@ 0x00000070) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM0R    : 32;           /*!< [31..0] CSGCM0R                                                           */
    } CSGCM0R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM1R;                     /*!< (@ 0x00000074) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM1R    : 32;           /*!< [31..0] CSGCM1R                                                           */
    } CSGCM1R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM2R;                     /*!< (@ 0x00000078) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM2R    : 32;           /*!< [31..0] CSGCM2R                                                           */
    } CSGCM2R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM3R;                     /*!< (@ 0x0000007C) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM3R    : 32;           /*!< [31..0] CSGCM3R                                                           */
    } CSGCM3R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM4R;                     /*!< (@ 0x00000080) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM4R    : 32;           /*!< [31..0] CSGCM4R                                                           */
    } CSGCM4R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM5R;                     /*!< (@ 0x00000084) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM5R    : 32;           /*!< [31..0] CSGCM5R                                                           */
    } CSGCM5R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM6R;                     /*!< (@ 0x00000088) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM6R    : 32;           /*!< [31..0] CSGCM6R                                                           */
    } CSGCM6R_b;
  } ;
  
  union {
    __IOM uint32_t CSGCM7R;                     /*!< (@ 0x0000008C) context swap register                                      */
    
    struct {
      __IOM uint32_t CSGCM7R    : 32;           /*!< [31..0] CSGCM7R                                                           */
    } CSGCM7R_b;
  } ;
} CRYP_Type;                                    /*!< Size = 144 (0x90)                                                         */



/* =========================================================================================================================== */
/* ================                                           DCMI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Digital camera interface (DCMI)
  */

typedef struct {                                /*!< (@ 0x48020000) DCMI Structure                                             */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CAPTURE    : 1;            /*!< [0..0] Capture enable                                                     */
      __IOM uint32_t CM         : 1;            /*!< [1..1] Capture mode                                                       */
      __IOM uint32_t CROP       : 1;            /*!< [2..2] Crop feature                                                       */
      __IOM uint32_t JPEG       : 1;            /*!< [3..3] JPEG format                                                        */
      __IOM uint32_t ESS        : 1;            /*!< [4..4] Embedded synchronization select                                    */
      __IOM uint32_t PCKPOL     : 1;            /*!< [5..5] Pixel clock polarity                                               */
      __IOM uint32_t HSPOL      : 1;            /*!< [6..6] Horizontal synchronization polarity                                */
      __IOM uint32_t VSPOL      : 1;            /*!< [7..7] Vertical synchronization polarity                                  */
      __IOM uint32_t FCRC       : 2;            /*!< [9..8] Frame capture rate control                                         */
      __IOM uint32_t EDM        : 2;            /*!< [11..10] Extended data mode                                               */
            uint32_t            : 2;
      __IOM uint32_t ENABLE     : 1;            /*!< [14..14] DCMI enable                                                      */
            uint32_t            : 1;
      __IOM uint32_t BSM        : 2;            /*!< [17..16] Byte Select mode                                                 */
      __IOM uint32_t OEBS       : 1;            /*!< [18..18] Odd/Even Byte Select (Byte Select Start)                         */
      __IOM uint32_t LSM        : 1;            /*!< [19..19] Line Select mode                                                 */
      __IOM uint32_t OELS       : 1;            /*!< [20..20] Odd/Even Line Select (Line Select Start)                         */
            uint32_t            : 11;
    } CR_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< (@ 0x00000004) status register                                            */
    
    struct {
      __IM  uint32_t HSYNC      : 1;            /*!< [0..0] HSYNC                                                              */
      __IM  uint32_t VSYNC      : 1;            /*!< [1..1] VSYNC                                                              */
      __IM  uint32_t FNE        : 1;            /*!< [2..2] FIFO not empty                                                     */
            uint32_t            : 29;
    } SR_b;
  } ;
  
  union {
    __IM  uint32_t RIS;                         /*!< (@ 0x00000008) raw interrupt status register                              */
    
    struct {
      __IM  uint32_t FRAME_RIS  : 1;            /*!< [0..0] Capture complete raw interrupt status                              */
      __IM  uint32_t OVR_RIS    : 1;            /*!< [1..1] Overrun raw interrupt status                                       */
      __IM  uint32_t ERR_RIS    : 1;            /*!< [2..2] Synchronization error raw interrupt status                         */
      __IM  uint32_t VSYNC_RIS  : 1;            /*!< [3..3] VSYNC raw interrupt status                                         */
      __IM  uint32_t LINE_RIS   : 1;            /*!< [4..4] Line raw interrupt status                                          */
            uint32_t            : 27;
    } RIS_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x0000000C) interrupt enable register                                  */
    
    struct {
      __IOM uint32_t FRAME_IE   : 1;            /*!< [0..0] Capture complete interrupt enable                                  */
      __IOM uint32_t OVR_IE     : 1;            /*!< [1..1] Overrun interrupt enable                                           */
      __IOM uint32_t ERR_IE     : 1;            /*!< [2..2] Synchronization error interrupt enable                             */
      __IOM uint32_t VSYNC_IE   : 1;            /*!< [3..3] VSYNC interrupt enable                                             */
      __IOM uint32_t LINE_IE    : 1;            /*!< [4..4] Line interrupt enable                                              */
            uint32_t            : 27;
    } IER_b;
  } ;
  
  union {
    __IM  uint32_t MIS;                         /*!< (@ 0x00000010) masked interrupt status register                           */
    
    struct {
      __IM  uint32_t FRAME_MIS  : 1;            /*!< [0..0] Capture complete masked interrupt status                           */
      __IM  uint32_t OVR_MIS    : 1;            /*!< [1..1] Overrun masked interrupt status                                    */
      __IM  uint32_t ERR_MIS    : 1;            /*!< [2..2] Synchronization error masked interrupt status                      */
      __IM  uint32_t VSYNC_MIS  : 1;            /*!< [3..3] VSYNC masked interrupt status                                      */
      __IM  uint32_t LINE_MIS   : 1;            /*!< [4..4] Line masked interrupt status                                       */
            uint32_t            : 27;
    } MIS_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000014) interrupt clear register                                   */
    
    struct {
      __OM  uint32_t FRAME_ISC  : 1;            /*!< [0..0] Capture complete interrupt status clear                            */
      __OM  uint32_t OVR_ISC    : 1;            /*!< [1..1] Overrun interrupt status clear                                     */
      __OM  uint32_t ERR_ISC    : 1;            /*!< [2..2] Synchronization error interrupt status clear                       */
      __OM  uint32_t VSYNC_ISC  : 1;            /*!< [3..3] Vertical synch interrupt status clear                              */
      __OM  uint32_t LINE_ISC   : 1;            /*!< [4..4] line interrupt status clear                                        */
            uint32_t            : 27;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t ESCR;                        /*!< (@ 0x00000018) embedded synchronization code register                     */
    
    struct {
      __IOM uint32_t FSC        : 8;            /*!< [7..0] Frame start delimiter code                                         */
      __IOM uint32_t LSC        : 8;            /*!< [15..8] Line start delimiter code                                         */
      __IOM uint32_t LEC        : 8;            /*!< [23..16] Line end delimiter code                                          */
      __IOM uint32_t FEC        : 8;            /*!< [31..24] Frame end delimiter code                                         */
    } ESCR_b;
  } ;
  
  union {
    __IOM uint32_t ESUR;                        /*!< (@ 0x0000001C) embedded synchronization unmask register                   */
    
    struct {
      __IOM uint32_t FSU        : 8;            /*!< [7..0] Frame start delimiter unmask                                       */
      __IOM uint32_t LSU        : 8;            /*!< [15..8] Line start delimiter unmask                                       */
      __IOM uint32_t LEU        : 8;            /*!< [23..16] Line end delimiter unmask                                        */
      __IOM uint32_t FEU        : 8;            /*!< [31..24] Frame end delimiter unmask                                       */
    } ESUR_b;
  } ;
  
  union {
    __IOM uint32_t CWSTRT;                      /*!< (@ 0x00000020) crop window start                                          */
    
    struct {
      __IOM uint32_t HOFFCNT    : 14;           /*!< [13..0] Horizontal offset count                                           */
            uint32_t            : 2;
      __IOM uint32_t VST        : 13;           /*!< [28..16] Vertical start line count                                        */
            uint32_t            : 3;
    } CWSTRT_b;
  } ;
  
  union {
    __IOM uint32_t CWSIZE;                      /*!< (@ 0x00000024) crop window size                                           */
    
    struct {
      __IOM uint32_t CAPCNT     : 14;           /*!< [13..0] Capture count                                                     */
            uint32_t            : 2;
      __IOM uint32_t VLINE      : 14;           /*!< [29..16] Vertical line count                                              */
            uint32_t            : 2;
    } CWSIZE_b;
  } ;
  
  union {
    __IM  uint32_t DR;                          /*!< (@ 0x00000028) data register                                              */
    
    struct {
      __IM  uint32_t Byte0      : 8;            /*!< [7..0] Data byte 0                                                        */
      __IM  uint32_t Byte1      : 8;            /*!< [15..8] Data byte 1                                                       */
      __IM  uint32_t Byte2      : 8;            /*!< [23..16] Data byte 2                                                      */
      __IM  uint32_t Byte3      : 8;            /*!< [31..24] Data byte 3                                                      */
    } DR_b;
  } ;
} DCMI_Type;                                    /*!< Size = 44 (0x2c)                                                          */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_GLOBAL                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_GLOBAL)
  */

typedef struct {                                /*!< (@ 0x40040000) OTG1_HS_GLOBAL Structure                                   */
  
  union {
    __IOM uint32_t OTG_HS_GOTGCTL;              /*!< (@ 0x00000000) OTG_HS control and status register                         */
    
    struct {
      __IM  uint32_t SRQSCS     : 1;            /*!< [0..0] Session request success                                            */
      __IOM uint32_t SRQ        : 1;            /*!< [1..1] Session request                                                    */
            uint32_t            : 6;
      __IM  uint32_t HNGSCS     : 1;            /*!< [8..8] Host negotiation success                                           */
      __IOM uint32_t HNPRQ      : 1;            /*!< [9..9] HNP request                                                        */
      __IOM uint32_t HSHNPEN    : 1;            /*!< [10..10] Host set HNP enable                                              */
      __IOM uint32_t DHNPEN     : 1;            /*!< [11..11] Device HNP enabled                                               */
      __IOM uint32_t EHEN       : 1;            /*!< [12..12] Embedded host enable                                             */
            uint32_t            : 3;
      __IM  uint32_t CIDSTS     : 1;            /*!< [16..16] Connector ID status                                              */
      __IM  uint32_t DBCT       : 1;            /*!< [17..17] Long/short debounce time                                         */
      __IM  uint32_t ASVLD      : 1;            /*!< [18..18] A-session valid                                                  */
      __IM  uint32_t BSVLD      : 1;            /*!< [19..19] B-session valid                                                  */
            uint32_t            : 12;
    } OTG_HS_GOTGCTL_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GOTGINT;              /*!< (@ 0x00000004) OTG_HS interrupt register                                  */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t SEDET      : 1;            /*!< [2..2] Session end detected                                               */
            uint32_t            : 5;
      __IOM uint32_t SRSSCHG    : 1;            /*!< [8..8] Session request success status change                              */
      __IOM uint32_t HNSSCHG    : 1;            /*!< [9..9] Host negotiation success status change                             */
            uint32_t            : 7;
      __IOM uint32_t HNGDET     : 1;            /*!< [17..17] Host negotiation detected                                        */
      __IOM uint32_t ADTOCHG    : 1;            /*!< [18..18] A-device timeout change                                          */
      __IOM uint32_t DBCDNE     : 1;            /*!< [19..19] Debounce done                                                    */
      __IOM uint32_t IDCHNG     : 1;            /*!< [20..20] ID input pin changed                                             */
            uint32_t            : 11;
    } OTG_HS_GOTGINT_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GAHBCFG;              /*!< (@ 0x00000008) OTG_HS AHB configuration register                          */
    
    struct {
      __IOM uint32_t GINT       : 1;            /*!< [0..0] Global interrupt mask                                              */
      __IOM uint32_t HBSTLEN    : 4;            /*!< [4..1] Burst length/type                                                  */
      __IOM uint32_t DMAEN      : 1;            /*!< [5..5] DMA enable                                                         */
            uint32_t            : 1;
      __IOM uint32_t TXFELVL    : 1;            /*!< [7..7] TxFIFO empty level                                                 */
      __IOM uint32_t PTXFELVL   : 1;            /*!< [8..8] Periodic TxFIFO empty level                                        */
            uint32_t            : 23;
    } OTG_HS_GAHBCFG_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GUSBCFG;              /*!< (@ 0x0000000C) OTG_HS USB configuration register                          */
    
    struct {
      __IOM uint32_t TOCAL      : 3;            /*!< [2..0] FS timeout calibration                                             */
            uint32_t            : 3;
      __OM  uint32_t PHYSEL     : 1;            /*!< [6..6] USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial
                                                     transceiver select                                                        */
            uint32_t            : 1;
      __IOM uint32_t SRPCAP     : 1;            /*!< [8..8] SRP-capable                                                        */
      __IOM uint32_t HNPCAP     : 1;            /*!< [9..9] HNP-capable                                                        */
      __IOM uint32_t TRDT       : 4;            /*!< [13..10] USB turnaround time                                              */
            uint32_t            : 1;
      __IOM uint32_t PHYLPCS    : 1;            /*!< [15..15] PHY Low-power clock select                                       */
            uint32_t            : 1;
      __IOM uint32_t ULPIFSLS   : 1;            /*!< [17..17] ULPI FS/LS select                                                */
      __IOM uint32_t ULPIAR     : 1;            /*!< [18..18] ULPI Auto-resume                                                 */
      __IOM uint32_t ULPICSM    : 1;            /*!< [19..19] ULPI Clock SuspendM                                              */
      __IOM uint32_t ULPIEVBUSD : 1;            /*!< [20..20] ULPI External VBUS Drive                                         */
      __IOM uint32_t ULPIEVBUSI : 1;            /*!< [21..21] ULPI external VBUS indicator                                     */
      __IOM uint32_t TSDPS      : 1;            /*!< [22..22] TermSel DLine pulsing selection                                  */
      __IOM uint32_t PCCI       : 1;            /*!< [23..23] Indicator complement                                             */
      __IOM uint32_t PTCI       : 1;            /*!< [24..24] Indicator pass through                                           */
      __IOM uint32_t ULPIIPD    : 1;            /*!< [25..25] ULPI interface protect disable                                   */
            uint32_t            : 3;
      __IOM uint32_t FHMOD      : 1;            /*!< [29..29] Forced host mode                                                 */
      __IOM uint32_t FDMOD      : 1;            /*!< [30..30] Forced peripheral mode                                           */
            uint32_t            : 1;
    } OTG_HS_GUSBCFG_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GRSTCTL;              /*!< (@ 0x00000010) OTG_HS reset register                                      */
    
    struct {
      __IOM uint32_t CSRST      : 1;            /*!< [0..0] Core soft reset                                                    */
      __IOM uint32_t HSRST      : 1;            /*!< [1..1] HCLK soft reset                                                    */
      __IOM uint32_t FCRST      : 1;            /*!< [2..2] Host frame counter reset                                           */
            uint32_t            : 1;
      __IOM uint32_t RXFFLSH    : 1;            /*!< [4..4] RxFIFO flush                                                       */
      __IOM uint32_t TXFFLSH    : 1;            /*!< [5..5] TxFIFO flush                                                       */
      __IOM uint32_t TXFNUM     : 5;            /*!< [10..6] TxFIFO number                                                     */
            uint32_t            : 19;
      __IM  uint32_t DMAREQ     : 1;            /*!< [30..30] DMA request signal enabled for USB OTG HS                        */
      __IM  uint32_t AHBIDL     : 1;            /*!< [31..31] AHB master idle                                                  */
    } OTG_HS_GRSTCTL_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GINTSTS;              /*!< (@ 0x00000014) OTG_HS core interrupt register                             */
    
    struct {
      __IM  uint32_t CMOD       : 1;            /*!< [0..0] Current mode of operation                                          */
      __IOM uint32_t MMIS       : 1;            /*!< [1..1] Mode mismatch interrupt                                            */
      __IM  uint32_t OTGINT     : 1;            /*!< [2..2] OTG interrupt                                                      */
      __IOM uint32_t SOF        : 1;            /*!< [3..3] Start of frame                                                     */
      __IM  uint32_t RXFLVL     : 1;            /*!< [4..4] RxFIFO nonempty                                                    */
      __IM  uint32_t NPTXFE     : 1;            /*!< [5..5] Nonperiodic TxFIFO empty                                           */
      __IM  uint32_t GINAKEFF   : 1;            /*!< [6..6] Global IN nonperiodic NAK effective                                */
      __IM  uint32_t BOUTNAKEFF : 1;            /*!< [7..7] Global OUT NAK effective                                           */
            uint32_t            : 2;
      __IOM uint32_t ESUSP      : 1;            /*!< [10..10] Early suspend                                                    */
      __IOM uint32_t USBSUSP    : 1;            /*!< [11..11] USB suspend                                                      */
      __IOM uint32_t USBRST     : 1;            /*!< [12..12] USB reset                                                        */
      __IOM uint32_t ENUMDNE    : 1;            /*!< [13..13] Enumeration done                                                 */
      __IOM uint32_t ISOODRP    : 1;            /*!< [14..14] Isochronous OUT packet dropped interrupt                         */
      __IOM uint32_t EOPF       : 1;            /*!< [15..15] End of periodic frame interrupt                                  */
            uint32_t            : 2;
      __IM  uint32_t IEPINT     : 1;            /*!< [18..18] IN endpoint interrupt                                            */
      __IM  uint32_t OEPINT     : 1;            /*!< [19..19] OUT endpoint interrupt                                           */
      __IOM uint32_t IISOIXFR   : 1;            /*!< [20..20] Incomplete isochronous IN transfer                               */
      __IOM uint32_t PXFR_INCOMPISOOUT : 1;     /*!< [21..21] Incomplete periodic transfer                                     */
      __IOM uint32_t DATAFSUSP  : 1;            /*!< [22..22] Data fetch suspended                                             */
            uint32_t            : 1;
      __IM  uint32_t HPRTINT    : 1;            /*!< [24..24] Host port interrupt                                              */
      __IM  uint32_t HCINT      : 1;            /*!< [25..25] Host channels interrupt                                          */
      __IM  uint32_t PTXFE      : 1;            /*!< [26..26] Periodic TxFIFO empty                                            */
            uint32_t            : 1;
      __IOM uint32_t CIDSCHG    : 1;            /*!< [28..28] Connector ID status change                                       */
      __IOM uint32_t DISCINT    : 1;            /*!< [29..29] Disconnect detected interrupt                                    */
      __IOM uint32_t SRQINT     : 1;            /*!< [30..30] Session request/new session detected interrupt                   */
      __IOM uint32_t WKUINT     : 1;            /*!< [31..31] Resume/remote wakeup detected interrupt                          */
    } OTG_HS_GINTSTS_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_GINTMSK;              /*!< (@ 0x00000018) OTG_HS interrupt mask register                             */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t MMISM      : 1;            /*!< [1..1] Mode mismatch interrupt mask                                       */
      __IOM uint32_t OTGINT     : 1;            /*!< [2..2] OTG interrupt mask                                                 */
      __IOM uint32_t SOFM       : 1;            /*!< [3..3] Start of frame mask                                                */
      __IOM uint32_t RXFLVLM    : 1;            /*!< [4..4] Receive FIFO nonempty mask                                         */
      __IOM uint32_t NPTXFEM    : 1;            /*!< [5..5] Nonperiodic TxFIFO empty mask                                      */
      __IOM uint32_t GINAKEFFM  : 1;            /*!< [6..6] Global nonperiodic IN NAK effective mask                           */
      __IOM uint32_t GONAKEFFM  : 1;            /*!< [7..7] Global OUT NAK effective mask                                      */
            uint32_t            : 2;
      __IOM uint32_t ESUSPM     : 1;            /*!< [10..10] Early suspend mask                                               */
      __IOM uint32_t USBSUSPM   : 1;            /*!< [11..11] USB suspend mask                                                 */
      __IOM uint32_t USBRST     : 1;            /*!< [12..12] USB reset mask                                                   */
      __IOM uint32_t ENUMDNEM   : 1;            /*!< [13..13] Enumeration done mask                                            */
      __IOM uint32_t ISOODRPM   : 1;            /*!< [14..14] Isochronous OUT packet dropped interrupt mask                    */
      __IOM uint32_t EOPFM      : 1;            /*!< [15..15] End of periodic frame interrupt mask                             */
            uint32_t            : 2;
      __IOM uint32_t IEPINT     : 1;            /*!< [18..18] IN endpoints interrupt mask                                      */
      __IOM uint32_t OEPINT     : 1;            /*!< [19..19] OUT endpoints interrupt mask                                     */
      __IOM uint32_t IISOIXFRM  : 1;            /*!< [20..20] Incomplete isochronous IN transfer mask                          */
      __IOM uint32_t PXFRM_IISOOXFRM : 1;       /*!< [21..21] Incomplete periodic transfer mask                                */
      __IOM uint32_t FSUSPM     : 1;            /*!< [22..22] Data fetch suspended mask                                        */
      __IOM uint32_t RSTDE      : 1;            /*!< [23..23] Reset detected interrupt mask                                    */
      __IM  uint32_t PRTIM      : 1;            /*!< [24..24] Host port interrupt mask                                         */
      __IOM uint32_t HCIM       : 1;            /*!< [25..25] Host channels interrupt mask                                     */
      __IOM uint32_t PTXFEM     : 1;            /*!< [26..26] Periodic TxFIFO empty mask                                       */
      __IOM uint32_t LPMINTM    : 1;            /*!< [27..27] LPM interrupt mask                                               */
      __IOM uint32_t CIDSCHGM   : 1;            /*!< [28..28] Connector ID status change mask                                  */
      __IOM uint32_t DISCINT    : 1;            /*!< [29..29] Disconnect detected interrupt mask                               */
      __IOM uint32_t SRQIM      : 1;            /*!< [30..30] Session request/new session detected interrupt mask              */
      __IOM uint32_t WUIM       : 1;            /*!< [31..31] Resume/remote wakeup detected interrupt mask                     */
    } OTG_HS_GINTMSK_b;
  } ;
  
  union {
    union {
      __IM  uint32_t OTG_HS_GRXSTSR_Host;       /*!< (@ 0x0000001C) OTG_HS Receive status debug read register (host
                                                                    mode)                                                      */
      
      struct {
        __IM  uint32_t CHNUM    : 4;            /*!< [3..0] Channel number                                                     */
        __IM  uint32_t BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32_t DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32_t PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
              uint32_t          : 11;
      } OTG_HS_GRXSTSR_Host_b;
    } ;
    
    union {
      __IM  uint32_t OTG_HS_GRXSTSR_Device;     /*!< (@ 0x0000001C) OTG_HS Receive status debug read register (peripheral
                                                                    mode mode)                                                 */
      
      struct {
        __IM  uint32_t EPNUM    : 4;            /*!< [3..0] Endpoint number                                                    */
        __IM  uint32_t BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32_t DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32_t PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
        __IM  uint32_t FRMNUM   : 4;            /*!< [24..21] Frame number                                                     */
              uint32_t          : 7;
      } OTG_HS_GRXSTSR_Device_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t OTG_HS_GRXSTSP_Host;       /*!< (@ 0x00000020) OTG_HS status read and pop register (host mode)            */
      
      struct {
        __IM  uint32_t CHNUM    : 4;            /*!< [3..0] Channel number                                                     */
        __IM  uint32_t BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32_t DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32_t PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
              uint32_t          : 11;
      } OTG_HS_GRXSTSP_Host_b;
    } ;
    
    union {
      __IM  uint32_t OTG_HS_GRXSTSP_Device;     /*!< (@ 0x00000020) OTG_HS status read and pop register (peripheral
                                                                    mode)                                                      */
      
      struct {
        __IM  uint32_t EPNUM    : 4;            /*!< [3..0] Endpoint number                                                    */
        __IM  uint32_t BCNT     : 11;           /*!< [14..4] Byte count                                                        */
        __IM  uint32_t DPID     : 2;            /*!< [16..15] Data PID                                                         */
        __IM  uint32_t PKTSTS   : 4;            /*!< [20..17] Packet status                                                    */
        __IM  uint32_t FRMNUM   : 4;            /*!< [24..21] Frame number                                                     */
              uint32_t          : 7;
      } OTG_HS_GRXSTSP_Device_b;
    } ;
  };
  
  union {
    __IOM uint32_t OTG_HS_GRXFSIZ;              /*!< (@ 0x00000024) OTG_HS Receive FIFO size register                          */
    
    struct {
      __IOM uint32_t RXFD       : 16;           /*!< [15..0] RxFIFO depth                                                      */
            uint32_t            : 16;
    } OTG_HS_GRXFSIZ_b;
  } ;
  
  union {
    union {
      __IOM uint32_t OTG_HS_HNPTXFSIZ_Host;     /*!< (@ 0x00000028) OTG_HS nonperiodic transmit FIFO size register
                                                                    (host mode)                                                */
      
      struct {
        __IOM uint32_t NPTXFSA  : 16;           /*!< [15..0] Nonperiodic transmit RAM start address                            */
        __IOM uint32_t NPTXFD   : 16;           /*!< [31..16] Nonperiodic TxFIFO depth                                         */
      } OTG_HS_HNPTXFSIZ_Host_b;
    } ;
    
    union {
      __IOM uint32_t OTG_HS_DIEPTXF0_Device;    /*!< (@ 0x00000028) Endpoint 0 transmit FIFO size (peripheral mode)            */
      
      struct {
        __IOM uint32_t TX0FSA   : 16;           /*!< [15..0] Endpoint 0 transmit RAM start address                             */
        __IOM uint32_t TX0FD    : 16;           /*!< [31..16] Endpoint 0 TxFIFO depth                                          */
      } OTG_HS_DIEPTXF0_Device_b;
    } ;
  };
  
  union {
    __IM  uint32_t OTG_HS_GNPTXSTS;             /*!< (@ 0x0000002C) OTG_HS nonperiodic transmit FIFO/queue status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t NPTXFSAV   : 16;           /*!< [15..0] Nonperiodic TxFIFO space available                                */
      __IM  uint32_t NPTQXSAV   : 8;            /*!< [23..16] Nonperiodic transmit request queue space available               */
      __IM  uint32_t NPTXQTOP   : 7;            /*!< [30..24] Top of the nonperiodic transmit request queue                    */
            uint32_t            : 1;
    } OTG_HS_GNPTXSTS_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t OTG_HS_GCCFG;                /*!< (@ 0x00000038) OTG_HS general core configuration register                 */
    
    struct {
      __IOM uint32_t DCDET      : 1;            /*!< [0..0] Data contact detection (DCD) status                                */
      __IOM uint32_t PDET       : 1;            /*!< [1..1] Primary detection (PD) status                                      */
      __IOM uint32_t SDET       : 1;            /*!< [2..2] Secondary detection (SD) status                                    */
      __IOM uint32_t PS2DET     : 1;            /*!< [3..3] DM pull-up detection status                                        */
            uint32_t            : 12;
      __IOM uint32_t PWRDWN     : 1;            /*!< [16..16] Power down                                                       */
      __IOM uint32_t BCDEN      : 1;            /*!< [17..17] Battery charging detector (BCD) enable                           */
      __IOM uint32_t DCDEN      : 1;            /*!< [18..18] Data contact detection (DCD) mode enable                         */
      __IOM uint32_t PDEN       : 1;            /*!< [19..19] Primary detection (PD) mode enable                               */
      __IOM uint32_t SDEN       : 1;            /*!< [20..20] Secondary detection (SD) mode enable                             */
      __IOM uint32_t VBDEN      : 1;            /*!< [21..21] USB VBUS detection enable                                        */
            uint32_t            : 10;
    } OTG_HS_GCCFG_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_CID;                  /*!< (@ 0x0000003C) OTG_HS core ID register                                    */
    
    struct {
      __IOM uint32_t PRODUCT_ID : 32;           /*!< [31..0] Product ID field                                                  */
    } OTG_HS_CID_b;
  } ;
  __IM  uint32_t  RESERVED1[5];
  
  union {
    __IOM uint32_t OTG_HS_GLPMCFG;              /*!< (@ 0x00000054) OTG core LPM configuration register                        */
    
    struct {
      __IOM uint32_t LPMEN      : 1;            /*!< [0..0] LPM support enable                                                 */
      __IOM uint32_t LPMACK     : 1;            /*!< [1..1] LPM token acknowledge enable                                       */
      __IM  uint32_t BESL       : 4;            /*!< [5..2] Best effort service latency                                        */
      __IM  uint32_t REMWAKE    : 1;            /*!< [6..6] bRemoteWake value                                                  */
      __IOM uint32_t L1SSEN     : 1;            /*!< [7..7] L1 Shallow Sleep enable                                            */
      __IOM uint32_t BESLTHRS   : 4;            /*!< [11..8] BESL threshold                                                    */
      __IOM uint32_t L1DSEN     : 1;            /*!< [12..12] L1 deep sleep enable                                             */
      __IM  uint32_t LPMRST     : 2;            /*!< [14..13] LPM response                                                     */
      __IM  uint32_t SLPSTS     : 1;            /*!< [15..15] Port sleep status                                                */
      __IM  uint32_t L1RSMOK    : 1;            /*!< [16..16] Sleep State Resume OK                                            */
      __IOM uint32_t LPMCHIDX   : 4;            /*!< [20..17] LPM Channel Index                                                */
      __IOM uint32_t LPMRCNT    : 3;            /*!< [23..21] LPM retry count                                                  */
      __IOM uint32_t SNDLPM     : 1;            /*!< [24..24] Send LPM transaction                                             */
      __IM  uint32_t LPMRCNTSTS : 3;            /*!< [27..25] LPM retry count status                                           */
      __IOM uint32_t ENBESL     : 1;            /*!< [28..28] Enable best effort service latency                               */
            uint32_t            : 3;
    } OTG_HS_GLPMCFG_b;
  } ;
  __IM  uint32_t  RESERVED2[42];
  
  union {
    __IOM uint32_t OTG_HS_HPTXFSIZ;             /*!< (@ 0x00000100) OTG_HS Host periodic transmit FIFO size register           */
    
    struct {
      __IOM uint32_t PTXSA      : 16;           /*!< [15..0] Host periodic TxFIFO start address                                */
      __IOM uint32_t PTXFD      : 16;           /*!< [31..16] Host periodic TxFIFO depth                                       */
    } OTG_HS_HPTXFSIZ_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF1;             /*!< (@ 0x00000104) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF2;             /*!< (@ 0x00000108) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF2_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF3;             /*!< (@ 0x0000011C) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF4;             /*!< (@ 0x00000120) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF5;             /*!< (@ 0x00000124) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF6;             /*!< (@ 0x00000128) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTXF7;             /*!< (@ 0x0000012C) OTG_HS device IN endpoint transmit FIFO size
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTXSA   : 16;           /*!< [15..0] IN endpoint FIFOx transmit RAM start address                      */
      __IOM uint32_t INEPTXFD   : 16;           /*!< [31..16] IN endpoint TxFIFO depth                                         */
    } OTG_HS_DIEPTXF7_b;
  } ;
} OTG1_HS_GLOBAL_Type;                          /*!< Size = 304 (0x130)                                                        */



/* =========================================================================================================================== */
/* ================                                       OTG1_HS_HOST                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_HOST)
  */

typedef struct {                                /*!< (@ 0x40040400) OTG1_HS_HOST Structure                                     */
  
  union {
    __IOM uint32_t OTG_HS_HCFG;                 /*!< (@ 0x00000000) OTG_HS host configuration register                         */
    
    struct {
      __IOM uint32_t FSLSPCS    : 2;            /*!< [1..0] FS/LS PHY clock select                                             */
      __IM  uint32_t FSLSS      : 1;            /*!< [2..2] FS- and LS-only support                                            */
            uint32_t            : 29;
    } OTG_HS_HCFG_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HFIR;                 /*!< (@ 0x00000004) OTG_HS Host frame interval register                        */
    
    struct {
      __IOM uint32_t FRIVL      : 16;           /*!< [15..0] Frame interval                                                    */
            uint32_t            : 16;
    } OTG_HS_HFIR_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_HFNUM;                /*!< (@ 0x00000008) OTG_HS host frame number/frame time remaining
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t FRNUM      : 16;           /*!< [15..0] Frame number                                                      */
      __IM  uint32_t FTREM      : 16;           /*!< [31..16] Frame time remaining                                             */
    } OTG_HS_HFNUM_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t OTG_HS_HPTXSTS;              /*!< (@ 0x00000010) OTG_HS_Host periodic transmit FIFO/queue status
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t PTXFSAVL   : 16;           /*!< [15..0] Periodic transmit data FIFO space available                       */
      __IM  uint32_t PTXQSAV    : 8;            /*!< [23..16] Periodic transmit request queue space available                  */
      __IM  uint32_t PTXQTOP    : 8;            /*!< [31..24] Top of the periodic transmit request queue                       */
    } OTG_HS_HPTXSTS_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_HAINT;                /*!< (@ 0x00000014) OTG_HS Host all channels interrupt register                */
    
    struct {
      __IM  uint32_t HAINT      : 16;           /*!< [15..0] Channel interrupts                                                */
            uint32_t            : 16;
    } OTG_HS_HAINT_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HAINTMSK;             /*!< (@ 0x00000018) OTG_HS host all channels interrupt mask register           */
    
    struct {
      __IOM uint32_t HAINTM     : 16;           /*!< [15..0] Channel interrupt mask                                            */
            uint32_t            : 16;
    } OTG_HS_HAINTMSK_b;
  } ;
  __IM  uint32_t  RESERVED1[9];
  
  union {
    __IOM uint32_t OTG_HS_HPRT;                 /*!< (@ 0x00000040) OTG_HS host port control and status register               */
    
    struct {
      __IM  uint32_t PCSTS      : 1;            /*!< [0..0] Port connect status                                                */
      __IOM uint32_t PCDET      : 1;            /*!< [1..1] Port connect detected                                              */
      __IOM uint32_t PENA       : 1;            /*!< [2..2] Port enable                                                        */
      __IOM uint32_t PENCHNG    : 1;            /*!< [3..3] Port enable/disable change                                         */
      __IM  uint32_t POCA       : 1;            /*!< [4..4] Port overcurrent active                                            */
      __IOM uint32_t POCCHNG    : 1;            /*!< [5..5] Port overcurrent change                                            */
      __IOM uint32_t PRES       : 1;            /*!< [6..6] Port resume                                                        */
      __IOM uint32_t PSUSP      : 1;            /*!< [7..7] Port suspend                                                       */
      __IOM uint32_t PRST       : 1;            /*!< [8..8] Port reset                                                         */
            uint32_t            : 1;
      __IM  uint32_t PLSTS      : 2;            /*!< [11..10] Port line status                                                 */
      __IOM uint32_t PPWR       : 1;            /*!< [12..12] Port power                                                       */
      __IOM uint32_t PTCTL      : 4;            /*!< [16..13] Port test control                                                */
      __IM  uint32_t PSPD       : 2;            /*!< [18..17] Port speed                                                       */
            uint32_t            : 13;
    } OTG_HS_HPRT_b;
  } ;
  __IM  uint32_t  RESERVED2[47];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR0;              /*!< (@ 0x00000100) OTG_HS host channel-0 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT0;              /*!< (@ 0x00000104) OTG_HS host channel-0 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT0;               /*!< (@ 0x00000108) OTG_HS host channel-11 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK0;            /*!< (@ 0x0000010C) OTG_HS host channel-11 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ0;              /*!< (@ 0x00000110) OTG_HS host channel-11 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA0;               /*!< (@ 0x00000114) OTG_HS host channel-0 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA0_b;
  } ;
  __IM  uint32_t  RESERVED3[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR1;              /*!< (@ 0x00000120) OTG_HS host channel-1 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT1;              /*!< (@ 0x00000124) OTG_HS host channel-1 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT1;               /*!< (@ 0x00000128) OTG_HS host channel-1 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK1;            /*!< (@ 0x0000012C) OTG_HS host channel-1 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ1;              /*!< (@ 0x00000130) OTG_HS host channel-1 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA1;               /*!< (@ 0x00000134) OTG_HS host channel-1 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA1_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR2;              /*!< (@ 0x00000140) OTG_HS host channel-2 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT2;              /*!< (@ 0x00000144) OTG_HS host channel-2 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT2;               /*!< (@ 0x00000148) OTG_HS host channel-2 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK2;            /*!< (@ 0x0000014C) OTG_HS host channel-2 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ2;              /*!< (@ 0x00000150) OTG_HS host channel-2 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA2;               /*!< (@ 0x00000154) OTG_HS host channel-2 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA2_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR3;              /*!< (@ 0x00000160) OTG_HS host channel-3 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT3;              /*!< (@ 0x00000164) OTG_HS host channel-3 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT3;               /*!< (@ 0x00000168) OTG_HS host channel-3 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK3;            /*!< (@ 0x0000016C) OTG_HS host channel-3 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ3;              /*!< (@ 0x00000170) OTG_HS host channel-3 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA3;               /*!< (@ 0x00000174) OTG_HS host channel-3 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA3_b;
  } ;
  __IM  uint32_t  RESERVED6[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR4;              /*!< (@ 0x00000180) OTG_HS host channel-4 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT4;              /*!< (@ 0x00000184) OTG_HS host channel-4 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT4;               /*!< (@ 0x00000188) OTG_HS host channel-4 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK4;            /*!< (@ 0x0000018C) OTG_HS host channel-4 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ4;              /*!< (@ 0x00000190) OTG_HS host channel-4 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA4;               /*!< (@ 0x00000194) OTG_HS host channel-4 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA4_b;
  } ;
  __IM  uint32_t  RESERVED7[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR5;              /*!< (@ 0x000001A0) OTG_HS host channel-5 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT5;              /*!< (@ 0x000001A4) OTG_HS host channel-5 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT5;               /*!< (@ 0x000001A8) OTG_HS host channel-5 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK5;            /*!< (@ 0x000001AC) OTG_HS host channel-5 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ5;              /*!< (@ 0x000001B0) OTG_HS host channel-5 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ5_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA5;               /*!< (@ 0x000001B4) OTG_HS host channel-5 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA5_b;
  } ;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR6;              /*!< (@ 0x000001C0) OTG_HS host channel-6 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT6;              /*!< (@ 0x000001C4) OTG_HS host channel-6 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT6;               /*!< (@ 0x000001C8) OTG_HS host channel-6 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK6;            /*!< (@ 0x000001CC) OTG_HS host channel-6 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ6;              /*!< (@ 0x000001D0) OTG_HS host channel-6 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ6_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA6;               /*!< (@ 0x000001D4) OTG_HS host channel-6 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA6_b;
  } ;
  __IM  uint32_t  RESERVED9[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR7;              /*!< (@ 0x000001E0) OTG_HS host channel-7 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT7;              /*!< (@ 0x000001E4) OTG_HS host channel-7 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT7;               /*!< (@ 0x000001E8) OTG_HS host channel-7 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK7;            /*!< (@ 0x000001EC) OTG_HS host channel-7 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ7;              /*!< (@ 0x000001F0) OTG_HS host channel-7 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA7;               /*!< (@ 0x000001F4) OTG_HS host channel-7 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA7_b;
  } ;
  __IM  uint32_t  RESERVED10[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR8;              /*!< (@ 0x00000200) OTG_HS host channel-8 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR8_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT8;              /*!< (@ 0x00000204) OTG_HS host channel-8 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT8_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT8;               /*!< (@ 0x00000208) OTG_HS host channel-8 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT8_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK8;            /*!< (@ 0x0000020C) OTG_HS host channel-8 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK8_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ8;              /*!< (@ 0x00000210) OTG_HS host channel-8 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ8_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA8;               /*!< (@ 0x00000214) OTG_HS host channel-8 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA8_b;
  } ;
  __IM  uint32_t  RESERVED11[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR9;              /*!< (@ 0x00000220) OTG_HS host channel-9 characteristics register             */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR9_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT9;              /*!< (@ 0x00000224) OTG_HS host channel-9 split control register               */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT9_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT9;               /*!< (@ 0x00000228) OTG_HS host channel-9 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT9_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK9;            /*!< (@ 0x0000022C) OTG_HS host channel-9 interrupt mask register              */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK9_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ9;              /*!< (@ 0x00000230) OTG_HS host channel-9 transfer size register               */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ9_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA9;               /*!< (@ 0x00000234) OTG_HS host channel-9 DMA address register                 */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA9_b;
  } ;
  __IM  uint32_t  RESERVED12[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR10;             /*!< (@ 0x00000240) OTG_HS host channel-10 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR10_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT10;             /*!< (@ 0x00000244) OTG_HS host channel-10 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT10_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT10;              /*!< (@ 0x00000248) OTG_HS host channel-10 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT10_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK10;           /*!< (@ 0x0000024C) OTG_HS host channel-10 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK10_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ10;             /*!< (@ 0x00000250) OTG_HS host channel-10 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ10_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA10;              /*!< (@ 0x00000254) OTG_HS host channel-10 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA10_b;
  } ;
  __IM  uint32_t  RESERVED13[2];
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR11;             /*!< (@ 0x00000260) OTG_HS host channel-11 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT11;             /*!< (@ 0x00000264) OTG_HS host channel-11 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT11;              /*!< (@ 0x00000268) OTG_HS host channel-11 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK11;           /*!< (@ 0x0000026C) OTG_HS host channel-11 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] response received interrupt mask                                   */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error mask                                             */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error mask                                                  */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ11;             /*!< (@ 0x00000270) OTG_HS host channel-11 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA11;              /*!< (@ 0x00000274) OTG_HS host channel-11 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA11_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR12;             /*!< (@ 0x00000278) OTG_HS host channel-12 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT12;             /*!< (@ 0x0000027C) OTG_HS host channel-12 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT12;              /*!< (@ 0x00000280) OTG_HS host channel-12 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK12;           /*!< (@ 0x00000284) OTG_HS host channel-12 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ12;             /*!< (@ 0x00000288) OTG_HS host channel-12 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA12;              /*!< (@ 0x0000028C) OTG_HS host channel-12 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA12_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR13;             /*!< (@ 0x00000290) OTG_HS host channel-13 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT13;             /*!< (@ 0x00000294) OTG_HS host channel-13 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT13;              /*!< (@ 0x00000298) OTG_HS host channel-13 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK13;           /*!< (@ 0x0000029C) OTG_HS host channel-13 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALLM response received interrupt mask                            */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ13;             /*!< (@ 0x000002A0) OTG_HS host channel-13 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA13;              /*!< (@ 0x000002A4) OTG_HS host channel-13 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA13_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR14;             /*!< (@ 0x000002A8) OTG_HS host channel-14 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT14;             /*!< (@ 0x000002AC) OTG_HS host channel-14 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT14;              /*!< (@ 0x000002B0) OTG_HS host channel-14 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK14;           /*!< (@ 0x000002B4) OTG_HS host channel-14 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALLM     : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAKM response received interrupt mask                              */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACKM response received/transmitted interrupt mask                  */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ14;             /*!< (@ 0x000002B8) OTG_HS host channel-14 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA14;              /*!< (@ 0x000002BC) OTG_HS host channel-14 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA14_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCCHAR15;             /*!< (@ 0x000002C0) OTG_HS host channel-15 characteristics register            */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
      __IOM uint32_t EPNUM      : 4;            /*!< [14..11] Endpoint number                                                  */
      __IOM uint32_t EPDIR      : 1;            /*!< [15..15] Endpoint direction                                               */
            uint32_t            : 1;
      __IOM uint32_t LSDEV      : 1;            /*!< [17..17] Low-speed device                                                 */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t MC         : 2;            /*!< [21..20] Multi Count (MC) / Error Count (EC)                              */
      __IOM uint32_t DAD        : 7;            /*!< [28..22] Device address                                                   */
      __IOM uint32_t ODDFRM     : 1;            /*!< [29..29] Odd frame                                                        */
      __IOM uint32_t CHDIS      : 1;            /*!< [30..30] Channel disable                                                  */
      __IOM uint32_t CHENA      : 1;            /*!< [31..31] Channel enable                                                   */
    } OTG_HS_HCCHAR15_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCSPLT15;             /*!< (@ 0x000002C4) OTG_HS host channel-15 split control register              */
    
    struct {
      __IOM uint32_t PRTADDR    : 7;            /*!< [6..0] Port address                                                       */
      __IOM uint32_t HUBADDR    : 7;            /*!< [13..7] Hub address                                                       */
      __IOM uint32_t XACTPOS    : 2;            /*!< [15..14] XACTPOS                                                          */
      __IOM uint32_t COMPLSPLT  : 1;            /*!< [16..16] Do complete split                                                */
            uint32_t            : 14;
      __IOM uint32_t SPLITEN    : 1;            /*!< [31..31] Split enable                                                     */
    } OTG_HS_HCSPLT15_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINT15;              /*!< (@ 0x000002C8) OTG_HS host channel-15 interrupt register                  */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed                                                 */
      __IOM uint32_t CHH        : 1;            /*!< [1..1] Channel halted                                                     */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt                                  */
      __IOM uint32_t NAK        : 1;            /*!< [4..4] NAK response received interrupt                                    */
      __IOM uint32_t ACK        : 1;            /*!< [5..5] ACK response received/transmitted interrupt                        */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERR      : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERR      : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMOR      : 1;            /*!< [9..9] Frame overrun                                                      */
      __IOM uint32_t DTERR      : 1;            /*!< [10..10] Data toggle error                                                */
            uint32_t            : 21;
    } OTG_HS_HCINT15_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCINTMSK15;           /*!< (@ 0x000002CC) OTG_HS host channel-15 interrupt mask register             */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed mask                                            */
      __IOM uint32_t CHHM       : 1;            /*!< [1..1] Channel halted mask                                                */
      __IOM uint32_t AHBERR     : 1;            /*!< [2..2] AHB error                                                          */
      __IOM uint32_t STALL      : 1;            /*!< [3..3] STALL response received interrupt mask                             */
      __IOM uint32_t NAKM       : 1;            /*!< [4..4] NAK response received interrupt mask                               */
      __IOM uint32_t ACKM       : 1;            /*!< [5..5] ACK response received/transmitted interrupt mask                   */
      __IOM uint32_t NYET       : 1;            /*!< [6..6] Response received interrupt                                        */
      __IOM uint32_t TXERRM     : 1;            /*!< [7..7] Transaction error                                                  */
      __IOM uint32_t BBERRM     : 1;            /*!< [8..8] Babble error                                                       */
      __IOM uint32_t FRMORM     : 1;            /*!< [9..9] Frame overrun mask                                                 */
      __IOM uint32_t DTERRM     : 1;            /*!< [10..10] Data toggle error mask                                           */
            uint32_t            : 21;
    } OTG_HS_HCINTMSK15_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCTSIZ15;             /*!< (@ 0x000002D0) OTG_HS host channel-15 transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t DPID       : 2;            /*!< [30..29] Data PID                                                         */
            uint32_t            : 1;
    } OTG_HS_HCTSIZ15_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_HCDMA15;              /*!< (@ 0x000002D4) OTG_HS host channel-15 DMA address register                */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_HCDMA15_b;
  } ;
} OTG1_HS_HOST_Type;                            /*!< Size = 728 (0x2d8)                                                        */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_DEVICE                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_DEVICE)
  */

typedef struct {                                /*!< (@ 0x40040800) OTG1_HS_DEVICE Structure                                   */
  
  union {
    __IOM uint32_t OTG_HS_DCFG;                 /*!< (@ 0x00000000) OTG_HS device configuration register                       */
    
    struct {
      __IOM uint32_t DSPD       : 2;            /*!< [1..0] Device speed                                                       */
      __IOM uint32_t NZLSOHSK   : 1;            /*!< [2..2] Nonzero-length status OUT handshake                                */
            uint32_t            : 1;
      __IOM uint32_t DAD        : 7;            /*!< [10..4] Device address                                                    */
      __IOM uint32_t PFIVL      : 2;            /*!< [12..11] Periodic (micro)frame interval                                   */
            uint32_t            : 11;
      __IOM uint32_t PERSCHIVL  : 2;            /*!< [25..24] Periodic scheduling interval                                     */
            uint32_t            : 6;
    } OTG_HS_DCFG_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DCTL;                 /*!< (@ 0x00000004) OTG_HS device control register                             */
    
    struct {
      __IOM uint32_t RWUSIG     : 1;            /*!< [0..0] Remote wakeup signaling                                            */
      __IOM uint32_t SDIS       : 1;            /*!< [1..1] Soft disconnect                                                    */
      __IM  uint32_t GINSTS     : 1;            /*!< [2..2] Global IN NAK status                                               */
      __IM  uint32_t GONSTS     : 1;            /*!< [3..3] Global OUT NAK status                                              */
      __IOM uint32_t TCTL       : 3;            /*!< [6..4] Test control                                                       */
      __OM  uint32_t SGINAK     : 1;            /*!< [7..7] Set global IN NAK                                                  */
      __OM  uint32_t CGINAK     : 1;            /*!< [8..8] Clear global IN NAK                                                */
      __OM  uint32_t SGONAK     : 1;            /*!< [9..9] Set global OUT NAK                                                 */
      __OM  uint32_t CGONAK     : 1;            /*!< [10..10] Clear global OUT NAK                                             */
      __IOM uint32_t POPRGDNE   : 1;            /*!< [11..11] Power-on programming done                                        */
            uint32_t            : 20;
    } OTG_HS_DCTL_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DSTS;                 /*!< (@ 0x00000008) OTG_HS device status register                              */
    
    struct {
      __IM  uint32_t SUSPSTS    : 1;            /*!< [0..0] Suspend status                                                     */
      __IM  uint32_t ENUMSPD    : 2;            /*!< [2..1] Enumerated speed                                                   */
      __IM  uint32_t EERR       : 1;            /*!< [3..3] Erratic error                                                      */
            uint32_t            : 4;
      __IM  uint32_t FNSOF      : 14;           /*!< [21..8] Frame number of the received SOF                                  */
            uint32_t            : 10;
    } OTG_HS_DSTS_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t OTG_HS_DIEPMSK;              /*!< (@ 0x00000010) OTG_HS device IN endpoint common interrupt mask
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed interrupt mask                                  */
      __IOM uint32_t EPDM       : 1;            /*!< [1..1] Endpoint disabled interrupt mask                                   */
            uint32_t            : 1;
      __IOM uint32_t TOM        : 1;            /*!< [3..3] Timeout condition mask (nonisochronous endpoints)                  */
      __IOM uint32_t ITTXFEMSK  : 1;            /*!< [4..4] IN token received when TxFIFO empty mask                           */
      __IOM uint32_t INEPNMM    : 1;            /*!< [5..5] IN token received with EP mismatch mask                            */
      __IOM uint32_t INEPNEM    : 1;            /*!< [6..6] IN endpoint NAK effective mask                                     */
            uint32_t            : 1;
      __IOM uint32_t TXFURM     : 1;            /*!< [8..8] FIFO underrun mask                                                 */
      __IOM uint32_t BIM        : 1;            /*!< [9..9] BNA interrupt mask                                                 */
            uint32_t            : 22;
    } OTG_HS_DIEPMSK_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DOEPMSK;              /*!< (@ 0x00000014) OTG_HS device OUT endpoint common interrupt mask
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t XFRCM      : 1;            /*!< [0..0] Transfer completed interrupt mask                                  */
      __IOM uint32_t EPDM       : 1;            /*!< [1..1] Endpoint disabled interrupt mask                                   */
            uint32_t            : 1;
      __IOM uint32_t STUPM      : 1;            /*!< [3..3] SETUP phase done mask                                              */
      __IOM uint32_t OTEPDM     : 1;            /*!< [4..4] OUT token received when endpoint disabled mask                     */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received mask                           */
            uint32_t            : 1;
      __IOM uint32_t OPEM       : 1;            /*!< [8..8] OUT packet error mask                                              */
      __IOM uint32_t BOIM       : 1;            /*!< [9..9] BNA interrupt mask                                                 */
            uint32_t            : 22;
    } OTG_HS_DOEPMSK_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DAINT;                /*!< (@ 0x00000018) OTG_HS device all endpoints interrupt register             */
    
    struct {
      __IM  uint32_t IEPINT     : 16;           /*!< [15..0] IN endpoint interrupt bits                                        */
      __IM  uint32_t OEPINT     : 16;           /*!< [31..16] OUT endpoint interrupt bits                                      */
    } OTG_HS_DAINT_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DAINTMSK;             /*!< (@ 0x0000001C) OTG_HS all endpoints interrupt mask register               */
    
    struct {
      __IOM uint32_t IEPM       : 16;           /*!< [15..0] IN EP interrupt mask bits                                         */
      __IOM uint32_t OEPM       : 16;           /*!< [31..16] OUT EP interrupt mask bits                                       */
    } OTG_HS_DAINTMSK_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t OTG_HS_DVBUSDIS;             /*!< (@ 0x00000028) OTG_HS device VBUS discharge time register                 */
    
    struct {
      __IOM uint32_t VBUSDT     : 16;           /*!< [15..0] Device VBUS discharge time                                        */
            uint32_t            : 16;
    } OTG_HS_DVBUSDIS_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DVBUSPULSE;           /*!< (@ 0x0000002C) OTG_HS device VBUS pulsing time register                   */
    
    struct {
      __IOM uint32_t DVBUSP     : 12;           /*!< [11..0] Device VBUS pulsing time                                          */
            uint32_t            : 20;
    } OTG_HS_DVBUSPULSE_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DTHRCTL;              /*!< (@ 0x00000030) OTG_HS Device threshold control register                   */
    
    struct {
      __IOM uint32_t NONISOTHREN : 1;           /*!< [0..0] Nonisochronous IN endpoints threshold enable                       */
      __IOM uint32_t ISOTHREN   : 1;            /*!< [1..1] ISO IN endpoint threshold enable                                   */
      __IOM uint32_t TXTHRLEN   : 9;            /*!< [10..2] Transmit threshold length                                         */
            uint32_t            : 5;
      __IOM uint32_t RXTHREN    : 1;            /*!< [16..16] Receive threshold enable                                         */
      __IOM uint32_t RXTHRLEN   : 9;            /*!< [25..17] Receive threshold length                                         */
            uint32_t            : 1;
      __IOM uint32_t ARPEN      : 1;            /*!< [27..27] Arbiter parking enable                                           */
            uint32_t            : 4;
    } OTG_HS_DTHRCTL_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPEMPMSK;           /*!< (@ 0x00000034) OTG_HS device IN endpoint FIFO empty interrupt
                                                                    mask register                                              */
    
    struct {
      __IOM uint32_t INEPTXFEM  : 16;           /*!< [15..0] IN EP Tx FIFO empty interrupt mask bits                           */
            uint32_t            : 16;
    } OTG_HS_DIEPEMPMSK_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DEACHINT;             /*!< (@ 0x00000038) OTG_HS device each endpoint interrupt register             */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t IEP1INT    : 1;            /*!< [1..1] IN endpoint 1interrupt bit                                         */
            uint32_t            : 15;
      __IOM uint32_t OEP1INT    : 1;            /*!< [17..17] OUT endpoint 1 interrupt bit                                     */
            uint32_t            : 14;
    } OTG_HS_DEACHINT_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DEACHINTMSK;          /*!< (@ 0x0000003C) OTG_HS device each endpoint interrupt register
                                                                    mask                                                       */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t IEP1INTM   : 1;            /*!< [1..1] IN Endpoint 1 interrupt mask bit                                   */
            uint32_t            : 15;
      __IOM uint32_t OEP1INTM   : 1;            /*!< [17..17] OUT Endpoint 1 interrupt mask bit                                */
            uint32_t            : 14;
    } OTG_HS_DEACHINTMSK_b;
  } ;
  __IM  uint32_t  RESERVED2[48];
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL0;             /*!< (@ 0x00000100) OTG device endpoint-0 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL0_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT0;             /*!< (@ 0x00000108) OTG device endpoint-0 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT0_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ0;            /*!< (@ 0x00000110) OTG_HS device IN endpoint 0 transfer size register         */
    
    struct {
      __IOM uint32_t XFRSIZ     : 7;            /*!< [6..0] Transfer size                                                      */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT     : 2;            /*!< [20..19] Packet count                                                     */
            uint32_t            : 11;
    } OTG_HS_DIEPTSIZ0_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPDMA1;             /*!< (@ 0x00000114) OTG_HS device endpoint-1 DMA address register              */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_DIEPDMA1_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS0;             /*!< (@ 0x00000118) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS0_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL1;             /*!< (@ 0x00000120) OTG device endpoint-1 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL1_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT1;             /*!< (@ 0x00000128) OTG device endpoint-1 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT1_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ1;            /*!< (@ 0x00000130) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32_t            : 1;
    } OTG_HS_DIEPTSIZ1_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPDMA2;             /*!< (@ 0x00000134) OTG_HS device endpoint-2 DMA address register              */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_DIEPDMA2_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS1;             /*!< (@ 0x00000138) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS1_b;
  } ;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL2;             /*!< (@ 0x00000140) OTG device endpoint-2 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL2_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT2;             /*!< (@ 0x00000148) OTG device endpoint-2 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT2_b;
  } ;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ2;            /*!< (@ 0x00000150) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32_t            : 1;
    } OTG_HS_DIEPTSIZ2_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPDMA3;             /*!< (@ 0x00000154) OTG_HS device endpoint-3 DMA address register              */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_DIEPDMA3_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS2;             /*!< (@ 0x00000158) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS2_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL3;             /*!< (@ 0x00000160) OTG device endpoint-3 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL3_b;
  } ;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT3;             /*!< (@ 0x00000168) OTG device endpoint-3 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT3_b;
  } ;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ3;            /*!< (@ 0x00000170) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32_t            : 1;
    } OTG_HS_DIEPTSIZ3_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPDMA4;             /*!< (@ 0x00000174) OTG_HS device endpoint-4 DMA address register              */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_DIEPDMA4_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS3;             /*!< (@ 0x00000178) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS3_b;
  } ;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL4;             /*!< (@ 0x00000180) OTG device endpoint-4 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL4_b;
  } ;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT4;             /*!< (@ 0x00000188) OTG device endpoint-4 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT4_b;
  } ;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ4;            /*!< (@ 0x00000190) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32_t            : 1;
    } OTG_HS_DIEPTSIZ4_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPDMA5;             /*!< (@ 0x00000194) OTG_HS device endpoint-5 DMA address register              */
    
    struct {
      __IOM uint32_t DMAADDR    : 32;           /*!< [31..0] DMA address                                                       */
    } OTG_HS_DIEPDMA5_b;
  } ;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS4;             /*!< (@ 0x00000198) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS4_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    union {
      __IOM uint32_t OTG_HS_DIEPCTL5;           /*!< (@ 0x000001A0) OTG device endpoint-5 control register                     */
      
      struct {
        __IOM uint32_t MPSIZ    : 11;           /*!< [10..0] Maximum packet size                                               */
              uint32_t          : 4;
        __IOM uint32_t USBAEP   : 1;            /*!< [15..15] USB active endpoint                                              */
        __IM  uint32_t EONUM_DPID : 1;          /*!< [16..16] Even/odd frame                                                   */
        __IM  uint32_t NAKSTS   : 1;            /*!< [17..17] NAK status                                                       */
        __IOM uint32_t EPTYP    : 2;            /*!< [19..18] Endpoint type                                                    */
              uint32_t          : 1;
        __IOM uint32_t Stall    : 1;            /*!< [21..21] STALL handshake                                                  */
        __IOM uint32_t TXFNUM   : 4;            /*!< [25..22] TxFIFO number                                                    */
        __OM  uint32_t CNAK     : 1;            /*!< [26..26] Clear NAK                                                        */
        __OM  uint32_t SNAK     : 1;            /*!< [27..27] Set NAK                                                          */
        __OM  uint32_t SD0PID_SEVNFRM : 1;      /*!< [28..28] Set DATA0 PID                                                    */
        __OM  uint32_t SODDFRM  : 1;            /*!< [29..29] Set odd frame                                                    */
        __IOM uint32_t EPDIS    : 1;            /*!< [30..30] Endpoint disable                                                 */
        __IOM uint32_t EPENA    : 1;            /*!< [31..31] Endpoint enable                                                  */
      } OTG_HS_DIEPCTL5_b;
    } ;
    
    union {
      __IOM uint32_t OTG_HS_DIEPTSIZ6;          /*!< (@ 0x000001A0) OTG_HS device endpoint transfer size register              */
      
      struct {
        __IOM uint32_t XFRSIZ   : 19;           /*!< [18..0] Transfer size                                                     */
        __IOM uint32_t PKTCNT   : 10;           /*!< [28..19] Packet count                                                     */
        __IOM uint32_t MCNT     : 2;            /*!< [30..29] Multi count                                                      */
              uint32_t          : 1;
      } OTG_HS_DIEPTSIZ6_b;
    } ;
  };
  
  union {
    __IOM uint32_t OTG_HS_DTXFSTS6;             /*!< (@ 0x000001A4) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS6_b;
  } ;
  
  union {
    union {
      __IOM uint32_t OTG_HS_DIEPINT5;           /*!< (@ 0x000001A8) OTG device endpoint-5 interrupt register                   */
      
      struct {
        __IOM uint32_t XFRC     : 1;            /*!< [0..0] Transfer completed interrupt                                       */
        __IOM uint32_t EPDISD   : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
              uint32_t          : 1;
        __IOM uint32_t TOC      : 1;            /*!< [3..3] Timeout condition                                                  */
        __IOM uint32_t ITTXFE   : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
              uint32_t          : 1;
        __IOM uint32_t INEPNE   : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
        __IM  uint32_t TXFE     : 1;            /*!< [7..7] Transmit FIFO empty                                                */
        __IOM uint32_t TXFIFOUDRN : 1;          /*!< [8..8] Transmit Fifo Underrun                                             */
        __IOM uint32_t BNA      : 1;            /*!< [9..9] Buffer not available interrupt                                     */
              uint32_t          : 1;
        __IOM uint32_t PKTDRPSTS : 1;           /*!< [11..11] Packet dropped status                                            */
        __IOM uint32_t BERR     : 1;            /*!< [12..12] Babble error interrupt                                           */
        __IOM uint32_t NAK      : 1;            /*!< [13..13] NAK interrupt                                                    */
              uint32_t          : 18;
      } OTG_HS_DIEPINT5_b;
    } ;
    
    union {
      __IOM uint32_t OTG_HS_DIEPTSIZ7;          /*!< (@ 0x000001A8) OTG_HS device endpoint transfer size register              */
      
      struct {
        __IOM uint32_t XFRSIZ   : 19;           /*!< [18..0] Transfer size                                                     */
        __IOM uint32_t PKTCNT   : 10;           /*!< [28..19] Packet count                                                     */
        __IOM uint32_t MCNT     : 2;            /*!< [30..29] Multi count                                                      */
              uint32_t          : 1;
      } OTG_HS_DIEPTSIZ7_b;
    } ;
  };
  
  union {
    __IOM uint32_t OTG_HS_DTXFSTS7;             /*!< (@ 0x000001AC) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS7_b;
  } ;
  
  union {
    __IOM uint32_t OTG_HS_DIEPTSIZ5;            /*!< (@ 0x000001B0) OTG_HS device endpoint transfer size register              */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t MCNT       : 2;            /*!< [30..29] Multi count                                                      */
            uint32_t            : 1;
    } OTG_HS_DIEPTSIZ5_b;
  } ;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IM  uint32_t OTG_HS_DTXFSTS5;             /*!< (@ 0x000001B8) OTG_HS device IN endpoint transmit FIFO status
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t INEPTFSAV  : 16;           /*!< [15..0] IN endpoint TxFIFO space avail                                    */
            uint32_t            : 16;
    } OTG_HS_DTXFSTS5_b;
  } ;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL6;             /*!< (@ 0x000001C0) OTG device endpoint-6 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL6_b;
  } ;
  __IM  uint32_t  RESERVED20;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT6;             /*!< (@ 0x000001C8) OTG device endpoint-6 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT6_b;
  } ;
  __IM  uint32_t  RESERVED21[5];
  
  union {
    __IOM uint32_t OTG_HS_DIEPCTL7;             /*!< (@ 0x000001E0) OTG device endpoint-7 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even/odd frame                                                   */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
            uint32_t            : 1;
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
      __IOM uint32_t TXFNUM     : 4;            /*!< [25..22] TxFIFO number                                                    */
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID                                                    */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DIEPCTL7_b;
  } ;
  __IM  uint32_t  RESERVED22;
  
  union {
    __IOM uint32_t OTG_HS_DIEPINT7;             /*!< (@ 0x000001E8) OTG device endpoint-7 interrupt register                   */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t TOC        : 1;            /*!< [3..3] Timeout condition                                                  */
      __IOM uint32_t ITTXFE     : 1;            /*!< [4..4] IN token received when TxFIFO is empty                             */
            uint32_t            : 1;
      __IOM uint32_t INEPNE     : 1;            /*!< [6..6] IN endpoint NAK effective                                          */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty                                                */
      __IOM uint32_t TXFIFOUDRN : 1;            /*!< [8..8] Transmit Fifo Underrun                                             */
      __IOM uint32_t BNA        : 1;            /*!< [9..9] Buffer not available interrupt                                     */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS  : 1;            /*!< [11..11] Packet dropped status                                            */
      __IOM uint32_t BERR       : 1;            /*!< [12..12] Babble error interrupt                                           */
      __IOM uint32_t NAK        : 1;            /*!< [13..13] NAK interrupt                                                    */
            uint32_t            : 18;
    } OTG_HS_DIEPINT7_b;
  } ;
  __IM  uint32_t  RESERVED23[69];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL0;             /*!< (@ 0x00000300) OTG_HS device control OUT endpoint 0 control
                                                                    register                                                   */
    
    struct {
      __IM  uint32_t MPSIZ      : 2;            /*!< [1..0] Maximum packet size                                                */
            uint32_t            : 13;
      __IM  uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IM  uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
            uint32_t            : 2;
      __IM  uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __OM  uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL0_b;
  } ;
  __IM  uint32_t  RESERVED24;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT0;             /*!< (@ 0x00000308) OTG_HS device endpoint-0 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT0_b;
  } ;
  __IM  uint32_t  RESERVED25;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ0;            /*!< (@ 0x00000310) OTG_HS device endpoint-0 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 7;            /*!< [6..0] Transfer size                                                      */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT     : 1;            /*!< [19..19] Packet count                                                     */
            uint32_t            : 9;
      __IOM uint32_t STUPCNT    : 2;            /*!< [30..29] SETUP packet count                                               */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ0_b;
  } ;
  __IM  uint32_t  RESERVED26[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL1;             /*!< (@ 0x00000320) OTG device endpoint-1 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL1_b;
  } ;
  __IM  uint32_t  RESERVED27;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT1;             /*!< (@ 0x00000328) OTG_HS device endpoint-1 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT1_b;
  } ;
  __IM  uint32_t  RESERVED28;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ1;            /*!< (@ 0x00000330) OTG_HS device endpoint-1 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ1_b;
  } ;
  __IM  uint32_t  RESERVED29[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL2;             /*!< (@ 0x00000340) OTG device endpoint-2 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL2_b;
  } ;
  __IM  uint32_t  RESERVED30;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT2;             /*!< (@ 0x00000348) OTG_HS device endpoint-2 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT2_b;
  } ;
  __IM  uint32_t  RESERVED31;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ2;            /*!< (@ 0x00000350) OTG_HS device endpoint-2 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ2_b;
  } ;
  __IM  uint32_t  RESERVED32[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL3;             /*!< (@ 0x00000360) OTG device endpoint-3 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL3_b;
  } ;
  __IM  uint32_t  RESERVED33;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT3;             /*!< (@ 0x00000368) OTG_HS device endpoint-3 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT3_b;
  } ;
  __IM  uint32_t  RESERVED34;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ3;            /*!< (@ 0x00000370) OTG_HS device endpoint-3 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ3_b;
  } ;
  __IM  uint32_t  RESERVED35[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL4;             /*!< (@ 0x00000380) OTG device endpoint-4 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL4_b;
  } ;
  __IM  uint32_t  RESERVED36;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT4;             /*!< (@ 0x00000388) OTG_HS device endpoint-4 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT4_b;
  } ;
  __IM  uint32_t  RESERVED37;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ4;            /*!< (@ 0x00000390) OTG_HS device endpoint-4 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ4_b;
  } ;
  __IM  uint32_t  RESERVED38[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL5;             /*!< (@ 0x000003A0) OTG device endpoint-5 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL5_b;
  } ;
  __IM  uint32_t  RESERVED39;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT5;             /*!< (@ 0x000003A8) OTG_HS device endpoint-5 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT5_b;
  } ;
  __IM  uint32_t  RESERVED40;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ5;            /*!< (@ 0x000003B0) OTG_HS device endpoint-5 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ5_b;
  } ;
  __IM  uint32_t  RESERVED41[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL6;             /*!< (@ 0x000003C0) OTG device endpoint-6 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL6_b;
  } ;
  __IM  uint32_t  RESERVED42;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT6;             /*!< (@ 0x000003C8) OTG_HS device endpoint-6 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT6_b;
  } ;
  __IM  uint32_t  RESERVED43;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ6;            /*!< (@ 0x000003D0) OTG_HS device endpoint-6 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ6_b;
  } ;
  __IM  uint32_t  RESERVED44[3];
  
  union {
    __IOM uint32_t OTG_HS_DOEPCTL7;             /*!< (@ 0x000003E0) OTG device endpoint-7 control register                     */
    
    struct {
      __IOM uint32_t MPSIZ      : 11;           /*!< [10..0] Maximum packet size                                               */
            uint32_t            : 4;
      __IOM uint32_t USBAEP     : 1;            /*!< [15..15] USB active endpoint                                              */
      __IM  uint32_t EONUM_DPID : 1;            /*!< [16..16] Even odd frame/Endpoint data PID                                 */
      __IM  uint32_t NAKSTS     : 1;            /*!< [17..17] NAK status                                                       */
      __IOM uint32_t EPTYP      : 2;            /*!< [19..18] Endpoint type                                                    */
      __IOM uint32_t SNPM       : 1;            /*!< [20..20] Snoop mode                                                       */
      __IOM uint32_t Stall      : 1;            /*!< [21..21] STALL handshake                                                  */
            uint32_t            : 4;
      __OM  uint32_t CNAK       : 1;            /*!< [26..26] Clear NAK                                                        */
      __OM  uint32_t SNAK       : 1;            /*!< [27..27] Set NAK                                                          */
      __OM  uint32_t SD0PID_SEVNFRM : 1;        /*!< [28..28] Set DATA0 PID/Set even frame                                     */
      __OM  uint32_t SODDFRM    : 1;            /*!< [29..29] Set odd frame                                                    */
      __IOM uint32_t EPDIS      : 1;            /*!< [30..30] Endpoint disable                                                 */
      __IOM uint32_t EPENA      : 1;            /*!< [31..31] Endpoint enable                                                  */
    } OTG_HS_DOEPCTL7_b;
  } ;
  __IM  uint32_t  RESERVED45;
  
  union {
    __IOM uint32_t OTG_HS_DOEPINT7;             /*!< (@ 0x000003E8) OTG_HS device endpoint-7 interrupt register                */
    
    struct {
      __IOM uint32_t XFRC       : 1;            /*!< [0..0] Transfer completed interrupt                                       */
      __IOM uint32_t EPDISD     : 1;            /*!< [1..1] Endpoint disabled interrupt                                        */
            uint32_t            : 1;
      __IOM uint32_t STUP       : 1;            /*!< [3..3] SETUP phase done                                                   */
      __IOM uint32_t OTEPDIS    : 1;            /*!< [4..4] OUT token received when endpoint disabled                          */
            uint32_t            : 1;
      __IOM uint32_t B2BSTUP    : 1;            /*!< [6..6] Back-to-back SETUP packets received                                */
            uint32_t            : 7;
      __IOM uint32_t NYET       : 1;            /*!< [14..14] NYET interrupt                                                   */
            uint32_t            : 17;
    } OTG_HS_DOEPINT7_b;
  } ;
  __IM  uint32_t  RESERVED46;
  
  union {
    __IOM uint32_t OTG_HS_DOEPTSIZ7;            /*!< (@ 0x000003F0) OTG_HS device endpoint-7 transfer size register            */
    
    struct {
      __IOM uint32_t XFRSIZ     : 19;           /*!< [18..0] Transfer size                                                     */
      __IOM uint32_t PKTCNT     : 10;           /*!< [28..19] Packet count                                                     */
      __IOM uint32_t RXDPID_STUPCNT : 2;        /*!< [30..29] Received data PID/SETUP packet count                             */
            uint32_t            : 1;
    } OTG_HS_DOEPTSIZ7_b;
  } ;
} OTG1_HS_DEVICE_Type;                          /*!< Size = 1012 (0x3f4)                                                       */



/* =========================================================================================================================== */
/* ================                                      OTG1_HS_PWRCLK                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief USB 1 on the go high speed (OTG1_HS_PWRCLK)
  */

typedef struct {                                /*!< (@ 0x40040E00) OTG1_HS_PWRCLK Structure                                   */
  
  union {
    __IOM uint32_t OTG_HS_PCGCR;                /*!< (@ 0x00000000) Power and clock gating control register                    */
    
    struct {
      __IOM uint32_t STPPCLK    : 1;            /*!< [0..0] Stop PHY clock                                                     */
      __IOM uint32_t GATEHCLK   : 1;            /*!< [1..1] Gate HCLK                                                          */
            uint32_t            : 2;
      __IOM uint32_t PHYSUSP    : 1;            /*!< [4..4] PHY suspended                                                      */
            uint32_t            : 27;
    } OTG_HS_PCGCR_b;
  } ;
} OTG1_HS_PWRCLK_Type;                          /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                       Ethernet_MAC                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Ethernet: media access control
      (MAC) (Ethernet_MAC)
  */

typedef struct {                                /*!< (@ 0x40028000) Ethernet_MAC Structure                                     */
  
  union {
    __IOM uint32_t DMAMR;                       /*!< (@ 0x00000000) DMA mode register                                          */
    
    struct {
      __IOM uint32_t SWR        : 1;            /*!< [0..0] Software Reset                                                     */
      __IOM uint32_t DA         : 1;            /*!< [1..1] DMA Tx or Rx Arbitration Scheme                                    */
            uint32_t            : 9;
      __IOM uint32_t TXPR       : 1;            /*!< [11..11] Transmit priority                                                */
      __IOM uint32_t PR         : 3;            /*!< [14..12] Priority ratio                                                   */
            uint32_t            : 1;
      __IOM uint32_t INTM       : 1;            /*!< [16..16] Interrupt Mode                                                   */
            uint32_t            : 15;
    } DMAMR_b;
  } ;
  
  union {
    __IOM uint32_t DMASBMR;                     /*!< (@ 0x00000004) System bus mode register                                   */
    
    struct {
      __IOM uint32_t FB         : 1;            /*!< [0..0] Fixed Burst Length                                                 */
            uint32_t            : 11;
      __IOM uint32_t AAL        : 1;            /*!< [12..12] Address-Aligned Beats                                            */
            uint32_t            : 1;
      __IOM uint32_t MB         : 1;            /*!< [14..14] Mixed Burst                                                      */
      __IOM uint32_t RB         : 1;            /*!< [15..15] Rebuild INCRx Burst                                              */
            uint32_t            : 16;
    } DMASBMR_b;
  } ;
  
  union {
    __IOM uint32_t DMAISR;                      /*!< (@ 0x00000008) Interrupt status register                                  */
    
    struct {
      __IOM uint32_t DC0IS      : 1;            /*!< [0..0] DMA Channel Interrupt Status                                       */
            uint32_t            : 15;
      __IOM uint32_t MTLIS      : 1;            /*!< [16..16] MTL Interrupt Status                                             */
      __IOM uint32_t MACIS      : 1;            /*!< [17..17] MAC Interrupt Status                                             */
            uint32_t            : 14;
    } DMAISR_b;
  } ;
  
  union {
    __IOM uint32_t DMADSR;                      /*!< (@ 0x0000000C) Debug status register                                      */
    
    struct {
      __IOM uint32_t AXWHSTS    : 1;            /*!< [0..0] AHB Master Write Channel                                           */
            uint32_t            : 7;
      __IOM uint32_t RPS0       : 4;            /*!< [11..8] DMA Channel Receive Process State                                 */
      __IOM uint32_t TPS0       : 4;            /*!< [15..12] DMA Channel Transmit Process State                               */
            uint32_t            : 16;
    } DMADSR_b;
  } ;
  __IM  uint32_t  RESERVED[60];
  
  union {
    __IOM uint32_t DMACCR;                      /*!< (@ 0x00000100) Channel control register                                   */
    
    struct {
      __IOM uint32_t MSS        : 14;           /*!< [13..0] Maximum Segment Size                                              */
            uint32_t            : 2;
      __IOM uint32_t PBLX8      : 1;            /*!< [16..16] 8xPBL mode                                                       */
            uint32_t            : 1;
      __IOM uint32_t DSL        : 3;            /*!< [20..18] Descriptor Skip Length                                           */
            uint32_t            : 11;
    } DMACCR_b;
  } ;
  
  union {
    __IOM uint32_t DMACTxCR;                    /*!< (@ 0x00000104) Channel transmit control register                          */
    
    struct {
      __IOM uint32_t ST         : 1;            /*!< [0..0] Start or Stop Transmission Command                                 */
            uint32_t            : 3;
      __IOM uint32_t OSF        : 1;            /*!< [4..4] Operate on Second Packet                                           */
            uint32_t            : 7;
      __IOM uint32_t TSE        : 1;            /*!< [12..12] TCP Segmentation Enabled                                         */
            uint32_t            : 3;
      __IOM uint32_t TXPBL      : 6;            /*!< [21..16] Transmit Programmable Burst Length                               */
            uint32_t            : 10;
    } DMACTxCR_b;
  } ;
  
  union {
    __IOM uint32_t DMACRxCR;                    /*!< (@ 0x00000108) Channel receive control register                           */
    
    struct {
      __IOM uint32_t SR         : 1;            /*!< [0..0] Start or Stop Receive Command                                      */
      __IOM uint32_t RBSZ       : 14;           /*!< [14..1] Receive Buffer size                                               */
            uint32_t            : 1;
      __IOM uint32_t RXPBL      : 6;            /*!< [21..16] RXPBL                                                            */
            uint32_t            : 9;
      __IOM uint32_t RPF        : 1;            /*!< [31..31] DMA Rx Channel Packet Flush                                      */
    } DMACRxCR_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t DMACTxDLAR;                  /*!< (@ 0x00000114) Channel Tx descriptor list address register                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TDESLA     : 30;           /*!< [31..2] Start of Transmit List                                            */
    } DMACTxDLAR_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t DMACRxDLAR;                  /*!< (@ 0x0000011C) Channel Rx descriptor list address register                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t RDESLA     : 30;           /*!< [31..2] Start of Receive List                                             */
    } DMACRxDLAR_b;
  } ;
  
  union {
    __IOM uint32_t DMACTxDTPR;                  /*!< (@ 0x00000120) Channel Tx descriptor tail pointer register                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TDT        : 30;           /*!< [31..2] Transmit Descriptor Tail Pointer                                  */
    } DMACTxDTPR_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t DMACRxDTPR;                  /*!< (@ 0x00000128) Channel Rx descriptor tail pointer register                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t RDT        : 30;           /*!< [31..2] Receive Descriptor Tail Pointer                                   */
    } DMACRxDTPR_b;
  } ;
  
  union {
    __IOM uint32_t DMACTxRLR;                   /*!< (@ 0x0000012C) Channel Tx descriptor ring length register                 */
    
    struct {
      __IOM uint32_t TDRL       : 10;           /*!< [9..0] Transmit Descriptor Ring Length                                    */
            uint32_t            : 22;
    } DMACTxRLR_b;
  } ;
  
  union {
    __IOM uint32_t DMACRxRLR;                   /*!< (@ 0x00000130) Channel Rx descriptor ring length register                 */
    
    struct {
      __IOM uint32_t RDRL       : 10;           /*!< [9..0] Receive Descriptor Ring Length                                     */
            uint32_t            : 22;
    } DMACRxRLR_b;
  } ;
  
  union {
    __IOM uint32_t DMACIER;                     /*!< (@ 0x00000134) Channel interrupt enable register                          */
    
    struct {
      __IOM uint32_t TIE        : 1;            /*!< [0..0] Transmit Interrupt Enable                                          */
      __IOM uint32_t TXSE       : 1;            /*!< [1..1] Transmit Stopped Enable                                            */
      __IOM uint32_t TBUE       : 1;            /*!< [2..2] Transmit Buffer Unavailable Enable                                 */
            uint32_t            : 3;
      __IOM uint32_t RIE        : 1;            /*!< [6..6] Receive Interrupt Enable                                           */
      __IOM uint32_t RBUE       : 1;            /*!< [7..7] Receive Buffer Unavailable Enable                                  */
      __IOM uint32_t RSE        : 1;            /*!< [8..8] Receive Stopped Enable                                             */
      __IOM uint32_t RWTE       : 1;            /*!< [9..9] Receive Watchdog Timeout Enable                                    */
      __IOM uint32_t ETIE       : 1;            /*!< [10..10] Early Transmit Interrupt Enable                                  */
      __IOM uint32_t ERIE       : 1;            /*!< [11..11] Early Receive Interrupt Enable                                   */
      __IOM uint32_t FBEE       : 1;            /*!< [12..12] Fatal Bus Error Enable                                           */
      __IOM uint32_t CDEE       : 1;            /*!< [13..13] Context Descriptor Error Enable                                  */
      __IOM uint32_t AIE        : 1;            /*!< [14..14] Abnormal Interrupt Summary Enable                                */
      __IOM uint32_t NIE        : 1;            /*!< [15..15] Normal Interrupt Summary Enable                                  */
            uint32_t            : 16;
    } DMACIER_b;
  } ;
  
  union {
    __IOM uint32_t DMACRxIWTR;                  /*!< (@ 0x00000138) Channel Rx interrupt watchdog timer register               */
    
    struct {
      __IOM uint32_t RWT        : 8;            /*!< [7..0] Receive Interrupt Watchdog Timer Count                             */
            uint32_t            : 24;
    } DMACRxIWTR_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t DMACCATxDR;                  /*!< (@ 0x00000144) Channel current application transmit descriptor
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t CURTDESAPTR : 32;          /*!< [31..0] Application Transmit Descriptor Address Pointer                   */
    } DMACCATxDR_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t DMACCARxDR;                  /*!< (@ 0x0000014C) Channel current application receive descriptor
                                                                    register                                                   */
    
    struct {
      __IOM uint32_t CURRDESAPTR : 32;          /*!< [31..0] Application Receive Descriptor Address Pointer                    */
    } DMACCARxDR_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t DMACCATxBR;                  /*!< (@ 0x00000154) Channel current application transmit buffer register       */
    
    struct {
      __IOM uint32_t CURTBUFAPTR : 32;          /*!< [31..0] Application Transmit Buffer Address Pointer                       */
    } DMACCATxBR_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t DMACCARxBR;                  /*!< (@ 0x0000015C) Channel current application receive buffer register        */
    
    struct {
      __IOM uint32_t CURRBUFAPTR : 32;          /*!< [31..0] Application Receive Buffer Address Pointer                        */
    } DMACCARxBR_b;
  } ;
  
  union {
    __IOM uint32_t DMACSR;                      /*!< (@ 0x00000160) Channel status register                                    */
    
    struct {
      __IOM uint32_t TI         : 1;            /*!< [0..0] Transmit Interrupt                                                 */
      __IOM uint32_t TPS        : 1;            /*!< [1..1] Transmit Process Stopped                                           */
      __IOM uint32_t TBU        : 1;            /*!< [2..2] Transmit Buffer Unavailable                                        */
            uint32_t            : 3;
      __IOM uint32_t RI         : 1;            /*!< [6..6] Receive Interrupt                                                  */
      __IOM uint32_t RBU        : 1;            /*!< [7..7] Receive Buffer Unavailable                                         */
      __IOM uint32_t RPS        : 1;            /*!< [8..8] Receive Process Stopped                                            */
      __IOM uint32_t RWT        : 1;            /*!< [9..9] Receive Watchdog Timeout                                           */
      __IOM uint32_t ET         : 1;            /*!< [10..10] Early Transmit Interrupt                                         */
      __IOM uint32_t ER         : 1;            /*!< [11..11] Early Receive Interrupt                                          */
      __IOM uint32_t FBE        : 1;            /*!< [12..12] Fatal Bus Error                                                  */
      __IOM uint32_t CDE        : 1;            /*!< [13..13] Context Descriptor Error                                         */
      __IOM uint32_t AIS        : 1;            /*!< [14..14] Abnormal Interrupt Summary                                       */
      __IOM uint32_t NIS        : 1;            /*!< [15..15] Normal Interrupt Summary                                         */
      __IOM uint32_t TEB        : 3;            /*!< [18..16] Tx DMA Error Bits                                                */
      __IOM uint32_t REB        : 3;            /*!< [21..19] Rx DMA Error Bits                                                */
            uint32_t            : 10;
    } DMACSR_b;
  } ;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IM  uint32_t DMACMFCR;                    /*!< (@ 0x0000016C) Channel missed frame count register                        */
    
    struct {
      __IM  uint32_t MFC        : 11;           /*!< [10..0] Dropped Packet Counters                                           */
            uint32_t            : 4;
      __IM  uint32_t MFCO       : 1;            /*!< [15..15] Overflow status of the MFC Counter                               */
            uint32_t            : 16;
    } DMACMFCR_b;
  } ;
} Ethernet_MAC_Type;                            /*!< Size = 368 (0x170)                                                        */



/* =========================================================================================================================== */
/* ================                                           DMA1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA controller (DMA1)
  */

typedef struct {                                /*!< (@ 0x40020000) DMA1 Structure                                             */
  
  union {
    __IM  uint32_t LISR;                        /*!< (@ 0x00000000) low interrupt status register                              */
    
    struct {
      __IM  uint32_t FEIF0      : 1;            /*!< [0..0] Stream x FIFO error interrupt flag (x=3..0)                        */
            uint32_t            : 1;
      __IM  uint32_t DMEIF0     : 1;            /*!< [2..2] Stream x direct mode error interrupt flag (x=3..0)                 */
      __IM  uint32_t TEIF0      : 1;            /*!< [3..3] Stream x transfer error interrupt flag (x=3..0)                    */
      __IM  uint32_t HTIF0      : 1;            /*!< [4..4] Stream x half transfer interrupt flag (x=3..0)                     */
      __IM  uint32_t TCIF0      : 1;            /*!< [5..5] Stream x transfer complete interrupt flag (x = 3..0)               */
      __IM  uint32_t FEIF1      : 1;            /*!< [6..6] Stream x FIFO error interrupt flag (x=3..0)                        */
            uint32_t            : 1;
      __IM  uint32_t DMEIF1     : 1;            /*!< [8..8] Stream x direct mode error interrupt flag (x=3..0)                 */
      __IM  uint32_t TEIF1      : 1;            /*!< [9..9] Stream x transfer error interrupt flag (x=3..0)                    */
      __IM  uint32_t HTIF1      : 1;            /*!< [10..10] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32_t TCIF1      : 1;            /*!< [11..11] Stream x transfer complete interrupt flag (x = 3..0)             */
            uint32_t            : 4;
      __IM  uint32_t FEIF2      : 1;            /*!< [16..16] Stream x FIFO error interrupt flag (x=3..0)                      */
            uint32_t            : 1;
      __IM  uint32_t DMEIF2     : 1;            /*!< [18..18] Stream x direct mode error interrupt flag (x=3..0)               */
      __IM  uint32_t TEIF2      : 1;            /*!< [19..19] Stream x transfer error interrupt flag (x=3..0)                  */
      __IM  uint32_t HTIF2      : 1;            /*!< [20..20] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32_t TCIF2      : 1;            /*!< [21..21] Stream x transfer complete interrupt flag (x = 3..0)             */
      __IM  uint32_t FEIF3      : 1;            /*!< [22..22] Stream x FIFO error interrupt flag (x=3..0)                      */
            uint32_t            : 1;
      __IM  uint32_t DMEIF3     : 1;            /*!< [24..24] Stream x direct mode error interrupt flag (x=3..0)               */
      __IM  uint32_t TEIF3      : 1;            /*!< [25..25] Stream x transfer error interrupt flag (x=3..0)                  */
      __IM  uint32_t HTIF3      : 1;            /*!< [26..26] Stream x half transfer interrupt flag (x=3..0)                   */
      __IM  uint32_t TCIF3      : 1;            /*!< [27..27] Stream x transfer complete interrupt flag (x = 3..0)             */
            uint32_t            : 4;
    } LISR_b;
  } ;
  
  union {
    __IM  uint32_t HISR;                        /*!< (@ 0x00000004) high interrupt status register                             */
    
    struct {
      __IM  uint32_t FEIF4      : 1;            /*!< [0..0] Stream x FIFO error interrupt flag (x=7..4)                        */
            uint32_t            : 1;
      __IM  uint32_t DMEIF4     : 1;            /*!< [2..2] Stream x direct mode error interrupt flag (x=7..4)                 */
      __IM  uint32_t TEIF4      : 1;            /*!< [3..3] Stream x transfer error interrupt flag (x=7..4)                    */
      __IM  uint32_t HTIF4      : 1;            /*!< [4..4] Stream x half transfer interrupt flag (x=7..4)                     */
      __IM  uint32_t TCIF4      : 1;            /*!< [5..5] Stream x transfer complete interrupt flag (x=7..4)                 */
      __IM  uint32_t FEIF5      : 1;            /*!< [6..6] Stream x FIFO error interrupt flag (x=7..4)                        */
            uint32_t            : 1;
      __IM  uint32_t DMEIF5     : 1;            /*!< [8..8] Stream x direct mode error interrupt flag (x=7..4)                 */
      __IM  uint32_t TEIF5      : 1;            /*!< [9..9] Stream x transfer error interrupt flag (x=7..4)                    */
      __IM  uint32_t HTIF5      : 1;            /*!< [10..10] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32_t TCIF5      : 1;            /*!< [11..11] Stream x transfer complete interrupt flag (x=7..4)               */
            uint32_t            : 4;
      __IM  uint32_t FEIF6      : 1;            /*!< [16..16] Stream x FIFO error interrupt flag (x=7..4)                      */
            uint32_t            : 1;
      __IM  uint32_t DMEIF6     : 1;            /*!< [18..18] Stream x direct mode error interrupt flag (x=7..4)               */
      __IM  uint32_t TEIF6      : 1;            /*!< [19..19] Stream x transfer error interrupt flag (x=7..4)                  */
      __IM  uint32_t HTIF6      : 1;            /*!< [20..20] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32_t TCIF6      : 1;            /*!< [21..21] Stream x transfer complete interrupt flag (x=7..4)               */
      __IM  uint32_t FEIF7      : 1;            /*!< [22..22] Stream x FIFO error interrupt flag (x=7..4)                      */
            uint32_t            : 1;
      __IM  uint32_t DMEIF7     : 1;            /*!< [24..24] Stream x direct mode error interrupt flag (x=7..4)               */
      __IM  uint32_t TEIF7      : 1;            /*!< [25..25] Stream x transfer error interrupt flag (x=7..4)                  */
      __IM  uint32_t HTIF7      : 1;            /*!< [26..26] Stream x half transfer interrupt flag (x=7..4)                   */
      __IM  uint32_t TCIF7      : 1;            /*!< [27..27] Stream x transfer complete interrupt flag (x=7..4)               */
            uint32_t            : 4;
    } HISR_b;
  } ;
  
  union {
    __IOM uint32_t LIFCR;                       /*!< (@ 0x00000008) low interrupt flag clear register                          */
    
    struct {
      __IOM uint32_t CFEIF0     : 1;            /*!< [0..0] Stream x clear FIFO error interrupt flag (x = 3..0)                */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF0    : 1;            /*!< [2..2] Stream x clear direct mode error interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32_t CTEIF0     : 1;            /*!< [3..3] Stream x clear transfer error interrupt flag (x = 3..0)            */
      __IOM uint32_t CHTIF0     : 1;            /*!< [4..4] Stream x clear half transfer interrupt flag (x = 3..0)             */
      __IOM uint32_t CTCIF0     : 1;            /*!< [5..5] Stream x clear transfer complete interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32_t CFEIF1     : 1;            /*!< [6..6] Stream x clear FIFO error interrupt flag (x = 3..0)                */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF1    : 1;            /*!< [8..8] Stream x clear direct mode error interrupt flag (x =
                                                     3..0)                                                                     */
      __IOM uint32_t CTEIF1     : 1;            /*!< [9..9] Stream x clear transfer error interrupt flag (x = 3..0)            */
      __IOM uint32_t CHTIF1     : 1;            /*!< [10..10] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32_t CTCIF1     : 1;            /*!< [11..11] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
            uint32_t            : 4;
      __IOM uint32_t CFEIF2     : 1;            /*!< [16..16] Stream x clear FIFO error interrupt flag (x = 3..0)              */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF2    : 1;            /*!< [18..18] Stream x clear direct mode error interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32_t CTEIF2     : 1;            /*!< [19..19] Stream x clear transfer error interrupt flag (x = 3..0)          */
      __IOM uint32_t CHTIF2     : 1;            /*!< [20..20] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32_t CTCIF2     : 1;            /*!< [21..21] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32_t CFEIF3     : 1;            /*!< [22..22] Stream x clear FIFO error interrupt flag (x = 3..0)              */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF3    : 1;            /*!< [24..24] Stream x clear direct mode error interrupt flag (x
                                                     = 3..0)                                                                   */
      __IOM uint32_t CTEIF3     : 1;            /*!< [25..25] Stream x clear transfer error interrupt flag (x = 3..0)          */
      __IOM uint32_t CHTIF3     : 1;            /*!< [26..26] Stream x clear half transfer interrupt flag (x = 3..0)           */
      __IOM uint32_t CTCIF3     : 1;            /*!< [27..27] Stream x clear transfer complete interrupt flag (x
                                                     = 3..0)                                                                   */
            uint32_t            : 4;
    } LIFCR_b;
  } ;
  
  union {
    __IOM uint32_t HIFCR;                       /*!< (@ 0x0000000C) high interrupt flag clear register                         */
    
    struct {
      __IOM uint32_t CFEIF4     : 1;            /*!< [0..0] Stream x clear FIFO error interrupt flag (x = 7..4)                */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF4    : 1;            /*!< [2..2] Stream x clear direct mode error interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32_t CTEIF4     : 1;            /*!< [3..3] Stream x clear transfer error interrupt flag (x = 7..4)            */
      __IOM uint32_t CHTIF4     : 1;            /*!< [4..4] Stream x clear half transfer interrupt flag (x = 7..4)             */
      __IOM uint32_t CTCIF4     : 1;            /*!< [5..5] Stream x clear transfer complete interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32_t CFEIF5     : 1;            /*!< [6..6] Stream x clear FIFO error interrupt flag (x = 7..4)                */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF5    : 1;            /*!< [8..8] Stream x clear direct mode error interrupt flag (x =
                                                     7..4)                                                                     */
      __IOM uint32_t CTEIF5     : 1;            /*!< [9..9] Stream x clear transfer error interrupt flag (x = 7..4)            */
      __IOM uint32_t CHTIF5     : 1;            /*!< [10..10] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32_t CTCIF5     : 1;            /*!< [11..11] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
            uint32_t            : 4;
      __IOM uint32_t CFEIF6     : 1;            /*!< [16..16] Stream x clear FIFO error interrupt flag (x = 7..4)              */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF6    : 1;            /*!< [18..18] Stream x clear direct mode error interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32_t CTEIF6     : 1;            /*!< [19..19] Stream x clear transfer error interrupt flag (x = 7..4)          */
      __IOM uint32_t CHTIF6     : 1;            /*!< [20..20] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32_t CTCIF6     : 1;            /*!< [21..21] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32_t CFEIF7     : 1;            /*!< [22..22] Stream x clear FIFO error interrupt flag (x = 7..4)              */
            uint32_t            : 1;
      __IOM uint32_t CDMEIF7    : 1;            /*!< [24..24] Stream x clear direct mode error interrupt flag (x
                                                     = 7..4)                                                                   */
      __IOM uint32_t CTEIF7     : 1;            /*!< [25..25] Stream x clear transfer error interrupt flag (x = 7..4)          */
      __IOM uint32_t CHTIF7     : 1;            /*!< [26..26] Stream x clear half transfer interrupt flag (x = 7..4)           */
      __IOM uint32_t CTCIF7     : 1;            /*!< [27..27] Stream x clear transfer complete interrupt flag (x
                                                     = 7..4)                                                                   */
            uint32_t            : 4;
    } HIFCR_b;
  } ;
  
  union {
    __IOM uint32_t S0CR;                        /*!< (@ 0x00000010) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
            uint32_t            : 1;
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S0CR_b;
  } ;
  
  union {
    __IOM uint32_t S0NDTR;                      /*!< (@ 0x00000014) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S0NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S0PAR;                       /*!< (@ 0x00000018) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S0PAR_b;
  } ;
  
  union {
    __IOM uint32_t S0M0AR;                      /*!< (@ 0x0000001C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S0M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S0M1AR;                      /*!< (@ 0x00000020) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S0M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S0FCR;                       /*!< (@ 0x00000024) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S0FCR_b;
  } ;
  
  union {
    __IOM uint32_t S1CR;                        /*!< (@ 0x00000028) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S1CR_b;
  } ;
  
  union {
    __IOM uint32_t S1NDTR;                      /*!< (@ 0x0000002C) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S1NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S1PAR;                       /*!< (@ 0x00000030) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S1PAR_b;
  } ;
  
  union {
    __IOM uint32_t S1M0AR;                      /*!< (@ 0x00000034) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S1M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S1M1AR;                      /*!< (@ 0x00000038) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S1M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S1FCR;                       /*!< (@ 0x0000003C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S1FCR_b;
  } ;
  
  union {
    __IOM uint32_t S2CR;                        /*!< (@ 0x00000040) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S2CR_b;
  } ;
  
  union {
    __IOM uint32_t S2NDTR;                      /*!< (@ 0x00000044) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S2NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S2PAR;                       /*!< (@ 0x00000048) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S2PAR_b;
  } ;
  
  union {
    __IOM uint32_t S2M0AR;                      /*!< (@ 0x0000004C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S2M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S2M1AR;                      /*!< (@ 0x00000050) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S2M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S2FCR;                       /*!< (@ 0x00000054) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S2FCR_b;
  } ;
  
  union {
    __IOM uint32_t S3CR;                        /*!< (@ 0x00000058) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S3CR_b;
  } ;
  
  union {
    __IOM uint32_t S3NDTR;                      /*!< (@ 0x0000005C) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S3NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S3PAR;                       /*!< (@ 0x00000060) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S3PAR_b;
  } ;
  
  union {
    __IOM uint32_t S3M0AR;                      /*!< (@ 0x00000064) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S3M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S3M1AR;                      /*!< (@ 0x00000068) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S3M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S3FCR;                       /*!< (@ 0x0000006C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S3FCR_b;
  } ;
  
  union {
    __IOM uint32_t S4CR;                        /*!< (@ 0x00000070) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S4CR_b;
  } ;
  
  union {
    __IOM uint32_t S4NDTR;                      /*!< (@ 0x00000074) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S4NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S4PAR;                       /*!< (@ 0x00000078) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S4PAR_b;
  } ;
  
  union {
    __IOM uint32_t S4M0AR;                      /*!< (@ 0x0000007C) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S4M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S4M1AR;                      /*!< (@ 0x00000080) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S4M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S4FCR;                       /*!< (@ 0x00000084) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S4FCR_b;
  } ;
  
  union {
    __IOM uint32_t S5CR;                        /*!< (@ 0x00000088) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S5CR_b;
  } ;
  
  union {
    __IOM uint32_t S5NDTR;                      /*!< (@ 0x0000008C) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S5NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S5PAR;                       /*!< (@ 0x00000090) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S5PAR_b;
  } ;
  
  union {
    __IOM uint32_t S5M0AR;                      /*!< (@ 0x00000094) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S5M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S5M1AR;                      /*!< (@ 0x00000098) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S5M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S5FCR;                       /*!< (@ 0x0000009C) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S5FCR_b;
  } ;
  
  union {
    __IOM uint32_t S6CR;                        /*!< (@ 0x000000A0) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S6CR_b;
  } ;
  
  union {
    __IOM uint32_t S6NDTR;                      /*!< (@ 0x000000A4) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S6NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S6PAR;                       /*!< (@ 0x000000A8) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S6PAR_b;
  } ;
  
  union {
    __IOM uint32_t S6M0AR;                      /*!< (@ 0x000000AC) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S6M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S6M1AR;                      /*!< (@ 0x000000B0) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S6M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S6FCR;                       /*!< (@ 0x000000B4) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S6FCR_b;
  } ;
  
  union {
    __IOM uint32_t S7CR;                        /*!< (@ 0x000000B8) stream x configuration register                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Stream enable / flag stream ready when read low                    */
      __IOM uint32_t DMEIE      : 1;            /*!< [1..1] Direct mode error interrupt enable                                 */
      __IOM uint32_t TEIE       : 1;            /*!< [2..2] Transfer error interrupt enable                                    */
      __IOM uint32_t HTIE       : 1;            /*!< [3..3] Half transfer interrupt enable                                     */
      __IOM uint32_t TCIE       : 1;            /*!< [4..4] Transfer complete interrupt enable                                 */
      __IOM uint32_t PFCTRL     : 1;            /*!< [5..5] Peripheral flow controller                                         */
      __IOM uint32_t DIR        : 2;            /*!< [7..6] Data transfer direction                                            */
      __IOM uint32_t CIRC       : 1;            /*!< [8..8] Circular mode                                                      */
      __IOM uint32_t PINC       : 1;            /*!< [9..9] Peripheral increment mode                                          */
      __IOM uint32_t MINC       : 1;            /*!< [10..10] Memory increment mode                                            */
      __IOM uint32_t PSIZE      : 2;            /*!< [12..11] Peripheral data size                                             */
      __IOM uint32_t MSIZE      : 2;            /*!< [14..13] Memory data size                                                 */
      __IOM uint32_t PINCOS     : 1;            /*!< [15..15] Peripheral increment offset size                                 */
      __IOM uint32_t PL         : 2;            /*!< [17..16] Priority level                                                   */
      __IOM uint32_t DBM        : 1;            /*!< [18..18] Double buffer mode                                               */
      __IOM uint32_t CT         : 1;            /*!< [19..19] Current target (only in double buffer mode)                      */
      __IOM uint32_t ACK        : 1;            /*!< [20..20] ACK                                                              */
      __IOM uint32_t PBURST     : 2;            /*!< [22..21] Peripheral burst transfer configuration                          */
      __IOM uint32_t MBURST     : 2;            /*!< [24..23] Memory burst transfer configuration                              */
            uint32_t            : 7;
    } S7CR_b;
  } ;
  
  union {
    __IOM uint32_t S7NDTR;                      /*!< (@ 0x000000BC) stream x number of data register                           */
    
    struct {
      __IOM uint32_t NDT        : 16;           /*!< [15..0] Number of data items to transfer                                  */
            uint32_t            : 16;
    } S7NDTR_b;
  } ;
  
  union {
    __IOM uint32_t S7PAR;                       /*!< (@ 0x000000C0) stream x peripheral address register                       */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< [31..0] Peripheral address                                                */
    } S7PAR_b;
  } ;
  
  union {
    __IOM uint32_t S7M0AR;                      /*!< (@ 0x000000C4) stream x memory 0 address register                         */
    
    struct {
      __IOM uint32_t M0A        : 32;           /*!< [31..0] Memory 0 address                                                  */
    } S7M0AR_b;
  } ;
  
  union {
    __IOM uint32_t S7M1AR;                      /*!< (@ 0x000000C8) stream x memory 1 address register                         */
    
    struct {
      __IOM uint32_t M1A        : 32;           /*!< [31..0] Memory 1 address (used in case of Double buffer mode)             */
    } S7M1AR_b;
  } ;
  
  union {
    __IOM uint32_t S7FCR;                       /*!< (@ 0x000000CC) stream x FIFO control register                             */
    
    struct {
      __IOM uint32_t FTH        : 2;            /*!< [1..0] FIFO threshold selection                                           */
      __IOM uint32_t DMDIS      : 1;            /*!< [2..2] Direct mode disable                                                */
      __IM  uint32_t FS         : 3;            /*!< [5..3] FIFO status                                                        */
            uint32_t            : 1;
      __IOM uint32_t FEIE       : 1;            /*!< [7..7] FIFO error interrupt enable                                        */
            uint32_t            : 24;
    } S7FCR_b;
  } ;
} DMA1_Type;                                    /*!< Size = 208 (0xd0)                                                         */



/* =========================================================================================================================== */
/* ================                                       HRTIM_Master                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: Master
      Timers (HRTIM_Master)
  */

typedef struct {                                /*!< (@ 0x40017400) HRTIM_Master Structure                                     */
  
  union {
    __IOM uint32_t MCR;                         /*!< (@ 0x00000000) Master Timer Control Register                              */
    
    struct {
      __IOM uint32_t CK_PSC     : 3;            /*!< [2..0] HRTIM Master Clock prescaler                                       */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Master Continuous mode                                             */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Master Re-triggerable mode                                         */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
            uint32_t            : 2;
      __IOM uint32_t SYNC_IN    : 2;            /*!< [9..8] ynchronization input                                               */
      __IOM uint32_t SYNCRSTM   : 1;            /*!< [10..10] Synchronization Resets Master                                    */
      __IOM uint32_t SYNCSTRTM  : 1;            /*!< [11..11] Synchronization Starts Master                                    */
      __IOM uint32_t SYNC_OUT   : 2;            /*!< [13..12] Synchronization output                                           */
      __IOM uint32_t SYNC_SRC   : 2;            /*!< [15..14] Synchronization source                                           */
      __IOM uint32_t MCEN       : 1;            /*!< [16..16] Master Counter enable                                            */
      __IOM uint32_t TACEN      : 1;            /*!< [17..17] Timer A counter enable                                           */
      __IOM uint32_t TBCEN      : 1;            /*!< [18..18] Timer B counter enable                                           */
      __IOM uint32_t TCCEN      : 1;            /*!< [19..19] Timer C counter enable                                           */
      __IOM uint32_t TDCEN      : 1;            /*!< [20..20] Timer D counter enable                                           */
      __IOM uint32_t TECEN      : 1;            /*!< [21..21] Timer E counter enable                                           */
            uint32_t            : 3;
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
            uint32_t            : 1;
      __IOM uint32_t MREPU      : 1;            /*!< [29..29] Master Timer Repetition update                                   */
      __IOM uint32_t BRSTDMA    : 2;            /*!< [31..30] Burst DMA Update                                                 */
    } MCR_b;
  } ;
  
  union {
    __IM  uint32_t MISR;                        /*!< (@ 0x00000004) Master Timer Interrupt Status Register                     */
    
    struct {
      __IM  uint32_t MCMP1      : 1;            /*!< [0..0] Master Compare 1 Interrupt Flag                                    */
      __IM  uint32_t MCMP2      : 1;            /*!< [1..1] Master Compare 2 Interrupt Flag                                    */
      __IM  uint32_t MCMP3      : 1;            /*!< [2..2] Master Compare 3 Interrupt Flag                                    */
      __IM  uint32_t MCMP4      : 1;            /*!< [3..3] Master Compare 4 Interrupt Flag                                    */
      __IM  uint32_t MREP       : 1;            /*!< [4..4] Master Repetition Interrupt Flag                                   */
      __IM  uint32_t SYNC       : 1;            /*!< [5..5] Sync Input Interrupt Flag                                          */
      __IM  uint32_t MUPD       : 1;            /*!< [6..6] Master Update Interrupt Flag                                       */
            uint32_t            : 25;
    } MISR_b;
  } ;
  
  union {
    __OM  uint32_t MICR;                        /*!< (@ 0x00000008) Master Timer Interrupt Clear Register                      */
    
    struct {
      __OM  uint32_t MCMP1C     : 1;            /*!< [0..0] Master Compare 1 Interrupt flag clear                              */
      __OM  uint32_t MCMP2C     : 1;            /*!< [1..1] Master Compare 2 Interrupt flag clear                              */
      __OM  uint32_t MCMP3C     : 1;            /*!< [2..2] Master Compare 3 Interrupt flag clear                              */
      __OM  uint32_t MCMP4C     : 1;            /*!< [3..3] Master Compare 4 Interrupt flag clear                              */
      __OM  uint32_t MREPC      : 1;            /*!< [4..4] Repetition Interrupt flag clear                                    */
      __OM  uint32_t SYNCC      : 1;            /*!< [5..5] Sync Input Interrupt flag clear                                    */
      __OM  uint32_t MUPDC      : 1;            /*!< [6..6] Master update Interrupt flag clear                                 */
            uint32_t            : 25;
    } MICR_b;
  } ;
  
  union {
    __IOM uint32_t MDIER4;                      /*!< (@ 0x0000000C) MDIER4                                                     */
    
    struct {
      __IOM uint32_t MCMP1IE    : 1;            /*!< [0..0] MCMP1IE                                                            */
      __IOM uint32_t MCMP2IE    : 1;            /*!< [1..1] MCMP2IE                                                            */
      __IOM uint32_t MCMP3IE    : 1;            /*!< [2..2] MCMP3IE                                                            */
      __IOM uint32_t MCMP4IE    : 1;            /*!< [3..3] MCMP4IE                                                            */
      __IOM uint32_t MREPIE     : 1;            /*!< [4..4] MREPIE                                                             */
      __IOM uint32_t SYNCIE     : 1;            /*!< [5..5] SYNCIE                                                             */
      __IOM uint32_t MUPDIE     : 1;            /*!< [6..6] MUPDIE                                                             */
            uint32_t            : 9;
      __IOM uint32_t MCMP1DE    : 1;            /*!< [16..16] MCMP1DE                                                          */
      __IOM uint32_t MCMP2DE    : 1;            /*!< [17..17] MCMP2DE                                                          */
      __IOM uint32_t MCMP3DE    : 1;            /*!< [18..18] MCMP3DE                                                          */
      __IOM uint32_t MCMP4DE    : 1;            /*!< [19..19] MCMP4DE                                                          */
      __IOM uint32_t MREPDE     : 1;            /*!< [20..20] MREPDE                                                           */
      __IOM uint32_t SYNCDE     : 1;            /*!< [21..21] SYNCDE                                                           */
      __IOM uint32_t MUPDDE     : 1;            /*!< [22..22] MUPDDE                                                           */
            uint32_t            : 9;
    } MDIER4_b;
  } ;
  
  union {
    __IOM uint32_t MCNTR;                       /*!< (@ 0x00000010) Master Timer Counter Register                              */
    
    struct {
      __IOM uint32_t MCNT       : 16;           /*!< [15..0] Counter value                                                     */
            uint32_t            : 16;
    } MCNTR_b;
  } ;
  
  union {
    __IOM uint32_t MPER;                        /*!< (@ 0x00000014) Master Timer Period Register                               */
    
    struct {
      __IOM uint32_t MPER       : 16;           /*!< [15..0] Master Timer Period value                                         */
            uint32_t            : 16;
    } MPER_b;
  } ;
  
  union {
    __IOM uint32_t MREP;                        /*!< (@ 0x00000018) Master Timer Repetition Register                           */
    
    struct {
      __IOM uint32_t MREP       : 8;            /*!< [7..0] Master Timer Repetition counter value                              */
            uint32_t            : 24;
    } MREP_b;
  } ;
  
  union {
    __IOM uint32_t MCMP1R;                      /*!< (@ 0x0000001C) Master Timer Compare 1 Register                            */
    
    struct {
      __IOM uint32_t MCMP1      : 16;           /*!< [15..0] Master Timer Compare 1 value                                      */
            uint32_t            : 16;
    } MCMP1R_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t MCMP2R;                      /*!< (@ 0x00000024) Master Timer Compare 2 Register                            */
    
    struct {
      __IOM uint32_t MCMP2      : 16;           /*!< [15..0] Master Timer Compare 2 value                                      */
            uint32_t            : 16;
    } MCMP2R_b;
  } ;
  
  union {
    __IOM uint32_t MCMP3R;                      /*!< (@ 0x00000028) Master Timer Compare 3 Register                            */
    
    struct {
      __IOM uint32_t MCMP3      : 16;           /*!< [15..0] Master Timer Compare 3 value                                      */
            uint32_t            : 16;
    } MCMP3R_b;
  } ;
  
  union {
    __IOM uint32_t MCMP4R;                      /*!< (@ 0x0000002C) Master Timer Compare 4 Register                            */
    
    struct {
      __IOM uint32_t MCMP4      : 16;           /*!< [15..0] Master Timer Compare 4 value                                      */
            uint32_t            : 16;
    } MCMP4R_b;
  } ;
} HRTIM_Master_Type;                            /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMA                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMA (HRTIM_TIMA)
  */

typedef struct {                                /*!< (@ 0x40017480) HRTIM_TIMA Structure                                       */
  
  union {
    __IOM uint32_t TIMACR;                      /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32_t CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32_t PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32_t SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32_t DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32_t DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32_t            : 1;
      __IOM uint32_t TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32_t TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32_t            : 1;
      __IOM uint32_t TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32_t TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32_t TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32_t TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32_t MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32_t UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } TIMACR_b;
  } ;
  
  union {
    __IM  uint32_t TIMAISR;                     /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32_t CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32_t CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32_t CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32_t REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32_t CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32_t CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32_t SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32_t RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32_t SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32_t RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32_t RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32_t DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32_t IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32_t O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32_t O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32_t            : 12;
    } TIMAISR_b;
  } ;
  
  union {
    __OM  uint32_t TIMAICR;                     /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32_t CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32_t CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32_t CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32_t REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32_t            : 1;
      __OM  uint32_t UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32_t CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32_t CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32_t SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32_t RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32_t SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32_t RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32_t RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32_t DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32_t            : 17;
    } TIMAICR_b;
  } ;
  
  union {
    __IOM uint32_t TIMADIER5;                   /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32_t CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32_t CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32_t CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32_t CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32_t REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32_t            : 1;
      __IOM uint32_t UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32_t CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32_t CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32_t SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32_t RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32_t SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32_t RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32_t RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32_t DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32_t            : 1;
      __IOM uint32_t CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32_t CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32_t CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32_t CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32_t REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32_t            : 1;
      __IOM uint32_t UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32_t CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32_t CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32_t SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32_t RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32_t SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32_t RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32_t RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32_t DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32_t            : 1;
    } TIMADIER5_b;
  } ;
  
  union {
    __IOM uint32_t CNTAR;                       /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32_t CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32_t            : 16;
    } CNTAR_b;
  } ;
  
  union {
    __IOM uint32_t PERAR;                       /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32_t PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32_t            : 16;
    } PERAR_b;
  } ;
  
  union {
    __IOM uint32_t REPAR;                       /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32_t REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32_t            : 24;
    } REPAR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1AR;                      /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32_t            : 16;
    } CMP1AR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CAR;                     /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32_t REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32_t            : 8;
    } CMP1CAR_b;
  } ;
  
  union {
    __IOM uint32_t CMP2AR;                      /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32_t CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32_t            : 16;
    } CMP2AR_b;
  } ;
  
  union {
    __IOM uint32_t CMP3AR;                      /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32_t CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32_t            : 16;
    } CMP3AR_b;
  } ;
  
  union {
    __IOM uint32_t CMP4AR;                      /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32_t CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32_t            : 16;
    } CMP4AR_b;
  } ;
  
  union {
    __IM  uint32_t CPT1AR;                      /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32_t CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32_t            : 16;
    } CPT1AR_b;
  } ;
  
  union {
    __IM  uint32_t CPT2AR;                      /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32_t CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32_t            : 16;
    } CPT2AR_b;
  } ;
  
  union {
    __IOM uint32_t DTAR;                        /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32_t DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32_t SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32_t DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32_t            : 1;
      __IOM uint32_t DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32_t DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32_t DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32_t SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32_t            : 4;
      __IOM uint32_t DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32_t DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } DTAR_b;
  } ;
  
  union {
    __IOM uint32_t SETA1R;                      /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32_t PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } SETA1R_b;
  } ;
  
  union {
    __IOM uint32_t RSTA1R;                      /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTA1R_b;
  } ;
  
  union {
    __IOM uint32_t SETA2R;                      /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } SETA2R_b;
  } ;
  
  union {
    __IOM uint32_t RSTA2R;                      /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTA2R_b;
  } ;
  
  union {
    __IOM uint32_t EEFAR1;                      /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32_t EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32_t EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32_t EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32_t EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32_t EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32_t EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32_t            : 3;
    } EEFAR1_b;
  } ;
  
  union {
    __IOM uint32_t EEFAR2;                      /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32_t EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32_t EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32_t EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32_t EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32_t EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32_t EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32_t            : 3;
    } EEFAR2_b;
  } ;
  
  union {
    __IOM uint32_t RSTAR;                       /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32_t CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32_t MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32_t TIMBCMP1   : 1;            /*!< [19..19] Timer B Compare 1                                                */
      __IOM uint32_t TIMBCMP2   : 1;            /*!< [20..20] Timer B Compare 2                                                */
      __IOM uint32_t TIMBCMP4   : 1;            /*!< [21..21] Timer B Compare 4                                                */
      __IOM uint32_t TIMCCMP1   : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TIMCCMP2   : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TIMCCMP4   : 1;            /*!< [24..24] Timer C Compare 4                                                */
      __IOM uint32_t TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32_t TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32_t TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32_t TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32_t TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32_t TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32_t            : 1;
    } RSTAR_b;
  } ;
  
  union {
    __IOM uint32_t CHPAR;                       /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32_t CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32_t CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32_t STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32_t            : 21;
    } CHPAR_b;
  } ;
  
  union {
    __IOM uint32_t CPT1ACR;                     /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
            uint32_t            : 4;
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT1ACR_b;
  } ;
  
  union {
    __IOM uint32_t CPT2ACR;                     /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
            uint32_t            : 4;
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT2ACR_b;
  } ;
  
  union {
    __IOM uint32_t OUTAR;                       /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32_t IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32_t IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32_t FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32_t CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32_t DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32_t DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32_t DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32_t DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32_t            : 4;
      __IOM uint32_t POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32_t IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32_t IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32_t FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32_t CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32_t DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32_t            : 8;
    } OUTAR_b;
  } ;
  
  union {
    __IOM uint32_t FLTAR;                       /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32_t FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32_t FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32_t FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32_t FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32_t FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32_t            : 26;
      __IOM uint32_t FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } FLTAR_b;
  } ;
} HRTIM_TIMA_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMB                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMB (HRTIM_TIMB)
  */

typedef struct {                                /*!< (@ 0x40017500) HRTIM_TIMB Structure                                       */
  
  union {
    __IOM uint32_t TIMBCR;                      /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32_t CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32_t PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32_t SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32_t DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32_t DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32_t            : 1;
      __IOM uint32_t TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32_t TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32_t            : 1;
      __IOM uint32_t TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32_t TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32_t TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32_t TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32_t MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32_t UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } TIMBCR_b;
  } ;
  
  union {
    __IM  uint32_t TIMBISR;                     /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32_t CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32_t CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32_t CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32_t REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32_t CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32_t CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32_t SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32_t RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32_t SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32_t RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32_t RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32_t DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32_t IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32_t O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32_t O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32_t            : 12;
    } TIMBISR_b;
  } ;
  
  union {
    __OM  uint32_t TIMBICR;                     /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32_t CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32_t CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32_t CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32_t REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32_t            : 1;
      __OM  uint32_t UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32_t CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32_t CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32_t SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32_t RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32_t SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32_t RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32_t RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32_t DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32_t            : 17;
    } TIMBICR_b;
  } ;
  
  union {
    __IOM uint32_t TIMBDIER5;                   /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32_t CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32_t CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32_t CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32_t CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32_t REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32_t            : 1;
      __IOM uint32_t UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32_t CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32_t CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32_t SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32_t RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32_t SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32_t RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32_t RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32_t DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32_t            : 1;
      __IOM uint32_t CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32_t CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32_t CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32_t CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32_t REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32_t            : 1;
      __IOM uint32_t UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32_t CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32_t CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32_t SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32_t RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32_t SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32_t RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32_t RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32_t DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32_t            : 1;
    } TIMBDIER5_b;
  } ;
  
  union {
    __IOM uint32_t CNTR;                        /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32_t CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32_t            : 16;
    } CNTR_b;
  } ;
  
  union {
    __IOM uint32_t PERBR;                       /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32_t PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32_t            : 16;
    } PERBR_b;
  } ;
  
  union {
    __IOM uint32_t REPBR;                       /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32_t REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32_t            : 24;
    } REPBR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1BR;                      /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32_t            : 16;
    } CMP1BR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CBR;                     /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32_t REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32_t            : 8;
    } CMP1CBR_b;
  } ;
  
  union {
    __IOM uint32_t CMP2BR;                      /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32_t CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32_t            : 16;
    } CMP2BR_b;
  } ;
  
  union {
    __IOM uint32_t CMP3BR;                      /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32_t CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32_t            : 16;
    } CMP3BR_b;
  } ;
  
  union {
    __IOM uint32_t CMP4BR;                      /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32_t CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32_t            : 16;
    } CMP4BR_b;
  } ;
  
  union {
    __IM  uint32_t CPT1BR;                      /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32_t CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32_t            : 16;
    } CPT1BR_b;
  } ;
  
  union {
    __IM  uint32_t CPT2BR;                      /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32_t CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32_t            : 16;
    } CPT2BR_b;
  } ;
  
  union {
    __IOM uint32_t DTBR;                        /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32_t DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32_t SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32_t DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32_t            : 1;
      __IOM uint32_t DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32_t DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32_t DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32_t SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32_t            : 4;
      __IOM uint32_t DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32_t DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } DTBR_b;
  } ;
  
  union {
    __IOM uint32_t SETB1R;                      /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32_t PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } SETB1R_b;
  } ;
  
  union {
    __IOM uint32_t RSTB1R;                      /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTB1R_b;
  } ;
  
  union {
    __IOM uint32_t SETB2R;                      /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } SETB2R_b;
  } ;
  
  union {
    __IOM uint32_t RSTB2R;                      /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTB2R_b;
  } ;
  
  union {
    __IOM uint32_t EEFBR1;                      /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32_t EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32_t EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32_t EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32_t EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32_t EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32_t EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32_t            : 3;
    } EEFBR1_b;
  } ;
  
  union {
    __IOM uint32_t EEFBR2;                      /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32_t EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32_t EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32_t EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32_t EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32_t EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32_t EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32_t            : 3;
    } EEFBR2_b;
  } ;
  
  union {
    __IOM uint32_t RSTBR;                       /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32_t CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32_t MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32_t TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32_t TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32_t TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32_t TIMCCMP1   : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TIMCCMP2   : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TIMCCMP4   : 1;            /*!< [24..24] Timer C Compare 4                                                */
      __IOM uint32_t TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32_t TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32_t TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32_t TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32_t TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32_t TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32_t            : 1;
    } RSTBR_b;
  } ;
  
  union {
    __IOM uint32_t CHPBR;                       /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32_t CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32_t CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32_t STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32_t            : 21;
    } CHPBR_b;
  } ;
  
  union {
    __IOM uint32_t CPT1BCR;                     /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT1BCR_b;
  } ;
  
  union {
    __IOM uint32_t CPT2BCR;                     /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT2BCR_b;
  } ;
  
  union {
    __IOM uint32_t OUTBR;                       /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32_t IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32_t IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32_t FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32_t CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32_t DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32_t DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32_t DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32_t DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32_t            : 4;
      __IOM uint32_t POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32_t IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32_t IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32_t FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32_t CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32_t DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32_t            : 8;
    } OUTBR_b;
  } ;
  
  union {
    __IOM uint32_t FLTBR;                       /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32_t FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32_t FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32_t FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32_t FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32_t FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32_t            : 26;
      __IOM uint32_t FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } FLTBR_b;
  } ;
} HRTIM_TIMB_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMC                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMC (HRTIM_TIMC)
  */

typedef struct {                                /*!< (@ 0x40017580) HRTIM_TIMC Structure                                       */
  
  union {
    __IOM uint32_t TIMCCR;                      /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32_t CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32_t PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32_t SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32_t DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32_t DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32_t            : 1;
      __IOM uint32_t TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32_t TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32_t            : 1;
      __IOM uint32_t TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32_t TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32_t TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32_t TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32_t MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32_t UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } TIMCCR_b;
  } ;
  
  union {
    __IM  uint32_t TIMCISR;                     /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32_t CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32_t CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32_t CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32_t REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32_t CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32_t CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32_t SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32_t RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32_t SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32_t RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32_t RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32_t DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32_t IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32_t O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32_t O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32_t            : 12;
    } TIMCISR_b;
  } ;
  
  union {
    __OM  uint32_t TIMCICR;                     /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32_t CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32_t CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32_t CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32_t REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32_t            : 1;
      __OM  uint32_t UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32_t CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32_t CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32_t SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32_t RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32_t SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32_t RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32_t RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32_t DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32_t            : 17;
    } TIMCICR_b;
  } ;
  
  union {
    __IOM uint32_t TIMCDIER5;                   /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32_t CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32_t CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32_t CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32_t CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32_t REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32_t            : 1;
      __IOM uint32_t UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32_t CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32_t CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32_t SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32_t RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32_t SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32_t RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32_t RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32_t DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32_t            : 1;
      __IOM uint32_t CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32_t CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32_t CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32_t CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32_t REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32_t            : 1;
      __IOM uint32_t UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32_t CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32_t CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32_t SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32_t RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32_t SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32_t RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32_t RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32_t DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32_t            : 1;
    } TIMCDIER5_b;
  } ;
  
  union {
    __IOM uint32_t CNTCR;                       /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32_t CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32_t            : 16;
    } CNTCR_b;
  } ;
  
  union {
    __IOM uint32_t PERCR;                       /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32_t PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32_t            : 16;
    } PERCR_b;
  } ;
  
  union {
    __IOM uint32_t REPCR;                       /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32_t REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32_t            : 24;
    } REPCR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CR;                      /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32_t            : 16;
    } CMP1CR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CCR;                     /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32_t REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32_t            : 8;
    } CMP1CCR_b;
  } ;
  
  union {
    __IOM uint32_t CMP2CR;                      /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32_t CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32_t            : 16;
    } CMP2CR_b;
  } ;
  
  union {
    __IOM uint32_t CMP3CR;                      /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32_t CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32_t            : 16;
    } CMP3CR_b;
  } ;
  
  union {
    __IOM uint32_t CMP4CR;                      /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32_t CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32_t            : 16;
    } CMP4CR_b;
  } ;
  
  union {
    __IM  uint32_t CPT1CR;                      /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32_t CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32_t            : 16;
    } CPT1CR_b;
  } ;
  
  union {
    __IM  uint32_t CPT2CR;                      /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32_t CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32_t            : 16;
    } CPT2CR_b;
  } ;
  
  union {
    __IOM uint32_t DTCR;                        /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32_t DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32_t SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32_t DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32_t            : 1;
      __IOM uint32_t DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32_t DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32_t DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32_t SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32_t            : 4;
      __IOM uint32_t DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32_t DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } DTCR_b;
  } ;
  
  union {
    __IOM uint32_t SETC1R;                      /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32_t PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } SETC1R_b;
  } ;
  
  union {
    __IOM uint32_t RSTC1R;                      /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTC1R_b;
  } ;
  
  union {
    __IOM uint32_t SETC2R;                      /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } SETC2R_b;
  } ;
  
  union {
    __IOM uint32_t RSTC2R;                      /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTC2R_b;
  } ;
  
  union {
    __IOM uint32_t EEFCR1;                      /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32_t EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32_t EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32_t EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32_t EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32_t EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32_t EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32_t            : 3;
    } EEFCR1_b;
  } ;
  
  union {
    __IOM uint32_t EEFCR2;                      /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32_t EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32_t EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32_t EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32_t EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32_t EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32_t EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32_t            : 3;
    } EEFCR2_b;
  } ;
  
  union {
    __IOM uint32_t RSTCR;                       /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32_t CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32_t MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32_t TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32_t TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32_t TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32_t TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32_t TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32_t TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32_t TIMDCMP1   : 1;            /*!< [25..25] Timer D Compare 1                                                */
      __IOM uint32_t TIMDCMP2   : 1;            /*!< [26..26] Timer D Compare 2                                                */
      __IOM uint32_t TIMDCMP4   : 1;            /*!< [27..27] Timer D Compare 4                                                */
      __IOM uint32_t TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32_t TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32_t TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32_t            : 1;
    } RSTCR_b;
  } ;
  
  union {
    __IOM uint32_t CHPCR;                       /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32_t CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32_t CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32_t STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32_t            : 21;
    } CHPCR_b;
  } ;
  
  union {
    __IOM uint32_t CPT1CCR;                     /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT1CCR_b;
  } ;
  
  union {
    __IOM uint32_t CPT2CCR;                     /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT2CCR_b;
  } ;
  
  union {
    __IOM uint32_t OUTCR;                       /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32_t IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32_t IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32_t FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32_t CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32_t DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32_t DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32_t DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32_t DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32_t            : 4;
      __IOM uint32_t POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32_t IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32_t IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32_t FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32_t CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32_t DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32_t            : 8;
    } OUTCR_b;
  } ;
  
  union {
    __IOM uint32_t FLTCR;                       /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32_t FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32_t FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32_t FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32_t FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32_t FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32_t            : 26;
      __IOM uint32_t FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } FLTCR_b;
  } ;
} HRTIM_TIMC_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIMD                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIMD (HRTIM_TIMD)
  */

typedef struct {                                /*!< (@ 0x40017600) HRTIM_TIMD Structure                                       */
  
  union {
    __IOM uint32_t TIMDCR;                      /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32_t CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32_t PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32_t SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32_t DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32_t DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32_t            : 1;
      __IOM uint32_t TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32_t TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32_t            : 1;
      __IOM uint32_t TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32_t TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32_t TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32_t TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32_t MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32_t UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } TIMDCR_b;
  } ;
  
  union {
    __IM  uint32_t TIMDISR;                     /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32_t CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32_t CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32_t CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32_t REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32_t CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32_t CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32_t SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32_t RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32_t SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32_t RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32_t RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32_t DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32_t IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32_t O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32_t O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32_t            : 12;
    } TIMDISR_b;
  } ;
  
  union {
    __OM  uint32_t TIMDICR;                     /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32_t CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32_t CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32_t CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32_t REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32_t            : 1;
      __OM  uint32_t UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32_t CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32_t CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32_t SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32_t RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32_t SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32_t RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32_t RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32_t DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32_t            : 17;
    } TIMDICR_b;
  } ;
  
  union {
    __IOM uint32_t TIMDDIER5;                   /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32_t CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32_t CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32_t CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32_t CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32_t REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32_t            : 1;
      __IOM uint32_t UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32_t CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32_t CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32_t SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32_t RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32_t SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32_t RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32_t RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32_t DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32_t            : 1;
      __IOM uint32_t CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32_t CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32_t CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32_t CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32_t REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32_t            : 1;
      __IOM uint32_t UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32_t CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32_t CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32_t SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32_t RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32_t SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32_t RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32_t RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32_t DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32_t            : 1;
    } TIMDDIER5_b;
  } ;
  
  union {
    __IOM uint32_t CNTDR;                       /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32_t CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32_t            : 16;
    } CNTDR_b;
  } ;
  
  union {
    __IOM uint32_t PERDR;                       /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32_t PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32_t            : 16;
    } PERDR_b;
  } ;
  
  union {
    __IOM uint32_t REPDR;                       /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32_t REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32_t            : 24;
    } REPDR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1DR;                      /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32_t            : 16;
    } CMP1DR_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CDR;                     /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32_t REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32_t            : 8;
    } CMP1CDR_b;
  } ;
  
  union {
    __IOM uint32_t CMP2DR;                      /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32_t CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32_t            : 16;
    } CMP2DR_b;
  } ;
  
  union {
    __IOM uint32_t CMP3DR;                      /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32_t CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32_t            : 16;
    } CMP3DR_b;
  } ;
  
  union {
    __IOM uint32_t CMP4DR;                      /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32_t CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32_t            : 16;
    } CMP4DR_b;
  } ;
  
  union {
    __IM  uint32_t CPT1DR;                      /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32_t CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32_t            : 16;
    } CPT1DR_b;
  } ;
  
  union {
    __IM  uint32_t CPT2DR;                      /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32_t CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32_t            : 16;
    } CPT2DR_b;
  } ;
  
  union {
    __IOM uint32_t DTDR;                        /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32_t DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32_t SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32_t DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32_t            : 1;
      __IOM uint32_t DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32_t DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32_t DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32_t SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32_t            : 4;
      __IOM uint32_t DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32_t DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } DTDR_b;
  } ;
  
  union {
    __IOM uint32_t SETD1R;                      /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32_t PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } SETD1R_b;
  } ;
  
  union {
    __IOM uint32_t RSTD1R;                      /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTD1R_b;
  } ;
  
  union {
    __IOM uint32_t SETD2R;                      /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } SETD2R_b;
  } ;
  
  union {
    __IOM uint32_t RSTD2R;                      /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTD2R_b;
  } ;
  
  union {
    __IOM uint32_t EEFDR1;                      /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32_t EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32_t EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32_t EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32_t EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32_t EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32_t EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32_t            : 3;
    } EEFDR1_b;
  } ;
  
  union {
    __IOM uint32_t EEFDR2;                      /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32_t EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32_t EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32_t EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32_t EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32_t EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32_t EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32_t            : 3;
    } EEFDR2_b;
  } ;
  
  union {
    __IOM uint32_t RSTDR;                       /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32_t CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32_t MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32_t TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32_t TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32_t TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32_t TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32_t TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32_t TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32_t TIMCCMP1   : 1;            /*!< [25..25] Timer C Compare 1                                                */
      __IOM uint32_t TIMCCMP2   : 1;            /*!< [26..26] Timer C Compare 2                                                */
      __IOM uint32_t TIMCCMP4   : 1;            /*!< [27..27] Timer C Compare 4                                                */
      __IOM uint32_t TIMECMP1   : 1;            /*!< [28..28] Timer E Compare 1                                                */
      __IOM uint32_t TIMECMP2   : 1;            /*!< [29..29] Timer E Compare 2                                                */
      __IOM uint32_t TIMECMP4   : 1;            /*!< [30..30] Timer E Compare 4                                                */
            uint32_t            : 1;
    } RSTDR_b;
  } ;
  
  union {
    __IOM uint32_t CHPDR;                       /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32_t CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32_t CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32_t STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32_t            : 21;
    } CHPDR_b;
  } ;
  
  union {
    __IOM uint32_t CPT1DCR;                     /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT1DCR_b;
  } ;
  
  union {
    __IOM uint32_t CPT2DCR;                     /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
            uint32_t            : 4;
      __IOM uint32_t TE1SET     : 1;            /*!< [28..28] Timer E output 1 Set                                             */
      __IOM uint32_t TE1RST     : 1;            /*!< [29..29] Timer E output 1 Reset                                           */
      __IOM uint32_t TECMP1     : 1;            /*!< [30..30] Timer E Compare 1                                                */
      __IOM uint32_t TECMP2     : 1;            /*!< [31..31] Timer E Compare 2                                                */
    } CPT2DCR_b;
  } ;
  
  union {
    __IOM uint32_t OUTDR;                       /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32_t IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32_t IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32_t FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32_t CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32_t DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32_t DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32_t DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32_t DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32_t            : 4;
      __IOM uint32_t POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32_t IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32_t IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32_t FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32_t CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32_t DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32_t            : 8;
    } OUTDR_b;
  } ;
  
  union {
    __IOM uint32_t FLTDR;                       /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32_t FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32_t FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32_t FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32_t FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32_t FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32_t            : 26;
      __IOM uint32_t FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } FLTDR_b;
  } ;
} HRTIM_TIMD_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                        HRTIM_TIME                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: TIME (HRTIM_TIME)
  */

typedef struct {                                /*!< (@ 0x40017680) HRTIM_TIME Structure                                       */
  
  union {
    __IOM uint32_t TIMECR;                      /*!< (@ 0x00000000) Timerx Control Register                                    */
    
    struct {
      __IOM uint32_t CK_PSCx    : 3;            /*!< [2..0] HRTIM Timer x Clock prescaler                                      */
      __IOM uint32_t CONT       : 1;            /*!< [3..3] Continuous mode                                                    */
      __IOM uint32_t RETRIG     : 1;            /*!< [4..4] Re-triggerable mode                                                */
      __IOM uint32_t HALF       : 1;            /*!< [5..5] Half mode enable                                                   */
      __IOM uint32_t PSHPLL     : 1;            /*!< [6..6] Push-Pull mode enable                                              */
            uint32_t            : 3;
      __IOM uint32_t SYNCRSTx   : 1;            /*!< [10..10] Synchronization Resets Timer x                                   */
      __IOM uint32_t SYNCSTRTx  : 1;            /*!< [11..11] Synchronization Starts Timer x                                   */
      __IOM uint32_t DELCMP2    : 2;            /*!< [13..12] Delayed CMP2 mode                                                */
      __IOM uint32_t DELCMP4    : 2;            /*!< [15..14] Delayed CMP4 mode                                                */
            uint32_t            : 1;
      __IOM uint32_t TxREPU     : 1;            /*!< [17..17] Timer x Repetition update                                        */
      __IOM uint32_t TxRSTU     : 1;            /*!< [18..18] Timerx reset update                                              */
            uint32_t            : 1;
      __IOM uint32_t TBU        : 1;            /*!< [20..20] TBU                                                              */
      __IOM uint32_t TCU        : 1;            /*!< [21..21] TCU                                                              */
      __IOM uint32_t TDU        : 1;            /*!< [22..22] TDU                                                              */
      __IOM uint32_t TEU        : 1;            /*!< [23..23] TEU                                                              */
      __IOM uint32_t MSTU       : 1;            /*!< [24..24] Master Timer update                                              */
      __IOM uint32_t DACSYNC    : 2;            /*!< [26..25] AC Synchronization                                               */
      __IOM uint32_t PREEN      : 1;            /*!< [27..27] Preload enable                                                   */
      __IOM uint32_t UPDGAT     : 4;            /*!< [31..28] Update Gating                                                    */
    } TIMECR_b;
  } ;
  
  union {
    __IM  uint32_t TIMEISR;                     /*!< (@ 0x00000004) Timerx Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t CMP1       : 1;            /*!< [0..0] Compare 1 Interrupt Flag                                           */
      __IM  uint32_t CMP2       : 1;            /*!< [1..1] Compare 2 Interrupt Flag                                           */
      __IM  uint32_t CMP3       : 1;            /*!< [2..2] Compare 3 Interrupt Flag                                           */
      __IM  uint32_t CMP4       : 1;            /*!< [3..3] Compare 4 Interrupt Flag                                           */
      __IM  uint32_t REP        : 1;            /*!< [4..4] Repetition Interrupt Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t UPD        : 1;            /*!< [6..6] Update Interrupt Flag                                              */
      __IM  uint32_t CPT1       : 1;            /*!< [7..7] Capture1 Interrupt Flag                                            */
      __IM  uint32_t CPT2       : 1;            /*!< [8..8] Capture2 Interrupt Flag                                            */
      __IM  uint32_t SETx1      : 1;            /*!< [9..9] Output 1 Set Interrupt Flag                                        */
      __IM  uint32_t RSTx1      : 1;            /*!< [10..10] Output 1 Reset Interrupt Flag                                    */
      __IM  uint32_t SETx2      : 1;            /*!< [11..11] Output 2 Set Interrupt Flag                                      */
      __IM  uint32_t RSTx2      : 1;            /*!< [12..12] Output 2 Reset Interrupt Flag                                    */
      __IM  uint32_t RST        : 1;            /*!< [13..13] Reset Interrupt Flag                                             */
      __IM  uint32_t DLYPRT     : 1;            /*!< [14..14] Delayed Protection Flag                                          */
            uint32_t            : 1;
      __IM  uint32_t CPPSTAT    : 1;            /*!< [16..16] Current Push Pull Status                                         */
      __IM  uint32_t IPPSTAT    : 1;            /*!< [17..17] Idle Push Pull Status                                            */
      __IM  uint32_t O1STAT     : 1;            /*!< [18..18] Output 1 State                                                   */
      __IM  uint32_t O2STAT     : 1;            /*!< [19..19] Output 2 State                                                   */
            uint32_t            : 12;
    } TIMEISR_b;
  } ;
  
  union {
    __OM  uint32_t TIMEICR;                     /*!< (@ 0x00000008) Timerx Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t CMP1C      : 1;            /*!< [0..0] Compare 1 Interrupt flag Clear                                     */
      __OM  uint32_t CMP2C      : 1;            /*!< [1..1] Compare 2 Interrupt flag Clear                                     */
      __OM  uint32_t CMP3C      : 1;            /*!< [2..2] Compare 3 Interrupt flag Clear                                     */
      __OM  uint32_t CMP4C      : 1;            /*!< [3..3] Compare 4 Interrupt flag Clear                                     */
      __OM  uint32_t REPC       : 1;            /*!< [4..4] Repetition Interrupt flag Clear                                    */
            uint32_t            : 1;
      __OM  uint32_t UPDC       : 1;            /*!< [6..6] Update Interrupt flag Clear                                        */
      __OM  uint32_t CPT1C      : 1;            /*!< [7..7] Capture1 Interrupt flag Clear                                      */
      __OM  uint32_t CPT2C      : 1;            /*!< [8..8] Capture2 Interrupt flag Clear                                      */
      __OM  uint32_t SET1xC     : 1;            /*!< [9..9] Output 1 Set flag Clear                                            */
      __OM  uint32_t RSTx1C     : 1;            /*!< [10..10] Output 1 Reset flag Clear                                        */
      __OM  uint32_t SET2xC     : 1;            /*!< [11..11] Output 2 Set flag Clear                                          */
      __OM  uint32_t RSTx2C     : 1;            /*!< [12..12] Output 2 Reset flag Clear                                        */
      __OM  uint32_t RSTC       : 1;            /*!< [13..13] Reset Interrupt flag Clear                                       */
      __OM  uint32_t DLYPRTC    : 1;            /*!< [14..14] Delayed Protection Flag Clear                                    */
            uint32_t            : 17;
    } TIMEICR_b;
  } ;
  
  union {
    __IOM uint32_t TIMEDIER5;                   /*!< (@ 0x0000000C) TIMxDIER5                                                  */
    
    struct {
      __IOM uint32_t CMP1IE     : 1;            /*!< [0..0] CMP1IE                                                             */
      __IOM uint32_t CMP2IE     : 1;            /*!< [1..1] CMP2IE                                                             */
      __IOM uint32_t CMP3IE     : 1;            /*!< [2..2] CMP3IE                                                             */
      __IOM uint32_t CMP4IE     : 1;            /*!< [3..3] CMP4IE                                                             */
      __IOM uint32_t REPIE      : 1;            /*!< [4..4] REPIE                                                              */
            uint32_t            : 1;
      __IOM uint32_t UPDIE      : 1;            /*!< [6..6] UPDIE                                                              */
      __IOM uint32_t CPT1IE     : 1;            /*!< [7..7] CPT1IE                                                             */
      __IOM uint32_t CPT2IE     : 1;            /*!< [8..8] CPT2IE                                                             */
      __IOM uint32_t SET1xIE    : 1;            /*!< [9..9] SET1xIE                                                            */
      __IOM uint32_t RSTx1IE    : 1;            /*!< [10..10] RSTx1IE                                                          */
      __IOM uint32_t SETx2IE    : 1;            /*!< [11..11] SETx2IE                                                          */
      __IOM uint32_t RSTx2IE    : 1;            /*!< [12..12] RSTx2IE                                                          */
      __IOM uint32_t RSTIE      : 1;            /*!< [13..13] RSTIE                                                            */
      __IOM uint32_t DLYPRTIE   : 1;            /*!< [14..14] DLYPRTIE                                                         */
            uint32_t            : 1;
      __IOM uint32_t CMP1DE     : 1;            /*!< [16..16] CMP1DE                                                           */
      __IOM uint32_t CMP2DE     : 1;            /*!< [17..17] CMP2DE                                                           */
      __IOM uint32_t CMP3DE     : 1;            /*!< [18..18] CMP3DE                                                           */
      __IOM uint32_t CMP4DE     : 1;            /*!< [19..19] CMP4DE                                                           */
      __IOM uint32_t REPDE      : 1;            /*!< [20..20] REPDE                                                            */
            uint32_t            : 1;
      __IOM uint32_t UPDDE      : 1;            /*!< [22..22] UPDDE                                                            */
      __IOM uint32_t CPT1DE     : 1;            /*!< [23..23] CPT1DE                                                           */
      __IOM uint32_t CPT2DE     : 1;            /*!< [24..24] CPT2DE                                                           */
      __IOM uint32_t SET1xDE    : 1;            /*!< [25..25] SET1xDE                                                          */
      __IOM uint32_t RSTx1DE    : 1;            /*!< [26..26] RSTx1DE                                                          */
      __IOM uint32_t SETx2DE    : 1;            /*!< [27..27] SETx2DE                                                          */
      __IOM uint32_t RSTx2DE    : 1;            /*!< [28..28] RSTx2DE                                                          */
      __IOM uint32_t RSTDE      : 1;            /*!< [29..29] RSTDE                                                            */
      __IOM uint32_t DLYPRTDE   : 1;            /*!< [30..30] DLYPRTDE                                                         */
            uint32_t            : 1;
    } TIMEDIER5_b;
  } ;
  
  union {
    __IOM uint32_t CNTER;                       /*!< (@ 0x00000010) Timerx Counter Register                                    */
    
    struct {
      __IOM uint32_t CNTx       : 16;           /*!< [15..0] Timerx Counter value                                              */
            uint32_t            : 16;
    } CNTER_b;
  } ;
  
  union {
    __IOM uint32_t PERER;                       /*!< (@ 0x00000014) Timerx Period Register                                     */
    
    struct {
      __IOM uint32_t PERx       : 16;           /*!< [15..0] Timerx Period value                                               */
            uint32_t            : 16;
    } PERER_b;
  } ;
  
  union {
    __IOM uint32_t REPER;                       /*!< (@ 0x00000018) Timerx Repetition Register                                 */
    
    struct {
      __IOM uint32_t REPx       : 8;            /*!< [7..0] Timerx Repetition counter value                                    */
            uint32_t            : 24;
    } REPER_b;
  } ;
  
  union {
    __IOM uint32_t CMP1ER;                      /*!< (@ 0x0000001C) Timerx Compare 1 Register                                  */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
            uint32_t            : 16;
    } CMP1ER_b;
  } ;
  
  union {
    __IOM uint32_t CMP1CER;                     /*!< (@ 0x00000020) Timerx Compare 1 Compound Register                         */
    
    struct {
      __IOM uint32_t CMP1x      : 16;           /*!< [15..0] Timerx Compare 1 value                                            */
      __IOM uint32_t REPx       : 8;            /*!< [23..16] Timerx Repetition value (aliased from HRTIM_REPx register)       */
            uint32_t            : 8;
    } CMP1CER_b;
  } ;
  
  union {
    __IOM uint32_t CMP2ER;                      /*!< (@ 0x00000024) Timerx Compare 2 Register                                  */
    
    struct {
      __IOM uint32_t CMP2x      : 16;           /*!< [15..0] Timerx Compare 2 value                                            */
            uint32_t            : 16;
    } CMP2ER_b;
  } ;
  
  union {
    __IOM uint32_t CMP3ER;                      /*!< (@ 0x00000028) Timerx Compare 3 Register                                  */
    
    struct {
      __IOM uint32_t CMP3x      : 16;           /*!< [15..0] Timerx Compare 3 value                                            */
            uint32_t            : 16;
    } CMP3ER_b;
  } ;
  
  union {
    __IOM uint32_t CMP4ER;                      /*!< (@ 0x0000002C) Timerx Compare 4 Register                                  */
    
    struct {
      __IOM uint32_t CMP4x      : 16;           /*!< [15..0] Timerx Compare 4 value                                            */
            uint32_t            : 16;
    } CMP4ER_b;
  } ;
  
  union {
    __IM  uint32_t CPT1ER;                      /*!< (@ 0x00000030) Timerx Capture 1 Register                                  */
    
    struct {
      __IM  uint32_t CPT1x      : 16;           /*!< [15..0] Timerx Capture 1 value                                            */
            uint32_t            : 16;
    } CPT1ER_b;
  } ;
  
  union {
    __IM  uint32_t CPT2ER;                      /*!< (@ 0x00000034) Timerx Capture 2 Register                                  */
    
    struct {
      __IM  uint32_t CPT2x      : 16;           /*!< [15..0] Timerx Capture 2 value                                            */
            uint32_t            : 16;
    } CPT2ER_b;
  } ;
  
  union {
    __IOM uint32_t DTER;                        /*!< (@ 0x00000038) Timerx Deadtime Register                                   */
    
    struct {
      __IOM uint32_t DTRx       : 9;            /*!< [8..0] Deadtime Rising value                                              */
      __IOM uint32_t SDTRx      : 1;            /*!< [9..9] Sign Deadtime Rising value                                         */
      __IOM uint32_t DTPRSC     : 3;            /*!< [12..10] Deadtime Prescaler                                               */
            uint32_t            : 1;
      __IOM uint32_t DTRSLKx    : 1;            /*!< [14..14] Deadtime Rising Sign Lock                                        */
      __IOM uint32_t DTRLKx     : 1;            /*!< [15..15] Deadtime Rising Lock                                             */
      __IOM uint32_t DTFx       : 9;            /*!< [24..16] Deadtime Falling value                                           */
      __IOM uint32_t SDTFx      : 1;            /*!< [25..25] Sign Deadtime Falling value                                      */
            uint32_t            : 4;
      __IOM uint32_t DTFSLKx    : 1;            /*!< [30..30] Deadtime Falling Sign Lock                                       */
      __IOM uint32_t DTFLKx     : 1;            /*!< [31..31] Deadtime Falling Lock                                            */
    } DTER_b;
  } ;
  
  union {
    __IOM uint32_t SETE1R;                      /*!< (@ 0x0000003C) Timerx Output1 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] Software Set trigger                                               */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] Timer A resynchronizaton                                           */
      __IOM uint32_t PER        : 1;            /*!< [2..2] Timer A Period                                                     */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] Timer A compare 1                                                  */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] Timer A compare 2                                                  */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] Timer A compare 3                                                  */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] Timer A compare 4                                                  */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] Master Period                                                      */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] Master Compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] Master Compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] Master Compare 3                                                 */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] Master Compare 4                                                 */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] Timer Event 1                                                    */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] Timer Event 2                                                    */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] Timer Event 3                                                    */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] Timer Event 4                                                    */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] Timer Event 5                                                    */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] Timer Event 6                                                    */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] Timer Event 7                                                    */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] Timer Event 8                                                    */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] Timer Event 9                                                    */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] External Event 1                                                 */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] External Event 10                                                */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] Registers update (transfer preload to active)                    */
    } SETE1R_b;
  } ;
  
  union {
    __IOM uint32_t RSTE1R;                      /*!< (@ 0x00000040) Timerx Output1 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTE1R_b;
  } ;
  
  union {
    __IOM uint32_t SETE2R;                      /*!< (@ 0x00000044) Timerx Output2 Set Register                                */
    
    struct {
      __IOM uint32_t SST        : 1;            /*!< [0..0] SST                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } SETE2R_b;
  } ;
  
  union {
    __IOM uint32_t RSTE2R;                      /*!< (@ 0x00000048) Timerx Output2 Reset Register                              */
    
    struct {
      __IOM uint32_t SRT        : 1;            /*!< [0..0] SRT                                                                */
      __IOM uint32_t RESYNC     : 1;            /*!< [1..1] RESYNC                                                             */
      __IOM uint32_t PER        : 1;            /*!< [2..2] PER                                                                */
      __IOM uint32_t CMP1       : 1;            /*!< [3..3] CMP1                                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [4..4] CMP2                                                               */
      __IOM uint32_t CMP3       : 1;            /*!< [5..5] CMP3                                                               */
      __IOM uint32_t CMP4       : 1;            /*!< [6..6] CMP4                                                               */
      __IOM uint32_t MSTPER     : 1;            /*!< [7..7] MSTPER                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [8..8] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [9..9] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [10..10] MSTCMP3                                                          */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [11..11] MSTCMP4                                                          */
      __IOM uint32_t TIMEVNT1   : 1;            /*!< [12..12] TIMEVNT1                                                         */
      __IOM uint32_t TIMEVNT2   : 1;            /*!< [13..13] TIMEVNT2                                                         */
      __IOM uint32_t TIMEVNT3   : 1;            /*!< [14..14] TIMEVNT3                                                         */
      __IOM uint32_t TIMEVNT4   : 1;            /*!< [15..15] TIMEVNT4                                                         */
      __IOM uint32_t TIMEVNT5   : 1;            /*!< [16..16] TIMEVNT5                                                         */
      __IOM uint32_t TIMEVNT6   : 1;            /*!< [17..17] TIMEVNT6                                                         */
      __IOM uint32_t TIMEVNT7   : 1;            /*!< [18..18] TIMEVNT7                                                         */
      __IOM uint32_t TIMEVNT8   : 1;            /*!< [19..19] TIMEVNT8                                                         */
      __IOM uint32_t TIMEVNT9   : 1;            /*!< [20..20] TIMEVNT9                                                         */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [21..21] EXTEVNT1                                                         */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [22..22] EXTEVNT2                                                         */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [23..23] EXTEVNT3                                                         */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [24..24] EXTEVNT4                                                         */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [25..25] EXTEVNT5                                                         */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [26..26] EXTEVNT6                                                         */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [27..27] EXTEVNT7                                                         */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [28..28] EXTEVNT8                                                         */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [29..29] EXTEVNT9                                                         */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [30..30] EXTEVNT10                                                        */
      __IOM uint32_t UPDATE     : 1;            /*!< [31..31] UPDATE                                                           */
    } RSTE2R_b;
  } ;
  
  union {
    __IOM uint32_t EEFER1;                      /*!< (@ 0x0000004C) Timerx External Event Filtering Register 1                 */
    
    struct {
      __IOM uint32_t EE1LTCH    : 1;            /*!< [0..0] External Event 1 latch                                             */
      __IOM uint32_t EE1FLTR    : 4;            /*!< [4..1] External Event 1 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE2LTCH    : 1;            /*!< [6..6] External Event 2 latch                                             */
      __IOM uint32_t EE2FLTR    : 4;            /*!< [10..7] External Event 2 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE3LTCH    : 1;            /*!< [12..12] External Event 3 latch                                           */
      __IOM uint32_t EE3FLTR    : 4;            /*!< [16..13] External Event 3 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE4LTCH    : 1;            /*!< [18..18] External Event 4 latch                                           */
      __IOM uint32_t EE4FLTR    : 4;            /*!< [22..19] External Event 4 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE5LTCH    : 1;            /*!< [24..24] External Event 5 latch                                           */
      __IOM uint32_t EE5FLTR    : 4;            /*!< [28..25] External Event 5 filter                                          */
            uint32_t            : 3;
    } EEFER1_b;
  } ;
  
  union {
    __IOM uint32_t EEFER2;                      /*!< (@ 0x00000050) Timerx External Event Filtering Register 2                 */
    
    struct {
      __IOM uint32_t EE6LTCH    : 1;            /*!< [0..0] External Event 6 latch                                             */
      __IOM uint32_t EE6FLTR    : 4;            /*!< [4..1] External Event 6 filter                                            */
            uint32_t            : 1;
      __IOM uint32_t EE7LTCH    : 1;            /*!< [6..6] External Event 7 latch                                             */
      __IOM uint32_t EE7FLTR    : 4;            /*!< [10..7] External Event 7 filter                                           */
            uint32_t            : 1;
      __IOM uint32_t EE8LTCH    : 1;            /*!< [12..12] External Event 8 latch                                           */
      __IOM uint32_t EE8FLTR    : 4;            /*!< [16..13] External Event 8 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE9LTCH    : 1;            /*!< [18..18] External Event 9 latch                                           */
      __IOM uint32_t EE9FLTR    : 4;            /*!< [22..19] External Event 9 filter                                          */
            uint32_t            : 1;
      __IOM uint32_t EE10LTCH   : 1;            /*!< [24..24] External Event 10 latch                                          */
      __IOM uint32_t EE10FLTR   : 4;            /*!< [28..25] External Event 10 filter                                         */
            uint32_t            : 3;
    } EEFER2_b;
  } ;
  
  union {
    __IOM uint32_t RSTER;                       /*!< (@ 0x00000054) TimerA Reset Register                                      */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t UPDT       : 1;            /*!< [1..1] Timer A Update reset                                               */
      __IOM uint32_t CMP2       : 1;            /*!< [2..2] Timer A compare 2 reset                                            */
      __IOM uint32_t CMP4       : 1;            /*!< [3..3] Timer A compare 4 reset                                            */
      __IOM uint32_t MSTPER     : 1;            /*!< [4..4] Master timer Period                                                */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [5..5] Master compare 1                                                   */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [6..6] Master compare 2                                                   */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [7..7] Master compare 3                                                   */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [8..8] Master compare 4                                                   */
      __IOM uint32_t EXTEVNT1   : 1;            /*!< [9..9] External Event 1                                                   */
      __IOM uint32_t EXTEVNT2   : 1;            /*!< [10..10] External Event 2                                                 */
      __IOM uint32_t EXTEVNT3   : 1;            /*!< [11..11] External Event 3                                                 */
      __IOM uint32_t EXTEVNT4   : 1;            /*!< [12..12] External Event 4                                                 */
      __IOM uint32_t EXTEVNT5   : 1;            /*!< [13..13] External Event 5                                                 */
      __IOM uint32_t EXTEVNT6   : 1;            /*!< [14..14] External Event 6                                                 */
      __IOM uint32_t EXTEVNT7   : 1;            /*!< [15..15] External Event 7                                                 */
      __IOM uint32_t EXTEVNT8   : 1;            /*!< [16..16] External Event 8                                                 */
      __IOM uint32_t EXTEVNT9   : 1;            /*!< [17..17] External Event 9                                                 */
      __IOM uint32_t EXTEVNT10  : 1;            /*!< [18..18] External Event 10                                                */
      __IOM uint32_t TIMACMP1   : 1;            /*!< [19..19] Timer A Compare 1                                                */
      __IOM uint32_t TIMACMP2   : 1;            /*!< [20..20] Timer A Compare 2                                                */
      __IOM uint32_t TIMACMP4   : 1;            /*!< [21..21] Timer A Compare 4                                                */
      __IOM uint32_t TIMBCMP1   : 1;            /*!< [22..22] Timer B Compare 1                                                */
      __IOM uint32_t TIMBCMP2   : 1;            /*!< [23..23] Timer B Compare 2                                                */
      __IOM uint32_t TIMBCMP4   : 1;            /*!< [24..24] Timer B Compare 4                                                */
      __IOM uint32_t TIMCCMP1   : 1;            /*!< [25..25] Timer C Compare 1                                                */
      __IOM uint32_t TIMCCMP2   : 1;            /*!< [26..26] Timer C Compare 2                                                */
      __IOM uint32_t TIMCCMP4   : 1;            /*!< [27..27] Timer C Compare 4                                                */
      __IOM uint32_t TIMDCMP1   : 1;            /*!< [28..28] Timer D Compare 1                                                */
      __IOM uint32_t TIMDCMP2   : 1;            /*!< [29..29] Timer D Compare 2                                                */
      __IOM uint32_t TIMDCMP4   : 1;            /*!< [30..30] Timer D Compare 4                                                */
            uint32_t            : 1;
    } RSTER_b;
  } ;
  
  union {
    __IOM uint32_t CHPER;                       /*!< (@ 0x00000058) Timerx Chopper Register                                    */
    
    struct {
      __IOM uint32_t CHPFRQ     : 4;            /*!< [3..0] Timerx carrier frequency value                                     */
      __IOM uint32_t CHPDTY     : 3;            /*!< [6..4] Timerx chopper duty cycle value                                    */
      __IOM uint32_t STRTPW     : 4;            /*!< [10..7] STRTPW                                                            */
            uint32_t            : 21;
    } CHPER_b;
  } ;
  
  union {
    __IOM uint32_t CPT1ECR;                     /*!< (@ 0x0000005C) Timerx Capture 2 Control Register                          */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
            uint32_t            : 4;
    } CPT1ECR_b;
  } ;
  
  union {
    __IOM uint32_t CPT2ECR;                     /*!< (@ 0x00000060) CPT2xCR                                                    */
    
    struct {
      __IOM uint32_t SWCPT      : 1;            /*!< [0..0] Software Capture                                                   */
      __IOM uint32_t UDPCPT     : 1;            /*!< [1..1] Update Capture                                                     */
      __IOM uint32_t EXEV1CPT   : 1;            /*!< [2..2] External Event 1 Capture                                           */
      __IOM uint32_t EXEV2CPT   : 1;            /*!< [3..3] External Event 2 Capture                                           */
      __IOM uint32_t EXEV3CPT   : 1;            /*!< [4..4] External Event 3 Capture                                           */
      __IOM uint32_t EXEV4CPT   : 1;            /*!< [5..5] External Event 4 Capture                                           */
      __IOM uint32_t EXEV5CPT   : 1;            /*!< [6..6] External Event 5 Capture                                           */
      __IOM uint32_t EXEV6CPT   : 1;            /*!< [7..7] External Event 6 Capture                                           */
      __IOM uint32_t EXEV7CPT   : 1;            /*!< [8..8] External Event 7 Capture                                           */
      __IOM uint32_t EXEV8CPT   : 1;            /*!< [9..9] External Event 8 Capture                                           */
      __IOM uint32_t EXEV9CPT   : 1;            /*!< [10..10] External Event 9 Capture                                         */
      __IOM uint32_t EXEV10CPT  : 1;            /*!< [11..11] External Event 10 Capture                                        */
      __IOM uint32_t TA1SET     : 1;            /*!< [12..12] Timer A output 1 Set                                             */
      __IOM uint32_t TA1RST     : 1;            /*!< [13..13] Timer A output 1 Reset                                           */
      __IOM uint32_t TACMP1     : 1;            /*!< [14..14] Timer A Compare 1                                                */
      __IOM uint32_t TACMP2     : 1;            /*!< [15..15] Timer A Compare 2                                                */
      __IOM uint32_t TB1SET     : 1;            /*!< [16..16] Timer B output 1 Set                                             */
      __IOM uint32_t TB1RST     : 1;            /*!< [17..17] Timer B output 1 Reset                                           */
      __IOM uint32_t TBCMP1     : 1;            /*!< [18..18] Timer B Compare 1                                                */
      __IOM uint32_t TBCMP2     : 1;            /*!< [19..19] Timer B Compare 2                                                */
      __IOM uint32_t TC1SET     : 1;            /*!< [20..20] Timer C output 1 Set                                             */
      __IOM uint32_t TC1RST     : 1;            /*!< [21..21] Timer C output 1 Reset                                           */
      __IOM uint32_t TCCMP1     : 1;            /*!< [22..22] Timer C Compare 1                                                */
      __IOM uint32_t TCCMP2     : 1;            /*!< [23..23] Timer C Compare 2                                                */
      __IOM uint32_t TD1SET     : 1;            /*!< [24..24] Timer D output 1 Set                                             */
      __IOM uint32_t TD1RST     : 1;            /*!< [25..25] Timer D output 1 Reset                                           */
      __IOM uint32_t TDCMP1     : 1;            /*!< [26..26] Timer D Compare 1                                                */
      __IOM uint32_t TDCMP2     : 1;            /*!< [27..27] Timer D Compare 2                                                */
            uint32_t            : 4;
    } CPT2ECR_b;
  } ;
  
  union {
    __IOM uint32_t OUTER;                       /*!< (@ 0x00000064) Timerx Output Register                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Output 1 polarity                                                  */
      __IOM uint32_t IDLEM1     : 1;            /*!< [2..2] Output 1 Idle mode                                                 */
      __IOM uint32_t IDLES1     : 1;            /*!< [3..3] Output 1 Idle State                                                */
      __IOM uint32_t FAULT1     : 2;            /*!< [5..4] Output 1 Fault state                                               */
      __IOM uint32_t CHP1       : 1;            /*!< [6..6] Output 1 Chopper enable                                            */
      __IOM uint32_t DIDL1      : 1;            /*!< [7..7] Output 1 Deadtime upon burst mode Idle entry                       */
      __IOM uint32_t DTEN       : 1;            /*!< [8..8] Deadtime enable                                                    */
      __IOM uint32_t DLYPRTEN   : 1;            /*!< [9..9] Delayed Protection Enable                                          */
      __IOM uint32_t DLYPRT     : 3;            /*!< [12..10] Delayed Protection                                               */
            uint32_t            : 4;
      __IOM uint32_t POL2       : 1;            /*!< [17..17] Output 2 polarity                                                */
      __IOM uint32_t IDLEM2     : 1;            /*!< [18..18] Output 2 Idle mode                                               */
      __IOM uint32_t IDLES2     : 1;            /*!< [19..19] Output 2 Idle State                                              */
      __IOM uint32_t FAULT2     : 2;            /*!< [21..20] Output 2 Fault state                                             */
      __IOM uint32_t CHP2       : 1;            /*!< [22..22] Output 2 Chopper enable                                          */
      __IOM uint32_t DIDL2      : 1;            /*!< [23..23] Output 2 Deadtime upon burst mode Idle entry                     */
            uint32_t            : 8;
    } OUTER_b;
  } ;
  
  union {
    __IOM uint32_t FLTER;                       /*!< (@ 0x00000068) Timerx Fault Register                                      */
    
    struct {
      __IOM uint32_t FLT1EN     : 1;            /*!< [0..0] Fault 1 enable                                                     */
      __IOM uint32_t FLT2EN     : 1;            /*!< [1..1] Fault 2 enable                                                     */
      __IOM uint32_t FLT3EN     : 1;            /*!< [2..2] Fault 3 enable                                                     */
      __IOM uint32_t FLT4EN     : 1;            /*!< [3..3] Fault 4 enable                                                     */
      __IOM uint32_t FLT5EN     : 1;            /*!< [4..4] Fault 5 enable                                                     */
            uint32_t            : 26;
      __IOM uint32_t FLTLCK     : 1;            /*!< [31..31] Fault sources Lock                                               */
    } FLTER_b;
  } ;
} HRTIM_TIME_Type;                              /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                       HRTIM_Common                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief High Resolution Timer: Common
      functions (HRTIM_Common)
  */

typedef struct {                                /*!< (@ 0x40017780) HRTIM_Common Structure                                     */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) Control Register 1                                         */
    
    struct {
      __IOM uint32_t MUDIS      : 1;            /*!< [0..0] Master Update Disable                                              */
      __IOM uint32_t TAUDIS     : 1;            /*!< [1..1] Timer A Update Disable                                             */
      __IOM uint32_t TBUDIS     : 1;            /*!< [2..2] Timer B Update Disable                                             */
      __IOM uint32_t TCUDIS     : 1;            /*!< [3..3] Timer C Update Disable                                             */
      __IOM uint32_t TDUDIS     : 1;            /*!< [4..4] Timer D Update Disable                                             */
      __IOM uint32_t TEUDIS     : 1;            /*!< [5..5] Timer E Update Disable                                             */
            uint32_t            : 10;
      __IOM uint32_t AD1USRC    : 3;            /*!< [18..16] ADC Trigger 1 Update Source                                      */
      __IOM uint32_t AD2USRC    : 3;            /*!< [21..19] ADC Trigger 2 Update Source                                      */
      __IOM uint32_t AD3USRC    : 3;            /*!< [24..22] ADC Trigger 3 Update Source                                      */
      __IOM uint32_t AD4USRC    : 3;            /*!< [27..25] ADC Trigger 4 Update Source                                      */
            uint32_t            : 4;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) Control Register 2                                         */
    
    struct {
      __IOM uint32_t MSWU       : 1;            /*!< [0..0] Master Timer Software update                                       */
      __IOM uint32_t TASWU      : 1;            /*!< [1..1] Timer A Software update                                            */
      __IOM uint32_t TBSWU      : 1;            /*!< [2..2] Timer B Software Update                                            */
      __IOM uint32_t TCSWU      : 1;            /*!< [3..3] Timer C Software Update                                            */
      __IOM uint32_t TDSWU      : 1;            /*!< [4..4] Timer D Software Update                                            */
      __IOM uint32_t TESWU      : 1;            /*!< [5..5] Timer E Software Update                                            */
            uint32_t            : 2;
      __IOM uint32_t MRST       : 1;            /*!< [8..8] Master Counter software reset                                      */
      __IOM uint32_t TARST      : 1;            /*!< [9..9] Timer A counter software reset                                     */
      __IOM uint32_t TBRST      : 1;            /*!< [10..10] Timer B counter software reset                                   */
      __IOM uint32_t TCRST      : 1;            /*!< [11..11] Timer C counter software reset                                   */
      __IOM uint32_t TDRST      : 1;            /*!< [12..12] Timer D counter software reset                                   */
      __IOM uint32_t TERST      : 1;            /*!< [13..13] Timer E counter software reset                                   */
            uint32_t            : 18;
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t ISR;                         /*!< (@ 0x00000008) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t FLT1       : 1;            /*!< [0..0] Fault 1 Interrupt Flag                                             */
      __IM  uint32_t FLT2       : 1;            /*!< [1..1] Fault 2 Interrupt Flag                                             */
      __IM  uint32_t FLT3       : 1;            /*!< [2..2] Fault 3 Interrupt Flag                                             */
      __IM  uint32_t FLT4       : 1;            /*!< [3..3] Fault 4 Interrupt Flag                                             */
      __IM  uint32_t FLT5       : 1;            /*!< [4..4] Fault 5 Interrupt Flag                                             */
      __IOM uint32_t SYSFLT     : 1;            /*!< [5..5] System Fault Interrupt Flag                                        */
            uint32_t            : 10;
      __IM  uint32_t DLLRDY     : 1;            /*!< [16..16] DLL Ready Interrupt Flag                                         */
      __IM  uint32_t BMPER      : 1;            /*!< [17..17] Burst mode Period Interrupt Flag                                 */
            uint32_t            : 14;
    } ISR_b;
  } ;
  
  union {
    __IOM uint32_t ICR;                         /*!< (@ 0x0000000C) Interrupt Clear Register                                   */
    
    struct {
      __OM  uint32_t FLT1C      : 1;            /*!< [0..0] Fault 1 Interrupt Flag Clear                                       */
      __OM  uint32_t FLT2C      : 1;            /*!< [1..1] Fault 2 Interrupt Flag Clear                                       */
      __OM  uint32_t FLT3C      : 1;            /*!< [2..2] Fault 3 Interrupt Flag Clear                                       */
      __OM  uint32_t FLT4C      : 1;            /*!< [3..3] Fault 4 Interrupt Flag Clear                                       */
      __OM  uint32_t FLT5C      : 1;            /*!< [4..4] Fault 5 Interrupt Flag Clear                                       */
      __IOM uint32_t SYSFLTC    : 1;            /*!< [5..5] System Fault Interrupt Flag Clear                                  */
            uint32_t            : 10;
      __OM  uint32_t DLLRDYC    : 1;            /*!< [16..16] DLL Ready Interrupt flag Clear                                   */
      __OM  uint32_t BMPERC     : 1;            /*!< [17..17] Burst mode period flag Clear                                     */
            uint32_t            : 14;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000010) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t FLT1IE     : 1;            /*!< [0..0] Fault 1 Interrupt Enable                                           */
      __IOM uint32_t FLT2IE     : 1;            /*!< [1..1] Fault 2 Interrupt Enable                                           */
      __IOM uint32_t FLT3IE     : 1;            /*!< [2..2] Fault 3 Interrupt Enable                                           */
      __IOM uint32_t FLT4IE     : 1;            /*!< [3..3] Fault 4 Interrupt Enable                                           */
      __IOM uint32_t FLT5IE     : 1;            /*!< [4..4] Fault 5 Interrupt Enable                                           */
      __IOM uint32_t SYSFLTE    : 1;            /*!< [5..5] System Fault Interrupt Enable                                      */
            uint32_t            : 10;
      __IOM uint32_t DLLRDYIE   : 1;            /*!< [16..16] DLL Ready Interrupt Enable                                       */
      __IOM uint32_t BMPERIE    : 1;            /*!< [17..17] Burst mode period Interrupt Enable                               */
            uint32_t            : 14;
    } IER_b;
  } ;
  
  union {
    __OM  uint32_t OENR;                        /*!< (@ 0x00000014) Output Enable Register                                     */
    
    struct {
      __OM  uint32_t TA1OEN     : 1;            /*!< [0..0] Timer A Output 1 Enable                                            */
      __OM  uint32_t TA2OEN     : 1;            /*!< [1..1] Timer A Output 2 Enable                                            */
      __OM  uint32_t TB1OEN     : 1;            /*!< [2..2] Timer B Output 1 Enable                                            */
      __OM  uint32_t TB2OEN     : 1;            /*!< [3..3] Timer B Output 2 Enable                                            */
      __OM  uint32_t TC1OEN     : 1;            /*!< [4..4] Timer C Output 1 Enable                                            */
      __OM  uint32_t TC2OEN     : 1;            /*!< [5..5] Timer C Output 2 Enable                                            */
      __OM  uint32_t TD1OEN     : 1;            /*!< [6..6] Timer D Output 1 Enable                                            */
      __OM  uint32_t TD2OEN     : 1;            /*!< [7..7] Timer D Output 2 Enable                                            */
      __OM  uint32_t TE1OEN     : 1;            /*!< [8..8] Timer E Output 1 Enable                                            */
      __OM  uint32_t TE2OEN     : 1;            /*!< [9..9] Timer E Output 2 Enable                                            */
            uint32_t            : 22;
    } OENR_b;
  } ;
  
  union {
    __IOM uint32_t DISR;                        /*!< (@ 0x00000018) DISR                                                       */
    
    struct {
      __IOM uint32_t TA1ODIS    : 1;            /*!< [0..0] TA1ODIS                                                            */
      __IOM uint32_t TA2ODIS    : 1;            /*!< [1..1] TA2ODIS                                                            */
      __IOM uint32_t TB1ODIS    : 1;            /*!< [2..2] TB1ODIS                                                            */
      __IOM uint32_t TB2ODIS    : 1;            /*!< [3..3] TB2ODIS                                                            */
      __IOM uint32_t TC1ODIS    : 1;            /*!< [4..4] TC1ODIS                                                            */
      __IOM uint32_t TC2ODIS    : 1;            /*!< [5..5] TC2ODIS                                                            */
      __IOM uint32_t TD1ODIS    : 1;            /*!< [6..6] TD1ODIS                                                            */
      __IOM uint32_t TD2ODIS    : 1;            /*!< [7..7] TD2ODIS                                                            */
      __IOM uint32_t TE1ODIS    : 1;            /*!< [8..8] TE1ODIS                                                            */
      __IOM uint32_t TE2ODIS    : 1;            /*!< [9..9] TE2ODIS                                                            */
            uint32_t            : 22;
    } DISR_b;
  } ;
  
  union {
    __IM  uint32_t ODSR;                        /*!< (@ 0x0000001C) Output Disable Status Register                             */
    
    struct {
      __IM  uint32_t TA1ODS     : 1;            /*!< [0..0] Timer A Output 1 disable status                                    */
      __IM  uint32_t TA2ODS     : 1;            /*!< [1..1] Timer A Output 2 disable status                                    */
      __IM  uint32_t TB1ODS     : 1;            /*!< [2..2] Timer B Output 1 disable status                                    */
      __IM  uint32_t TB2ODS     : 1;            /*!< [3..3] Timer B Output 2 disable status                                    */
      __IM  uint32_t TC1ODS     : 1;            /*!< [4..4] Timer C Output 1 disable status                                    */
      __IM  uint32_t TC2ODS     : 1;            /*!< [5..5] Timer C Output 2 disable status                                    */
      __IM  uint32_t TD1ODS     : 1;            /*!< [6..6] Timer D Output 1 disable status                                    */
      __IM  uint32_t TD2ODS     : 1;            /*!< [7..7] Timer D Output 2 disable status                                    */
      __IM  uint32_t TE1ODS     : 1;            /*!< [8..8] Timer E Output 1 disable status                                    */
      __IM  uint32_t TE2ODS     : 1;            /*!< [9..9] Timer E Output 2 disable status                                    */
            uint32_t            : 22;
    } ODSR_b;
  } ;
  
  union {
    __IOM uint32_t BMCR;                        /*!< (@ 0x00000020) Burst Mode Control Register                                */
    
    struct {
      __IOM uint32_t BME        : 1;            /*!< [0..0] Burst Mode enable                                                  */
      __IOM uint32_t BMOM       : 1;            /*!< [1..1] Burst Mode operating mode                                          */
      __IOM uint32_t BMCLK      : 4;            /*!< [5..2] Burst Mode Clock source                                            */
      __IOM uint32_t BMPRSC     : 4;            /*!< [9..6] Burst Mode Prescaler                                               */
      __IOM uint32_t BMPREN     : 1;            /*!< [10..10] Burst Mode Preload Enable                                        */
            uint32_t            : 5;
      __IOM uint32_t MTBM       : 1;            /*!< [16..16] Master Timer Burst Mode                                          */
      __IOM uint32_t TABM       : 1;            /*!< [17..17] Timer A Burst Mode                                               */
      __IOM uint32_t TBBM       : 1;            /*!< [18..18] Timer B Burst Mode                                               */
      __IOM uint32_t TCBM       : 1;            /*!< [19..19] Timer C Burst Mode                                               */
      __IOM uint32_t TDBM       : 1;            /*!< [20..20] Timer D Burst Mode                                               */
      __IOM uint32_t TEBM       : 1;            /*!< [21..21] Timer E Burst Mode                                               */
            uint32_t            : 9;
      __IOM uint32_t BMSTAT     : 1;            /*!< [31..31] Burst Mode Status                                                */
    } BMCR_b;
  } ;
  
  union {
    __IOM uint32_t BMTRG;                       /*!< (@ 0x00000024) BMTRG                                                      */
    
    struct {
      __IOM uint32_t SW         : 1;            /*!< [0..0] SW                                                                 */
      __IOM uint32_t MSTRST     : 1;            /*!< [1..1] MSTRST                                                             */
      __IOM uint32_t MSTREP     : 1;            /*!< [2..2] MSTREP                                                             */
      __IOM uint32_t MSTCMP1    : 1;            /*!< [3..3] MSTCMP1                                                            */
      __IOM uint32_t MSTCMP2    : 1;            /*!< [4..4] MSTCMP2                                                            */
      __IOM uint32_t MSTCMP3    : 1;            /*!< [5..5] MSTCMP3                                                            */
      __IOM uint32_t MSTCMP4    : 1;            /*!< [6..6] MSTCMP4                                                            */
      __IOM uint32_t TARST      : 1;            /*!< [7..7] TARST                                                              */
      __IOM uint32_t TAREP      : 1;            /*!< [8..8] TAREP                                                              */
      __IOM uint32_t TACMP1     : 1;            /*!< [9..9] TACMP1                                                             */
      __IOM uint32_t TACMP2     : 1;            /*!< [10..10] TACMP2                                                           */
      __IOM uint32_t TBRST      : 1;            /*!< [11..11] TBRST                                                            */
      __IOM uint32_t TBREP      : 1;            /*!< [12..12] TBREP                                                            */
      __IOM uint32_t TBCMP1     : 1;            /*!< [13..13] TBCMP1                                                           */
      __IOM uint32_t TBCMP2     : 1;            /*!< [14..14] TBCMP2                                                           */
      __IOM uint32_t TCRST      : 1;            /*!< [15..15] TCRST                                                            */
      __IOM uint32_t TCREP      : 1;            /*!< [16..16] TCREP                                                            */
      __IOM uint32_t TCCMP1     : 1;            /*!< [17..17] TCCMP1                                                           */
      __IOM uint32_t TCCMP2     : 1;            /*!< [18..18] TCCMP2                                                           */
      __IOM uint32_t TDRST      : 1;            /*!< [19..19] TDRST                                                            */
      __IOM uint32_t TDREP      : 1;            /*!< [20..20] TDREP                                                            */
      __IOM uint32_t TDCMP1     : 1;            /*!< [21..21] TDCMP1                                                           */
      __IOM uint32_t TDCMP2     : 1;            /*!< [22..22] TDCMP2                                                           */
      __IOM uint32_t TERST      : 1;            /*!< [23..23] TERST                                                            */
      __IOM uint32_t TEREP      : 1;            /*!< [24..24] TEREP                                                            */
      __IOM uint32_t TECMP1     : 1;            /*!< [25..25] TECMP1                                                           */
      __IOM uint32_t TECMP2     : 1;            /*!< [26..26] TECMP2                                                           */
            uint32_t            : 4;
      __IOM uint32_t OCHPEV     : 1;            /*!< [31..31] OCHPEV                                                           */
    } BMTRG_b;
  } ;
  
  union {
    __IOM uint32_t BMCMPR6;                     /*!< (@ 0x00000028) BMCMPR6                                                    */
    
    struct {
      __IOM uint32_t BMCMP      : 16;           /*!< [15..0] BMCMP                                                             */
            uint32_t            : 16;
    } BMCMPR6_b;
  } ;
  
  union {
    __IOM uint32_t BMPER;                       /*!< (@ 0x0000002C) Burst Mode Period Register                                 */
    
    struct {
      __IOM uint32_t BMPER      : 16;           /*!< [15..0] Burst mode Period                                                 */
            uint32_t            : 16;
    } BMPER_b;
  } ;
  
  union {
    __IOM uint32_t EECR1;                       /*!< (@ 0x00000030) Timer External Event Control Register 1                    */
    
    struct {
      __IOM uint32_t EE1SRC     : 2;            /*!< [1..0] External Event 1 Source                                            */
      __IOM uint32_t EE1POL     : 1;            /*!< [2..2] External Event 1 Polarity                                          */
      __IOM uint32_t EE1SNS     : 2;            /*!< [4..3] External Event 1 Sensitivity                                       */
      __IOM uint32_t EE1FAST    : 1;            /*!< [5..5] External Event 1 Fast mode                                         */
      __IOM uint32_t EE2SRC     : 2;            /*!< [7..6] External Event 2 Source                                            */
      __IOM uint32_t EE2POL     : 1;            /*!< [8..8] External Event 2 Polarity                                          */
      __IOM uint32_t EE2SNS     : 2;            /*!< [10..9] External Event 2 Sensitivity                                      */
      __IOM uint32_t EE2FAST    : 1;            /*!< [11..11] External Event 2 Fast mode                                       */
      __IOM uint32_t EE3SRC     : 2;            /*!< [13..12] External Event 3 Source                                          */
      __IOM uint32_t EE3POL     : 1;            /*!< [14..14] External Event 3 Polarity                                        */
      __IOM uint32_t EE3SNS     : 2;            /*!< [16..15] External Event 3 Sensitivity                                     */
      __IOM uint32_t EE3FAST    : 1;            /*!< [17..17] External Event 3 Fast mode                                       */
      __IOM uint32_t EE4SRC     : 2;            /*!< [19..18] External Event 4 Source                                          */
      __IOM uint32_t EE4POL     : 1;            /*!< [20..20] External Event 4 Polarity                                        */
      __IOM uint32_t EE4SNS     : 2;            /*!< [22..21] External Event 4 Sensitivity                                     */
      __IOM uint32_t EE4FAST    : 1;            /*!< [23..23] External Event 4 Fast mode                                       */
      __IOM uint32_t EE5SRC     : 2;            /*!< [25..24] External Event 5 Source                                          */
      __IOM uint32_t EE5POL     : 1;            /*!< [26..26] External Event 5 Polarity                                        */
      __IOM uint32_t EE5SNS     : 2;            /*!< [28..27] External Event 5 Sensitivity                                     */
      __IOM uint32_t EE5FAST    : 1;            /*!< [29..29] External Event 5 Fast mode                                       */
            uint32_t            : 2;
    } EECR1_b;
  } ;
  
  union {
    __IOM uint32_t EECR2;                       /*!< (@ 0x00000034) Timer External Event Control Register 2                    */
    
    struct {
      __IOM uint32_t EE6SRC     : 2;            /*!< [1..0] External Event 6 Source                                            */
      __IOM uint32_t EE6POL     : 1;            /*!< [2..2] External Event 6 Polarity                                          */
      __IOM uint32_t EE6SNS     : 2;            /*!< [4..3] External Event 6 Sensitivity                                       */
            uint32_t            : 1;
      __IOM uint32_t EE7SRC     : 2;            /*!< [7..6] External Event 7 Source                                            */
      __IOM uint32_t EE7POL     : 1;            /*!< [8..8] External Event 7 Polarity                                          */
      __IOM uint32_t EE7SNS     : 2;            /*!< [10..9] External Event 7 Sensitivity                                      */
            uint32_t            : 1;
      __IOM uint32_t EE8SRC     : 2;            /*!< [13..12] External Event 8 Source                                          */
      __IOM uint32_t EE8POL     : 1;            /*!< [14..14] External Event 8 Polarity                                        */
      __IOM uint32_t EE8SNS     : 2;            /*!< [16..15] External Event 8 Sensitivity                                     */
            uint32_t            : 1;
      __IOM uint32_t EE9SRC     : 2;            /*!< [19..18] External Event 9 Source                                          */
      __IOM uint32_t EE9POL     : 1;            /*!< [20..20] External Event 9 Polarity                                        */
      __IOM uint32_t EE9SNS     : 2;            /*!< [22..21] External Event 9 Sensitivity                                     */
            uint32_t            : 1;
      __IOM uint32_t EE10SRC    : 2;            /*!< [25..24] External Event 10 Source                                         */
      __IOM uint32_t EE10POL    : 1;            /*!< [26..26] External Event 10 Polarity                                       */
      __IOM uint32_t EE10SNS    : 2;            /*!< [28..27] External Event 10 Sensitivity                                    */
            uint32_t            : 3;
    } EECR2_b;
  } ;
  
  union {
    __IOM uint32_t EECR3;                       /*!< (@ 0x00000038) Timer External Event Control Register 3                    */
    
    struct {
      __IOM uint32_t EE6SRC     : 2;            /*!< [1..0] EE6SRC                                                             */
      __IOM uint32_t EE6POL     : 1;            /*!< [2..2] EE6POL                                                             */
      __IOM uint32_t EE6SNS     : 2;            /*!< [4..3] EE6SNS                                                             */
            uint32_t            : 1;
      __IOM uint32_t EE7SRC     : 2;            /*!< [7..6] EE7SRC                                                             */
      __IOM uint32_t EE7POL     : 1;            /*!< [8..8] EE7POL                                                             */
      __IOM uint32_t EE7SNS     : 2;            /*!< [10..9] EE7SNS                                                            */
            uint32_t            : 1;
      __IOM uint32_t EE8SRC     : 2;            /*!< [13..12] EE8SRC                                                           */
      __IOM uint32_t EE8POL     : 1;            /*!< [14..14] EE8POL                                                           */
      __IOM uint32_t EE8SNS     : 2;            /*!< [16..15] EE8SNS                                                           */
            uint32_t            : 1;
      __IOM uint32_t EE9SRC     : 2;            /*!< [19..18] EE9SRC                                                           */
      __IOM uint32_t EE9POL     : 1;            /*!< [20..20] EE9POL                                                           */
      __IOM uint32_t EE9SNS     : 2;            /*!< [22..21] EE9SNS                                                           */
            uint32_t            : 1;
      __IOM uint32_t EE10SRC    : 2;            /*!< [25..24] EE10SRC                                                          */
      __IOM uint32_t EE10POL    : 1;            /*!< [26..26] EE10POL                                                          */
      __IOM uint32_t EE10SNS    : 2;            /*!< [28..27] EE10SNS                                                          */
            uint32_t            : 3;
    } EECR3_b;
  } ;
  
  union {
    __IOM uint32_t ADC1R;                       /*!< (@ 0x0000003C) ADC Trigger 1 Register                                     */
    
    struct {
      __IOM uint32_t AD1MC1     : 1;            /*!< [0..0] ADC trigger 1 on Master Compare 1                                  */
      __IOM uint32_t AD1MC2     : 1;            /*!< [1..1] ADC trigger 1 on Master Compare 2                                  */
      __IOM uint32_t AD1MC3     : 1;            /*!< [2..2] ADC trigger 1 on Master Compare 3                                  */
      __IOM uint32_t AD1MC4     : 1;            /*!< [3..3] ADC trigger 1 on Master Compare 4                                  */
      __IOM uint32_t AD1MPER    : 1;            /*!< [4..4] ADC trigger 1 on Master Period                                     */
      __IOM uint32_t AD1EEV1    : 1;            /*!< [5..5] ADC trigger 1 on External Event 1                                  */
      __IOM uint32_t AD1EEV2    : 1;            /*!< [6..6] ADC trigger 1 on External Event 2                                  */
      __IOM uint32_t AD1EEV3    : 1;            /*!< [7..7] ADC trigger 1 on External Event 3                                  */
      __IOM uint32_t AD1EEV4    : 1;            /*!< [8..8] ADC trigger 1 on External Event 4                                  */
      __IOM uint32_t AD1EEV5    : 1;            /*!< [9..9] ADC trigger 1 on External Event 5                                  */
      __IOM uint32_t AD1TAC2    : 1;            /*!< [10..10] ADC trigger 1 on Timer A compare 2                               */
      __IOM uint32_t AD1TAC3    : 1;            /*!< [11..11] ADC trigger 1 on Timer A compare 3                               */
      __IOM uint32_t AD1TAC4    : 1;            /*!< [12..12] ADC trigger 1 on Timer A compare 4                               */
      __IOM uint32_t AD1TAPER   : 1;            /*!< [13..13] ADC trigger 1 on Timer A Period                                  */
      __IOM uint32_t AD1TARST   : 1;            /*!< [14..14] ADC trigger 1 on Timer A Reset                                   */
      __IOM uint32_t AD1TBC2    : 1;            /*!< [15..15] ADC trigger 1 on Timer B compare 2                               */
      __IOM uint32_t AD1TBC3    : 1;            /*!< [16..16] ADC trigger 1 on Timer B compare 3                               */
      __IOM uint32_t AD1TBC4    : 1;            /*!< [17..17] ADC trigger 1 on Timer B compare 4                               */
      __IOM uint32_t AD1TBPER   : 1;            /*!< [18..18] ADC trigger 1 on Timer B Period                                  */
      __IOM uint32_t AD1TBRST   : 1;            /*!< [19..19] ADC trigger 1 on Timer B Reset                                   */
      __IOM uint32_t AD1TCC2    : 1;            /*!< [20..20] ADC trigger 1 on Timer C compare 2                               */
      __IOM uint32_t AD1TCC3    : 1;            /*!< [21..21] ADC trigger 1 on Timer C compare 3                               */
      __IOM uint32_t AD1TCC4    : 1;            /*!< [22..22] ADC trigger 1 on Timer C compare 4                               */
      __IOM uint32_t AD1TCPER   : 1;            /*!< [23..23] ADC trigger 1 on Timer C Period                                  */
      __IOM uint32_t AD1TDC2    : 1;            /*!< [24..24] ADC trigger 1 on Timer D compare 2                               */
      __IOM uint32_t AD1TDC3    : 1;            /*!< [25..25] ADC trigger 1 on Timer D compare 3                               */
      __IOM uint32_t AD1TDC4    : 1;            /*!< [26..26] ADC trigger 1 on Timer D compare 4                               */
      __IOM uint32_t AD1TDPER   : 1;            /*!< [27..27] ADC trigger 1 on Timer D Period                                  */
      __IOM uint32_t AD1TEC2    : 1;            /*!< [28..28] ADC trigger 1 on Timer E compare 2                               */
      __IOM uint32_t AD1TEC3    : 1;            /*!< [29..29] ADC trigger 1 on Timer E compare 3                               */
      __IOM uint32_t AD1TEC4    : 1;            /*!< [30..30] ADC trigger 1 on Timer E compare 4                               */
      __IOM uint32_t AD1TEPER   : 1;            /*!< [31..31] ADC trigger 1 on Timer E Period                                  */
    } ADC1R_b;
  } ;
  
  union {
    __IOM uint32_t ADC2R;                       /*!< (@ 0x00000040) ADC Trigger 2 Register                                     */
    
    struct {
      __IOM uint32_t AD2MC1     : 1;            /*!< [0..0] ADC trigger 2 on Master Compare 1                                  */
      __IOM uint32_t AD2MC2     : 1;            /*!< [1..1] ADC trigger 2 on Master Compare 2                                  */
      __IOM uint32_t AD2MC3     : 1;            /*!< [2..2] ADC trigger 2 on Master Compare 3                                  */
      __IOM uint32_t AD2MC4     : 1;            /*!< [3..3] ADC trigger 2 on Master Compare 4                                  */
      __IOM uint32_t AD2MPER    : 1;            /*!< [4..4] ADC trigger 2 on Master Period                                     */
      __IOM uint32_t AD2EEV6    : 1;            /*!< [5..5] ADC trigger 2 on External Event 6                                  */
      __IOM uint32_t AD2EEV7    : 1;            /*!< [6..6] ADC trigger 2 on External Event 7                                  */
      __IOM uint32_t AD2EEV8    : 1;            /*!< [7..7] ADC trigger 2 on External Event 8                                  */
      __IOM uint32_t AD2EEV9    : 1;            /*!< [8..8] ADC trigger 2 on External Event 9                                  */
      __IOM uint32_t AD2EEV10   : 1;            /*!< [9..9] ADC trigger 2 on External Event 10                                 */
      __IOM uint32_t AD2TAC2    : 1;            /*!< [10..10] ADC trigger 2 on Timer A compare 2                               */
      __IOM uint32_t AD2TAC3    : 1;            /*!< [11..11] ADC trigger 2 on Timer A compare 3                               */
      __IOM uint32_t AD2TAC4    : 1;            /*!< [12..12] ADC trigger 2 on Timer A compare 4                               */
      __IOM uint32_t AD2TAPER   : 1;            /*!< [13..13] ADC trigger 2 on Timer A Period                                  */
      __IOM uint32_t AD2TBC2    : 1;            /*!< [14..14] ADC trigger 2 on Timer B compare 2                               */
      __IOM uint32_t AD2TBC3    : 1;            /*!< [15..15] ADC trigger 2 on Timer B compare 3                               */
      __IOM uint32_t AD2TBC4    : 1;            /*!< [16..16] ADC trigger 2 on Timer B compare 4                               */
      __IOM uint32_t AD2TBPER   : 1;            /*!< [17..17] ADC trigger 2 on Timer B Period                                  */
      __IOM uint32_t AD2TCC2    : 1;            /*!< [18..18] ADC trigger 2 on Timer C compare 2                               */
      __IOM uint32_t AD2TCC3    : 1;            /*!< [19..19] ADC trigger 2 on Timer C compare 3                               */
      __IOM uint32_t AD2TCC4    : 1;            /*!< [20..20] ADC trigger 2 on Timer C compare 4                               */
      __IOM uint32_t AD2TCPER   : 1;            /*!< [21..21] ADC trigger 2 on Timer C Period                                  */
      __IOM uint32_t AD2TCRST   : 1;            /*!< [22..22] ADC trigger 2 on Timer C Reset                                   */
      __IOM uint32_t AD2TDC2    : 1;            /*!< [23..23] ADC trigger 2 on Timer D compare 2                               */
      __IOM uint32_t AD2TDC3    : 1;            /*!< [24..24] ADC trigger 2 on Timer D compare 3                               */
      __IOM uint32_t AD2TDC4    : 1;            /*!< [25..25] ADC trigger 2 on Timer D compare 4                               */
      __IOM uint32_t AD2TDPER   : 1;            /*!< [26..26] ADC trigger 2 on Timer D Period                                  */
      __IOM uint32_t AD2TDRST   : 1;            /*!< [27..27] ADC trigger 2 on Timer D Reset                                   */
      __IOM uint32_t AD2TEC2    : 1;            /*!< [28..28] ADC trigger 2 on Timer E compare 2                               */
      __IOM uint32_t AD2TEC3    : 1;            /*!< [29..29] ADC trigger 2 on Timer E compare 3                               */
      __IOM uint32_t AD2TEC4    : 1;            /*!< [30..30] ADC trigger 2 on Timer E compare 4                               */
      __IOM uint32_t AD2TERST   : 1;            /*!< [31..31] ADC trigger 2 on Timer E Reset                                   */
    } ADC2R_b;
  } ;
  
  union {
    __IOM uint32_t ADC3R;                       /*!< (@ 0x00000044) ADC Trigger 3 Register                                     */
    
    struct {
      __IOM uint32_t AD1MC1     : 1;            /*!< [0..0] AD1MC1                                                             */
      __IOM uint32_t AD1MC2     : 1;            /*!< [1..1] AD1MC2                                                             */
      __IOM uint32_t AD1MC3     : 1;            /*!< [2..2] AD1MC3                                                             */
      __IOM uint32_t AD1MC4     : 1;            /*!< [3..3] AD1MC4                                                             */
      __IOM uint32_t AD1MPER    : 1;            /*!< [4..4] AD1MPER                                                            */
      __IOM uint32_t AD1EEV1    : 1;            /*!< [5..5] AD1EEV1                                                            */
      __IOM uint32_t AD1EEV2    : 1;            /*!< [6..6] AD1EEV2                                                            */
      __IOM uint32_t AD1EEV3    : 1;            /*!< [7..7] AD1EEV3                                                            */
      __IOM uint32_t AD1EEV4    : 1;            /*!< [8..8] AD1EEV4                                                            */
      __IOM uint32_t AD1EEV5    : 1;            /*!< [9..9] AD1EEV5                                                            */
      __IOM uint32_t AD1TAC2    : 1;            /*!< [10..10] AD1TAC2                                                          */
      __IOM uint32_t AD1TAC3    : 1;            /*!< [11..11] AD1TAC3                                                          */
      __IOM uint32_t AD1TAC4    : 1;            /*!< [12..12] AD1TAC4                                                          */
      __IOM uint32_t AD1TAPER   : 1;            /*!< [13..13] AD1TAPER                                                         */
      __IOM uint32_t AD1TARST   : 1;            /*!< [14..14] AD1TARST                                                         */
      __IOM uint32_t AD1TBC2    : 1;            /*!< [15..15] AD1TBC2                                                          */
      __IOM uint32_t AD1TBC3    : 1;            /*!< [16..16] AD1TBC3                                                          */
      __IOM uint32_t AD1TBC4    : 1;            /*!< [17..17] AD1TBC4                                                          */
      __IOM uint32_t AD1TBPER   : 1;            /*!< [18..18] AD1TBPER                                                         */
      __IOM uint32_t AD1TBRST   : 1;            /*!< [19..19] AD1TBRST                                                         */
      __IOM uint32_t AD1TCC2    : 1;            /*!< [20..20] AD1TCC2                                                          */
      __IOM uint32_t AD1TCC3    : 1;            /*!< [21..21] AD1TCC3                                                          */
      __IOM uint32_t AD1TCC4    : 1;            /*!< [22..22] AD1TCC4                                                          */
      __IOM uint32_t AD1TCPER   : 1;            /*!< [23..23] AD1TCPER                                                         */
      __IOM uint32_t AD1TDC2    : 1;            /*!< [24..24] AD1TDC2                                                          */
      __IOM uint32_t AD1TDC3    : 1;            /*!< [25..25] AD1TDC3                                                          */
      __IOM uint32_t AD1TDC4    : 1;            /*!< [26..26] AD1TDC4                                                          */
      __IOM uint32_t AD1TDPER   : 1;            /*!< [27..27] AD1TDPER                                                         */
      __IOM uint32_t AD1TEC2    : 1;            /*!< [28..28] AD1TEC2                                                          */
      __IOM uint32_t AD1TEC3    : 1;            /*!< [29..29] AD1TEC3                                                          */
      __IOM uint32_t AD1TEC4    : 1;            /*!< [30..30] AD1TEC4                                                          */
      __IOM uint32_t AD1TEPER   : 1;            /*!< [31..31] AD1TEPER                                                         */
    } ADC3R_b;
  } ;
  
  union {
    __IOM uint32_t ADC4R;                       /*!< (@ 0x00000048) ADC Trigger 4 Register                                     */
    
    struct {
      __IOM uint32_t AD2MC1     : 1;            /*!< [0..0] AD2MC1                                                             */
      __IOM uint32_t AD2MC2     : 1;            /*!< [1..1] AD2MC2                                                             */
      __IOM uint32_t AD2MC3     : 1;            /*!< [2..2] AD2MC3                                                             */
      __IOM uint32_t AD2MC4     : 1;            /*!< [3..3] AD2MC4                                                             */
      __IOM uint32_t AD2MPER    : 1;            /*!< [4..4] AD2MPER                                                            */
      __IOM uint32_t AD2EEV6    : 1;            /*!< [5..5] AD2EEV6                                                            */
      __IOM uint32_t AD2EEV7    : 1;            /*!< [6..6] AD2EEV7                                                            */
      __IOM uint32_t AD2EEV8    : 1;            /*!< [7..7] AD2EEV8                                                            */
      __IOM uint32_t AD2EEV9    : 1;            /*!< [8..8] AD2EEV9                                                            */
      __IOM uint32_t AD2EEV10   : 1;            /*!< [9..9] AD2EEV10                                                           */
      __IOM uint32_t AD2TAC2    : 1;            /*!< [10..10] AD2TAC2                                                          */
      __IOM uint32_t AD2TAC3    : 1;            /*!< [11..11] AD2TAC3                                                          */
      __IOM uint32_t AD2TAC4    : 1;            /*!< [12..12] AD2TAC4                                                          */
      __IOM uint32_t AD2TAPER   : 1;            /*!< [13..13] AD2TAPER                                                         */
      __IOM uint32_t AD2TBC2    : 1;            /*!< [14..14] AD2TBC2                                                          */
      __IOM uint32_t AD2TBC3    : 1;            /*!< [15..15] AD2TBC3                                                          */
      __IOM uint32_t AD2TBC4    : 1;            /*!< [16..16] AD2TBC4                                                          */
      __IOM uint32_t AD2TBPER   : 1;            /*!< [17..17] AD2TBPER                                                         */
      __IOM uint32_t AD2TCC2    : 1;            /*!< [18..18] AD2TCC2                                                          */
      __IOM uint32_t AD2TCC3    : 1;            /*!< [19..19] AD2TCC3                                                          */
      __IOM uint32_t AD2TCC4    : 1;            /*!< [20..20] AD2TCC4                                                          */
      __IOM uint32_t AD2TCPER   : 1;            /*!< [21..21] AD2TCPER                                                         */
      __IOM uint32_t AD2TCRST   : 1;            /*!< [22..22] AD2TCRST                                                         */
      __IOM uint32_t AD2TDC2    : 1;            /*!< [23..23] AD2TDC2                                                          */
      __IOM uint32_t AD2TDC3    : 1;            /*!< [24..24] AD2TDC3                                                          */
      __IOM uint32_t AD2TDC4    : 1;            /*!< [25..25] AD2TDC4                                                          */
      __IOM uint32_t AD2TDPER   : 1;            /*!< [26..26] AD2TDPER                                                         */
      __IOM uint32_t AD2TDRST   : 1;            /*!< [27..27] AD2TDRST                                                         */
      __IOM uint32_t AD2TEC2    : 1;            /*!< [28..28] AD2TEC2                                                          */
      __IOM uint32_t AD2TEC3    : 1;            /*!< [29..29] AD2TEC3                                                          */
      __IOM uint32_t AD2TEC4    : 1;            /*!< [30..30] AD2TEC4                                                          */
      __IOM uint32_t AD2TERST   : 1;            /*!< [31..31] AD2TERST                                                         */
    } ADC4R_b;
  } ;
  
  union {
    __IOM uint32_t DLLCR;                       /*!< (@ 0x0000004C) DLL Control Register                                       */
    
    struct {
      __IOM uint32_t CAL        : 1;            /*!< [0..0] DLL Calibration Start                                              */
      __IOM uint32_t CALEN      : 1;            /*!< [1..1] DLL Calibration Enable                                             */
      __IOM uint32_t CALRTE     : 2;            /*!< [3..2] DLL Calibration rate                                               */
            uint32_t            : 28;
    } DLLCR_b;
  } ;
  
  union {
    __IOM uint32_t FLTINR1;                     /*!< (@ 0x00000050) HRTIM Fault Input Register 1                               */
    
    struct {
      __IOM uint32_t FLT1E      : 1;            /*!< [0..0] FLT1E                                                              */
      __IOM uint32_t FLT1P      : 1;            /*!< [1..1] FLT1P                                                              */
      __IOM uint32_t FLT1SRC    : 1;            /*!< [2..2] FLT1SRC                                                            */
      __IOM uint32_t FLT1F      : 4;            /*!< [6..3] FLT1F                                                              */
      __IOM uint32_t FLT1LCK    : 1;            /*!< [7..7] FLT1LCK                                                            */
      __IOM uint32_t FLT2E      : 1;            /*!< [8..8] FLT2E                                                              */
      __IOM uint32_t FLT2P      : 1;            /*!< [9..9] FLT2P                                                              */
      __IOM uint32_t FLT2SRC    : 1;            /*!< [10..10] FLT2SRC                                                          */
      __IOM uint32_t FLT2F      : 4;            /*!< [14..11] FLT2F                                                            */
      __IOM uint32_t FLT2LCK    : 1;            /*!< [15..15] FLT2LCK                                                          */
      __IOM uint32_t FLT3E      : 1;            /*!< [16..16] FLT3E                                                            */
      __IOM uint32_t FLT3P      : 1;            /*!< [17..17] FLT3P                                                            */
      __IOM uint32_t FLT3SRC    : 1;            /*!< [18..18] FLT3SRC                                                          */
      __IOM uint32_t FLT3F      : 4;            /*!< [22..19] FLT3F                                                            */
      __IOM uint32_t FLT3LCK    : 1;            /*!< [23..23] FLT3LCK                                                          */
      __IOM uint32_t FLT4E      : 1;            /*!< [24..24] FLT4E                                                            */
      __IOM uint32_t FLT4P      : 1;            /*!< [25..25] FLT4P                                                            */
      __IOM uint32_t FLT4SRC    : 1;            /*!< [26..26] FLT4SRC                                                          */
      __IOM uint32_t FLT4F      : 4;            /*!< [30..27] FLT4F                                                            */
      __IOM uint32_t FLT4LCK    : 1;            /*!< [31..31] FLT4LCK                                                          */
    } FLTINR1_b;
  } ;
  
  union {
    __IOM uint32_t FLTINR2;                     /*!< (@ 0x00000054) HRTIM Fault Input Register 2                               */
    
    struct {
      __IOM uint32_t FLT5E      : 1;            /*!< [0..0] FLT5E                                                              */
      __IOM uint32_t FLT5P      : 1;            /*!< [1..1] FLT5P                                                              */
      __IOM uint32_t FLT5SRC    : 1;            /*!< [2..2] FLT5SRC                                                            */
      __IOM uint32_t FLT5F      : 4;            /*!< [6..3] FLT5F                                                              */
      __IOM uint32_t FLT5LCK    : 1;            /*!< [7..7] FLT5LCK                                                            */
            uint32_t            : 16;
      __IOM uint32_t FLTSD      : 2;            /*!< [25..24] FLTSD                                                            */
            uint32_t            : 6;
    } FLTINR2_b;
  } ;
  
  union {
    __IOM uint32_t BDMUPDR;                     /*!< (@ 0x00000058) BDMUPDR                                                    */
    
    struct {
      __IOM uint32_t MCR        : 1;            /*!< [0..0] MCR                                                                */
      __IOM uint32_t MICR       : 1;            /*!< [1..1] MICR                                                               */
      __IOM uint32_t MDIER      : 1;            /*!< [2..2] MDIER                                                              */
      __IOM uint32_t MCNT       : 1;            /*!< [3..3] MCNT                                                               */
      __IOM uint32_t MPER       : 1;            /*!< [4..4] MPER                                                               */
      __IOM uint32_t MREP       : 1;            /*!< [5..5] MREP                                                               */
      __IOM uint32_t MCMP1      : 1;            /*!< [6..6] MCMP1                                                              */
      __IOM uint32_t MCMP2      : 1;            /*!< [7..7] MCMP2                                                              */
      __IOM uint32_t MCMP3      : 1;            /*!< [8..8] MCMP3                                                              */
      __IOM uint32_t MCMP4      : 1;            /*!< [9..9] MCMP4                                                              */
            uint32_t            : 22;
    } BDMUPDR_b;
  } ;
  
  union {
    __IOM uint32_t BDTxUPR;                     /*!< (@ 0x0000005C) Burst DMA Timerx update Register                           */
    
    struct {
      __IOM uint32_t TIMxCR     : 1;            /*!< [0..0] HRTIM_TIMxCR register update enable                                */
      __IOM uint32_t TIMxICR    : 1;            /*!< [1..1] HRTIM_TIMxICR register update enable                               */
      __IOM uint32_t TIMxDIER   : 1;            /*!< [2..2] HRTIM_TIMxDIER register update enable                              */
      __IOM uint32_t TIMxCNT    : 1;            /*!< [3..3] HRTIM_CNTxR register update enable                                 */
      __IOM uint32_t TIMxPER    : 1;            /*!< [4..4] HRTIM_PERxR register update enable                                 */
      __IOM uint32_t TIMxREP    : 1;            /*!< [5..5] HRTIM_REPxR register update enable                                 */
      __IOM uint32_t TIMxCMP1   : 1;            /*!< [6..6] HRTIM_CMP1xR register update enable                                */
      __IOM uint32_t TIMxCMP2   : 1;            /*!< [7..7] HRTIM_CMP2xR register update enable                                */
      __IOM uint32_t TIMxCMP3   : 1;            /*!< [8..8] HRTIM_CMP3xR register update enable                                */
      __IOM uint32_t TIMxCMP4   : 1;            /*!< [9..9] HRTIM_CMP4xR register update enable                                */
      __IOM uint32_t TIMx_DTxR  : 1;            /*!< [10..10] HRTIM_DTxR register update enable                                */
      __IOM uint32_t TIMxSET1R  : 1;            /*!< [11..11] HRTIM_SET1xR register update enable                              */
      __IOM uint32_t TIMxRST1R  : 1;            /*!< [12..12] HRTIM_RST1xR register update enable                              */
      __IOM uint32_t TIMxSET2R  : 1;            /*!< [13..13] HRTIM_SET2xR register update enable                              */
      __IOM uint32_t TIMxRST2R  : 1;            /*!< [14..14] HRTIM_RST2xR register update enable                              */
      __IOM uint32_t TIMxEEFR1  : 1;            /*!< [15..15] HRTIM_EEFxR1 register update enable                              */
      __IOM uint32_t TIMxEEFR2  : 1;            /*!< [16..16] HRTIM_EEFxR2 register update enable                              */
      __IOM uint32_t TIMxRSTR   : 1;            /*!< [17..17] HRTIM_RSTxR register update enable                               */
      __IOM uint32_t TIMxCHPR   : 1;            /*!< [18..18] HRTIM_CHPxR register update enable                               */
      __IOM uint32_t TIMxOUTR   : 1;            /*!< [19..19] HRTIM_OUTxR register update enable                               */
      __IOM uint32_t TIMxFLTR   : 1;            /*!< [20..20] HRTIM_FLTxR register update enable                               */
            uint32_t            : 11;
    } BDTxUPR_b;
  } ;
  
  union {
    __IOM uint32_t BDMADR;                      /*!< (@ 0x00000060) Burst DMA Data Register                                    */
    
    struct {
      __IOM uint32_t BDMADR     : 32;           /*!< [31..0] Burst DMA Data register                                           */
    } BDMADR_b;
  } ;
} HRTIM_Common_Type;                            /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                           DFSDM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Digital filter for sigma delta
      modulators (DFSDM)
  */

typedef struct {                                /*!< (@ 0x40017000) DFSDM Structure                                            */
  
  union {
    __IOM uint32_t CH0CFGR1;                    /*!< (@ 0x00000000) channel configuration y register                           */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
      __IOM uint32_t CKOUTDIV   : 8;            /*!< [23..16] CKOUTDIV                                                         */
            uint32_t            : 6;
      __IOM uint32_t CKOUTSRC   : 1;            /*!< [30..30] CKOUTSRC                                                         */
      __IOM uint32_t DFSDMEN    : 1;            /*!< [31..31] DFSDMEN                                                          */
    } CH0CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH0CFGR2;                    /*!< (@ 0x00000004) channel configuration y register                           */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH0CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH0AWSCDR;                   /*!< (@ 0x00000008) analog watchdog and short-circuit detector register        */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH0AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH0WDATR;                    /*!< (@ 0x0000000C) channel watchdog filter data register                      */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH0WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH0DATINR;                   /*!< (@ 0x00000010) channel data input register                                */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH0DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH0DLYR;                     /*!< (@ 0x00000014) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH0DLYR_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t CH1CFGR1;                    /*!< (@ 0x00000020) CH1CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH1CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH1CFGR2;                    /*!< (@ 0x00000024) CH1CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH1CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH1AWSCDR;                   /*!< (@ 0x00000028) CH1AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH1AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH1WDATR;                    /*!< (@ 0x0000002C) CH1WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH1WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH1DATINR;                   /*!< (@ 0x00000030) CH1DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH1DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH1DLYR;                     /*!< (@ 0x00000034) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH1DLYR_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t CH2CFGR1;                    /*!< (@ 0x00000040) CH2CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH2CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH2CFGR2;                    /*!< (@ 0x00000044) CH2CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH2CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH2AWSCDR;                   /*!< (@ 0x00000048) CH2AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH2AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH2WDATR;                    /*!< (@ 0x0000004C) CH2WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH2WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH2DATINR;                   /*!< (@ 0x00000050) CH2DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH2DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH2DLYR;                     /*!< (@ 0x00000054) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH2DLYR_b;
  } ;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t CH3CFGR1;                    /*!< (@ 0x00000060) CH3CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH3CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH3CFGR2;                    /*!< (@ 0x00000064) CH3CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH3CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH3AWSCDR;                   /*!< (@ 0x00000068) CH3AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH3AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH3WDATR;                    /*!< (@ 0x0000006C) CH3WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH3WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH3DATINR;                   /*!< (@ 0x00000070) CH3DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH3DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH3DLYR;                     /*!< (@ 0x00000074) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH3DLYR_b;
  } ;
  __IM  uint32_t  RESERVED3[2];
  
  union {
    __IOM uint32_t CH4CFGR1;                    /*!< (@ 0x00000080) CH4CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH4CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH4CFGR2;                    /*!< (@ 0x00000084) CH4CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH4CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH4AWSCDR;                   /*!< (@ 0x00000088) CH4AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH4AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH4WDATR;                    /*!< (@ 0x0000008C) CH4WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH4WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH4DATINR;                   /*!< (@ 0x00000090) CH4DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH4DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH4DLYR;                     /*!< (@ 0x00000094) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH4DLYR_b;
  } ;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t CH5CFGR1;                    /*!< (@ 0x000000A0) CH5CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH5CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH5CFGR2;                    /*!< (@ 0x000000A4) CH5CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH5CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH5AWSCDR;                   /*!< (@ 0x000000A8) CH5AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH5AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH5WDATR;                    /*!< (@ 0x000000AC) CH5WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH5WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH5DATINR;                   /*!< (@ 0x000000B0) CH5DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH5DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH5DLYR;                     /*!< (@ 0x000000B4) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH5DLYR_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t CH6CFGR1;                    /*!< (@ 0x000000C0) CH6CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH6CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH6CFGR2;                    /*!< (@ 0x000000C4) CH6CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH6CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH6AWSCDR;                   /*!< (@ 0x000000C8) CH6AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH6AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH6WDATR;                    /*!< (@ 0x000000CC) CH6WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH6WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH6DATINR;                   /*!< (@ 0x000000D0) CH6DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH6DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH6DLYR;                     /*!< (@ 0x000000D4) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH6DLYR_b;
  } ;
  __IM  uint32_t  RESERVED6[2];
  
  union {
    __IOM uint32_t CH7CFGR1;                    /*!< (@ 0x000000E0) CH7CFGR1                                                   */
    
    struct {
      __IOM uint32_t SITP       : 2;            /*!< [1..0] SITP                                                               */
      __IOM uint32_t SPICKSEL   : 2;            /*!< [3..2] SPICKSEL                                                           */
            uint32_t            : 1;
      __IOM uint32_t SCDEN      : 1;            /*!< [5..5] SCDEN                                                              */
      __IOM uint32_t CKABEN     : 1;            /*!< [6..6] CKABEN                                                             */
      __IOM uint32_t CHEN       : 1;            /*!< [7..7] CHEN                                                               */
      __IOM uint32_t CHINSEL    : 1;            /*!< [8..8] CHINSEL                                                            */
            uint32_t            : 3;
      __IOM uint32_t DATMPX     : 2;            /*!< [13..12] DATMPX                                                           */
      __IOM uint32_t DATPACK    : 2;            /*!< [15..14] DATPACK                                                          */
            uint32_t            : 16;
    } CH7CFGR1_b;
  } ;
  
  union {
    __IOM uint32_t CH7CFGR2;                    /*!< (@ 0x000000E4) CH7CFGR2                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DTRBS      : 5;            /*!< [7..3] DTRBS                                                              */
      __IOM uint32_t OFFSET     : 24;           /*!< [31..8] OFFSET                                                            */
    } CH7CFGR2_b;
  } ;
  
  union {
    __IOM uint32_t CH7AWSCDR;                   /*!< (@ 0x000000E8) CH7AWSCDR                                                  */
    
    struct {
      __IOM uint32_t SCDT       : 8;            /*!< [7..0] SCDT                                                               */
            uint32_t            : 4;
      __IOM uint32_t BKSCD      : 4;            /*!< [15..12] BKSCD                                                            */
      __IOM uint32_t AWFOSR     : 5;            /*!< [20..16] AWFOSR                                                           */
            uint32_t            : 1;
      __IOM uint32_t AWFORD     : 2;            /*!< [23..22] AWFORD                                                           */
            uint32_t            : 8;
    } CH7AWSCDR_b;
  } ;
  
  union {
    __IOM uint32_t CH7WDATR;                    /*!< (@ 0x000000EC) CH7WDATR                                                   */
    
    struct {
      __IOM uint32_t WDATA      : 16;           /*!< [15..0] WDATA                                                             */
            uint32_t            : 16;
    } CH7WDATR_b;
  } ;
  
  union {
    __IOM uint32_t CH7DATINR;                   /*!< (@ 0x000000F0) CH7DATINR                                                  */
    
    struct {
      __IOM uint32_t INDAT0     : 16;           /*!< [15..0] INDAT0                                                            */
      __IOM uint32_t INDAT1     : 16;           /*!< [31..16] INDAT1                                                           */
    } CH7DATINR_b;
  } ;
  
  union {
    __IOM uint32_t CH7DLYR;                     /*!< (@ 0x000000F4) channel y delay register                                   */
    
    struct {
      __IOM uint32_t PLSSKP     : 6;            /*!< [5..0] PLSSKP                                                             */
            uint32_t            : 26;
    } CH7DLYR_b;
  } ;
  __IM  uint32_t  RESERVED7[2];
  
  union {
    __IOM uint32_t DFSDM_FLT0CR1;               /*!< (@ 0x00000100) control register 1                                         */
    
    struct {
      __IOM uint32_t DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32_t JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32_t            : 1;
      __IOM uint32_t JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32_t JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32_t JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32_t            : 2;
      __IOM uint32_t JEXTSEL    : 3;            /*!< [10..8] Trigger signal selection for launching injected conversions       */
            uint32_t            : 2;
      __IOM uint32_t JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32_t            : 2;
      __IOM uint32_t RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32_t RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32_t RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32_t            : 1;
      __IOM uint32_t RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32_t            : 2;
      __IOM uint32_t RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32_t            : 2;
      __IOM uint32_t FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32_t AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32_t            : 1;
    } DFSDM_FLT0CR1_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0CR2;               /*!< (@ 0x00000104) control register 2                                         */
    
    struct {
      __IOM uint32_t JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32_t REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32_t JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32_t ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32_t AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32_t SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32_t CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32_t            : 1;
      __IOM uint32_t EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32_t AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32_t            : 8;
    } DFSDM_FLT0CR2_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0ISR;               /*!< (@ 0x00000108) interrupt and status register                              */
    
    struct {
      __IM  uint32_t JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32_t REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32_t JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32_t ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32_t AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32_t            : 8;
      __IM  uint32_t JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32_t RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32_t            : 1;
      __IM  uint32_t CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32_t SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } DFSDM_FLT0ISR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0ICR;               /*!< (@ 0x0000010C) interrupt flag clear register                              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32_t CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32_t            : 12;
      __IOM uint32_t CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32_t CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } DFSDM_FLT0ICR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0JCHGR;             /*!< (@ 0x00000110) injected channel group selection register                  */
    
    struct {
      __IOM uint32_t JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32_t            : 24;
    } DFSDM_FLT0JCHGR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0FCR;               /*!< (@ 0x00000114) filter control register                                    */
    
    struct {
      __IOM uint32_t IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32_t            : 8;
      __IOM uint32_t FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32_t            : 3;
      __IOM uint32_t FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } DFSDM_FLT0FCR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0JDATAR;            /*!< (@ 0x00000118) data register for injected group                           */
    
    struct {
      __IM  uint32_t JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32_t            : 5;
      __IM  uint32_t JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } DFSDM_FLT0JDATAR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0RDATAR;            /*!< (@ 0x0000011C) data register for the regular channel                      */
    
    struct {
      __IM  uint32_t RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32_t            : 1;
      __IM  uint32_t RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32_t            : 3;
      __IM  uint32_t RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } DFSDM_FLT0RDATAR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0AWHTR;             /*!< (@ 0x00000120) analog watchdog high threshold register                    */
    
    struct {
      __IOM uint32_t BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } DFSDM_FLT0AWHTR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0AWLTR;             /*!< (@ 0x00000124) analog watchdog low threshold register                     */
    
    struct {
      __IOM uint32_t BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } DFSDM_FLT0AWLTR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0AWSR;              /*!< (@ 0x00000128) analog watchdog status register                            */
    
    struct {
      __IM  uint32_t AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32_t AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32_t            : 16;
    } DFSDM_FLT0AWSR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT0AWCFR;             /*!< (@ 0x0000012C) analog watchdog clear flag register                        */
    
    struct {
      __IOM uint32_t CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32_t CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32_t            : 16;
    } DFSDM_FLT0AWCFR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0EXMAX;             /*!< (@ 0x00000130) Extremes detector maximum register                         */
    
    struct {
      __IM  uint32_t EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } DFSDM_FLT0EXMAX_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0EXMIN;             /*!< (@ 0x00000134) Extremes detector minimum register                         */
    
    struct {
      __IM  uint32_t EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMIN      : 24;           /*!< [31..8] EXMIN                                                             */
    } DFSDM_FLT0EXMIN_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT0CNVTIMR;           /*!< (@ 0x00000138) conversion timer register                                  */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time t = CNVCNT[27:0]
                                                     / fDFSDM_CKIN                                                             */
    } DFSDM_FLT0CNVTIMR_b;
  } ;
  __IM  uint32_t  RESERVED8[17];
  
  union {
    __IOM uint32_t DFSDM_FLT1CR1;               /*!< (@ 0x00000180) control register 1                                         */
    
    struct {
      __IOM uint32_t DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32_t JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32_t            : 1;
      __IOM uint32_t JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32_t JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32_t JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32_t            : 2;
      __IOM uint32_t JEXTSEL    : 3;            /*!< [10..8] Trigger signal selection for launching injected conversions       */
            uint32_t            : 2;
      __IOM uint32_t JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32_t            : 2;
      __IOM uint32_t RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32_t RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32_t RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32_t            : 1;
      __IOM uint32_t RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32_t            : 2;
      __IOM uint32_t RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32_t            : 2;
      __IOM uint32_t FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32_t AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32_t            : 1;
    } DFSDM_FLT1CR1_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1CR2;               /*!< (@ 0x00000184) control register 2                                         */
    
    struct {
      __IOM uint32_t JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32_t REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32_t JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32_t ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32_t AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32_t SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32_t CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32_t            : 1;
      __IOM uint32_t EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32_t AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32_t            : 8;
    } DFSDM_FLT1CR2_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1ISR;               /*!< (@ 0x00000188) interrupt and status register                              */
    
    struct {
      __IM  uint32_t JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32_t REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32_t JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32_t ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32_t AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32_t            : 8;
      __IM  uint32_t JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32_t RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32_t            : 1;
      __IM  uint32_t CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32_t SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } DFSDM_FLT1ISR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1ICR;               /*!< (@ 0x0000018C) interrupt flag clear register                              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32_t CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32_t            : 12;
      __IOM uint32_t CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32_t CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } DFSDM_FLT1ICR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1CHGR;              /*!< (@ 0x00000190) injected channel group selection register                  */
    
    struct {
      __IOM uint32_t JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32_t            : 24;
    } DFSDM_FLT1CHGR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1FCR;               /*!< (@ 0x00000194) filter control register                                    */
    
    struct {
      __IOM uint32_t IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32_t            : 8;
      __IOM uint32_t FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32_t            : 3;
      __IOM uint32_t FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } DFSDM_FLT1FCR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1JDATAR;            /*!< (@ 0x00000198) data register for injected group                           */
    
    struct {
      __IM  uint32_t JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32_t            : 5;
      __IM  uint32_t JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } DFSDM_FLT1JDATAR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1RDATAR;            /*!< (@ 0x0000019C) data register for the regular channel                      */
    
    struct {
      __IM  uint32_t RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32_t            : 1;
      __IM  uint32_t RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32_t            : 3;
      __IM  uint32_t RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } DFSDM_FLT1RDATAR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1AWHTR;             /*!< (@ 0x000001A0) analog watchdog high threshold register                    */
    
    struct {
      __IOM uint32_t BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } DFSDM_FLT1AWHTR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1AWLTR;             /*!< (@ 0x000001A4) analog watchdog low threshold register                     */
    
    struct {
      __IOM uint32_t BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } DFSDM_FLT1AWLTR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1AWSR;              /*!< (@ 0x000001A8) analog watchdog status register                            */
    
    struct {
      __IM  uint32_t AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32_t AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32_t            : 16;
    } DFSDM_FLT1AWSR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT1AWCFR;             /*!< (@ 0x000001AC) analog watchdog clear flag register                        */
    
    struct {
      __IOM uint32_t CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32_t CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32_t            : 16;
    } DFSDM_FLT1AWCFR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1EXMAX;             /*!< (@ 0x000001B0) Extremes detector maximum register                         */
    
    struct {
      __IM  uint32_t EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } DFSDM_FLT1EXMAX_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1EXMIN;             /*!< (@ 0x000001B4) Extremes detector minimum register                         */
    
    struct {
      __IM  uint32_t EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMIN      : 24;           /*!< [31..8] EXMIN                                                             */
    } DFSDM_FLT1EXMIN_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT1CNVTIMR;           /*!< (@ 0x000001B8) conversion timer register                                  */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time t = CNVCNT[27:0]
                                                     / fDFSDM_CKIN                                                             */
    } DFSDM_FLT1CNVTIMR_b;
  } ;
  __IM  uint32_t  RESERVED9[17];
  
  union {
    __IOM uint32_t DFSDM_FLT2CR1;               /*!< (@ 0x00000200) control register 1                                         */
    
    struct {
      __IOM uint32_t DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32_t JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32_t            : 1;
      __IOM uint32_t JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32_t JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32_t JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32_t            : 2;
      __IOM uint32_t JEXTSEL    : 3;            /*!< [10..8] Trigger signal selection for launching injected conversions       */
            uint32_t            : 2;
      __IOM uint32_t JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32_t            : 2;
      __IOM uint32_t RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32_t RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32_t RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32_t            : 1;
      __IOM uint32_t RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32_t            : 2;
      __IOM uint32_t RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32_t            : 2;
      __IOM uint32_t FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32_t AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32_t            : 1;
    } DFSDM_FLT2CR1_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2CR2;               /*!< (@ 0x00000204) control register 2                                         */
    
    struct {
      __IOM uint32_t JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32_t REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32_t JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32_t ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32_t AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32_t SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32_t CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32_t            : 1;
      __IOM uint32_t EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32_t AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32_t            : 8;
    } DFSDM_FLT2CR2_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2ISR;               /*!< (@ 0x00000208) interrupt and status register                              */
    
    struct {
      __IM  uint32_t JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32_t REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32_t JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32_t ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32_t AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32_t            : 8;
      __IM  uint32_t JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32_t RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32_t            : 1;
      __IM  uint32_t CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32_t SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } DFSDM_FLT2ISR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2ICR;               /*!< (@ 0x0000020C) interrupt flag clear register                              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32_t CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32_t            : 12;
      __IOM uint32_t CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32_t CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } DFSDM_FLT2ICR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2JCHGR;             /*!< (@ 0x00000210) injected channel group selection register                  */
    
    struct {
      __IOM uint32_t JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32_t            : 24;
    } DFSDM_FLT2JCHGR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2FCR;               /*!< (@ 0x00000214) filter control register                                    */
    
    struct {
      __IOM uint32_t IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32_t            : 8;
      __IOM uint32_t FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32_t            : 3;
      __IOM uint32_t FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } DFSDM_FLT2FCR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2JDATAR;            /*!< (@ 0x00000218) data register for injected group                           */
    
    struct {
      __IM  uint32_t JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32_t            : 5;
      __IM  uint32_t JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } DFSDM_FLT2JDATAR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2RDATAR;            /*!< (@ 0x0000021C) data register for the regular channel                      */
    
    struct {
      __IM  uint32_t RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32_t            : 1;
      __IM  uint32_t RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32_t            : 3;
      __IM  uint32_t RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } DFSDM_FLT2RDATAR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2AWHTR;             /*!< (@ 0x00000220) analog watchdog high threshold register                    */
    
    struct {
      __IOM uint32_t BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } DFSDM_FLT2AWHTR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2AWLTR;             /*!< (@ 0x00000224) analog watchdog low threshold register                     */
    
    struct {
      __IOM uint32_t BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } DFSDM_FLT2AWLTR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2AWSR;              /*!< (@ 0x00000228) analog watchdog status register                            */
    
    struct {
      __IM  uint32_t AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32_t AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32_t            : 16;
    } DFSDM_FLT2AWSR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT2AWCFR;             /*!< (@ 0x0000022C) analog watchdog clear flag register                        */
    
    struct {
      __IOM uint32_t CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32_t CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32_t            : 16;
    } DFSDM_FLT2AWCFR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2EXMAX;             /*!< (@ 0x00000230) Extremes detector maximum register                         */
    
    struct {
      __IM  uint32_t EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } DFSDM_FLT2EXMAX_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2EXMIN;             /*!< (@ 0x00000234) Extremes detector minimum register                         */
    
    struct {
      __IM  uint32_t EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMIN      : 24;           /*!< [31..8] EXMIN                                                             */
    } DFSDM_FLT2EXMIN_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT2CNVTIMR;           /*!< (@ 0x00000238) conversion timer register                                  */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time t = CNVCNT[27:0]
                                                     / fDFSDM_CKIN                                                             */
    } DFSDM_FLT2CNVTIMR_b;
  } ;
  __IM  uint32_t  RESERVED10[17];
  
  union {
    __IOM uint32_t DFSDM_FLT3CR1;               /*!< (@ 0x00000280) control register 1                                         */
    
    struct {
      __IOM uint32_t DFEN       : 1;            /*!< [0..0] DFSDM enable                                                       */
      __IOM uint32_t JSWSTART   : 1;            /*!< [1..1] Start a conversion of the injected group of channels               */
            uint32_t            : 1;
      __IOM uint32_t JSYNC      : 1;            /*!< [3..3] Launch an injected conversion synchronously with the
                                                     DFSDM0 JSWSTART trigger                                                   */
      __IOM uint32_t JSCAN      : 1;            /*!< [4..4] Scanning conversion mode for injected conversions                  */
      __IOM uint32_t JDMAEN     : 1;            /*!< [5..5] DMA channel enabled to read data for the injected channel
                                                     group                                                                     */
            uint32_t            : 2;
      __IOM uint32_t JEXTSEL    : 3;            /*!< [10..8] Trigger signal selection for launching injected conversions       */
            uint32_t            : 2;
      __IOM uint32_t JEXTEN     : 2;            /*!< [14..13] Trigger enable and trigger edge selection for injected
                                                     conversions                                                               */
            uint32_t            : 2;
      __IOM uint32_t RSWSTART   : 1;            /*!< [17..17] Software start of a conversion on the regular channel            */
      __IOM uint32_t RCONT      : 1;            /*!< [18..18] Continuous mode selection for regular conversions                */
      __IOM uint32_t RSYNC      : 1;            /*!< [19..19] Launch regular conversion synchronously with DFSDM0              */
            uint32_t            : 1;
      __IOM uint32_t RDMAEN     : 1;            /*!< [21..21] DMA channel enabled to read data for the regular conversion      */
            uint32_t            : 2;
      __IOM uint32_t RCH        : 3;            /*!< [26..24] Regular channel selection                                        */
            uint32_t            : 2;
      __IOM uint32_t FAST       : 1;            /*!< [29..29] Fast conversion mode selection for regular conversions           */
      __IOM uint32_t AWFSEL     : 1;            /*!< [30..30] Analog watchdog fast mode select                                 */
            uint32_t            : 1;
    } DFSDM_FLT3CR1_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3CR2;               /*!< (@ 0x00000284) control register 2                                         */
    
    struct {
      __IOM uint32_t JEOCIE     : 1;            /*!< [0..0] Injected end of conversion interrupt enable                        */
      __IOM uint32_t REOCIE     : 1;            /*!< [1..1] Regular end of conversion interrupt enable                         */
      __IOM uint32_t JOVRIE     : 1;            /*!< [2..2] Injected data overrun interrupt enable                             */
      __IOM uint32_t ROVRIE     : 1;            /*!< [3..3] Regular data overrun interrupt enable                              */
      __IOM uint32_t AWDIE      : 1;            /*!< [4..4] Analog watchdog interrupt enable                                   */
      __IOM uint32_t SCDIE      : 1;            /*!< [5..5] Short-circuit detector interrupt enable                            */
      __IOM uint32_t CKABIE     : 1;            /*!< [6..6] Clock absence interrupt enable                                     */
            uint32_t            : 1;
      __IOM uint32_t EXCH       : 8;            /*!< [15..8] Extremes detector channel selection                               */
      __IOM uint32_t AWDCH      : 8;            /*!< [23..16] Analog watchdog channel selection                                */
            uint32_t            : 8;
    } DFSDM_FLT3CR2_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3ISR;               /*!< (@ 0x00000288) interrupt and status register                              */
    
    struct {
      __IM  uint32_t JEOCF      : 1;            /*!< [0..0] End of injected conversion flag                                    */
      __IM  uint32_t REOCF      : 1;            /*!< [1..1] End of regular conversion flag                                     */
      __IM  uint32_t JOVRF      : 1;            /*!< [2..2] Injected conversion overrun flag                                   */
      __IM  uint32_t ROVRF      : 1;            /*!< [3..3] Regular conversion overrun flag                                    */
      __IM  uint32_t AWDF       : 1;            /*!< [4..4] Analog watchdog                                                    */
            uint32_t            : 8;
      __IM  uint32_t JCIP       : 1;            /*!< [13..13] Injected conversion in progress status                           */
      __IM  uint32_t RCIP       : 1;            /*!< [14..14] Regular conversion in progress status                            */
            uint32_t            : 1;
      __IM  uint32_t CKABF      : 8;            /*!< [23..16] Clock absence flag                                               */
      __IM  uint32_t SCDF       : 8;            /*!< [31..24] short-circuit detector flag                                      */
    } DFSDM_FLT3ISR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3ICR;               /*!< (@ 0x0000028C) interrupt flag clear register                              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t CLRJOVRF   : 1;            /*!< [2..2] Clear the injected conversion overrun flag                         */
      __IOM uint32_t CLRROVRF   : 1;            /*!< [3..3] Clear the regular conversion overrun flag                          */
            uint32_t            : 12;
      __IOM uint32_t CLRCKABF   : 8;            /*!< [23..16] Clear the clock absence flag                                     */
      __IOM uint32_t CLRSCDF    : 8;            /*!< [31..24] Clear the short-circuit detector flag                            */
    } DFSDM_FLT3ICR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3JCHGR;             /*!< (@ 0x00000290) injected channel group selection register                  */
    
    struct {
      __IOM uint32_t JCHG       : 8;            /*!< [7..0] Injected channel group selection                                   */
            uint32_t            : 24;
    } DFSDM_FLT3JCHGR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3FCR;               /*!< (@ 0x00000294) filter control register                                    */
    
    struct {
      __IOM uint32_t IOSR       : 8;            /*!< [7..0] Integrator oversampling ratio (averaging length)                   */
            uint32_t            : 8;
      __IOM uint32_t FOSR       : 10;           /*!< [25..16] Sinc filter oversampling ratio (decimation rate)                 */
            uint32_t            : 3;
      __IOM uint32_t FORD       : 3;            /*!< [31..29] Sinc filter order                                                */
    } DFSDM_FLT3FCR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3JDATAR;            /*!< (@ 0x00000298) data register for injected group                           */
    
    struct {
      __IM  uint32_t JDATACH    : 3;            /*!< [2..0] Injected channel most recently converted                           */
            uint32_t            : 5;
      __IM  uint32_t JDATA      : 24;           /*!< [31..8] Injected group conversion data                                    */
    } DFSDM_FLT3JDATAR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3RDATAR;            /*!< (@ 0x0000029C) data register for the regular channel                      */
    
    struct {
      __IM  uint32_t RDATACH    : 3;            /*!< [2..0] Regular channel most recently converted                            */
            uint32_t            : 1;
      __IM  uint32_t RPEND      : 1;            /*!< [4..4] Regular channel pending data                                       */
            uint32_t            : 3;
      __IM  uint32_t RDATA      : 24;           /*!< [31..8] Regular channel conversion data                                   */
    } DFSDM_FLT3RDATAR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3AWHTR;             /*!< (@ 0x000002A0) analog watchdog high threshold register                    */
    
    struct {
      __IOM uint32_t BKAWH      : 4;            /*!< [3..0] Break signal assignment to analog watchdog high threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWHT       : 24;           /*!< [31..8] Analog watchdog high threshold                                    */
    } DFSDM_FLT3AWHTR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3AWLTR;             /*!< (@ 0x000002A4) analog watchdog low threshold register                     */
    
    struct {
      __IOM uint32_t BKAWL      : 4;            /*!< [3..0] Break signal assignment to analog watchdog low threshold
                                                     event                                                                     */
            uint32_t            : 4;
      __IOM uint32_t AWLT       : 24;           /*!< [31..8] Analog watchdog low threshold                                     */
    } DFSDM_FLT3AWLTR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3AWSR;              /*!< (@ 0x000002A8) analog watchdog status register                            */
    
    struct {
      __IM  uint32_t AWLTF      : 8;            /*!< [7..0] Analog watchdog low threshold flag                                 */
      __IM  uint32_t AWHTF      : 8;            /*!< [15..8] Analog watchdog high threshold flag                               */
            uint32_t            : 16;
    } DFSDM_FLT3AWSR_b;
  } ;
  
  union {
    __IOM uint32_t DFSDM_FLT3AWCFR;             /*!< (@ 0x000002AC) analog watchdog clear flag register                        */
    
    struct {
      __IOM uint32_t CLRAWLTF   : 8;            /*!< [7..0] Clear the analog watchdog low threshold flag                       */
      __IOM uint32_t CLRAWHTF   : 8;            /*!< [15..8] Clear the analog watchdog high threshold flag                     */
            uint32_t            : 16;
    } DFSDM_FLT3AWCFR_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3EXMAX;             /*!< (@ 0x000002B0) Extremes detector maximum register                         */
    
    struct {
      __IM  uint32_t EXMAXCH    : 3;            /*!< [2..0] Extremes detector maximum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMAX      : 24;           /*!< [31..8] Extremes detector maximum value                                   */
    } DFSDM_FLT3EXMAX_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3EXMIN;             /*!< (@ 0x000002B4) Extremes detector minimum register                         */
    
    struct {
      __IM  uint32_t EXMINCH    : 3;            /*!< [2..0] Extremes detector minimum data channel                             */
            uint32_t            : 5;
      __IM  uint32_t EXMIN      : 24;           /*!< [31..8] EXMIN                                                             */
    } DFSDM_FLT3EXMIN_b;
  } ;
  
  union {
    __IM  uint32_t DFSDM_FLT3CNVTIMR;           /*!< (@ 0x000002B8) conversion timer register                                  */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t CNVCNT     : 28;           /*!< [31..4] 28-bit timer counting conversion time t = CNVCNT[27:0]
                                                     / fDFSDM_CKIN                                                             */
    } DFSDM_FLT3CNVTIMR_b;
  } ;
} DFSDM_Type;                                   /*!< Size = 700 (0x2bc)                                                        */



/* =========================================================================================================================== */
/* ================                                           TIM16                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General-purpose-timers (TIM16)
  */

typedef struct {                                /*!< (@ 0x40014400) TIM16 Structure                                            */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32_t            : 3;
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32_t CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32_t            : 1;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32_t CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32_t            : 1;
      __IOM uint32_t CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32_t CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
            uint32_t            : 4;
      __IOM uint32_t OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32_t OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
            uint32_t            : 22;
    } CR2_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32_t CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
            uint32_t            : 3;
      __IOM uint32_t COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
            uint32_t            : 1;
      __IOM uint32_t BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32_t CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
            uint32_t            : 3;
      __IOM uint32_t COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
            uint32_t            : 18;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32_t CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
            uint32_t            : 3;
      __IOM uint32_t COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
            uint32_t            : 1;
      __IOM uint32_t BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32_t            : 1;
      __IOM uint32_t CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
            uint32_t            : 22;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32_t CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
            uint32_t            : 3;
      __OM  uint32_t COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
            uint32_t            : 1;
      __OM  uint32_t BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32_t            : 24;
    } EGR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CCMR1_Output;              /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32_t OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32_t OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32_t          : 9;
        __IOM uint32_t OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode                                            */
              uint32_t          : 15;
      } CCMR1_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR1_Input;               /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32_t IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
              uint32_t          : 24;
      } CCMR1_Input_b;
    } ;
  };
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t CCER;                        /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32_t CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32_t CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32_t CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
            uint32_t            : 28;
    } CCER_b;
  } ;
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32_t            : 15;
      __IM  uint32_t UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IOM uint32_t RCR;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32_t REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32_t            : 24;
    } RCR_b;
  } ;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32_t CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32_t            : 16;
    } CCR1_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t BDTR;                        /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32_t DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32_t LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32_t OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32_t OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32_t BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32_t BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32_t AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32_t MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32_t BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32_t            : 12;
    } BDTR_b;
  } ;
  
  union {
    __IOM uint32_t DCR;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32_t DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32_t            : 3;
      __IOM uint32_t DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32_t            : 19;
    } DCR_b;
  } ;
  
  union {
    __IOM uint32_t DMAR;                        /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32_t DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32_t            : 16;
    } DMAR_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t TIM16_AF1;                   /*!< (@ 0x00000060) TIM16 alternate function register 1                        */
    
    struct {
      __IOM uint32_t BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32_t BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32_t BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32_t            : 5;
      __IOM uint32_t BKDFBK1E   : 1;            /*!< [8..8] BRK dfsdm1_break[1] enable                                         */
      __IOM uint32_t BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32_t BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32_t BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32_t            : 20;
    } TIM16_AF1_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t TIM16_TISEL;                 /*!< (@ 0x00000068) TIM16 input selection register                             */
    
    struct {
      __IOM uint32_t TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32_t            : 28;
    } TIM16_TISEL_b;
  } ;
} TIM16_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM17                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General-purpose-timers (TIM17)
  */

typedef struct {                                /*!< (@ 0x40014800) TIM17 Structure                                            */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32_t            : 3;
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32_t CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32_t            : 1;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32_t CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32_t            : 1;
      __IOM uint32_t CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32_t CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
            uint32_t            : 4;
      __IOM uint32_t OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32_t OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
            uint32_t            : 22;
    } CR2_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32_t CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
            uint32_t            : 3;
      __IOM uint32_t COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
            uint32_t            : 1;
      __IOM uint32_t BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32_t CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
            uint32_t            : 3;
      __IOM uint32_t COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
            uint32_t            : 18;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32_t CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
            uint32_t            : 3;
      __IOM uint32_t COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
            uint32_t            : 1;
      __IOM uint32_t BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32_t            : 1;
      __IOM uint32_t CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
            uint32_t            : 22;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32_t CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
            uint32_t            : 3;
      __OM  uint32_t COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
            uint32_t            : 1;
      __OM  uint32_t BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32_t            : 24;
    } EGR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CCMR1_Output;              /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32_t OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32_t OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32_t          : 9;
        __IOM uint32_t OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode                                            */
              uint32_t          : 15;
      } CCMR1_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR1_Input;               /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32_t IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
              uint32_t          : 24;
      } CCMR1_Input_b;
    } ;
  };
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t CCER;                        /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32_t CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32_t CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32_t CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
            uint32_t            : 28;
    } CCER_b;
  } ;
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32_t            : 15;
      __IM  uint32_t UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IOM uint32_t RCR;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32_t REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32_t            : 24;
    } RCR_b;
  } ;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32_t CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32_t            : 16;
    } CCR1_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t BDTR;                        /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32_t DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32_t LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32_t OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32_t OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32_t BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32_t BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32_t AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32_t MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32_t BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32_t            : 12;
    } BDTR_b;
  } ;
  
  union {
    __IOM uint32_t DCR;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32_t DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32_t            : 3;
      __IOM uint32_t DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32_t            : 19;
    } DCR_b;
  } ;
  
  union {
    __IOM uint32_t DMAR;                        /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32_t DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32_t            : 16;
    } DMAR_b;
  } ;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t TIM17_AF1;                   /*!< (@ 0x00000060) TIM17 alternate function register 1                        */
    
    struct {
      __IOM uint32_t BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32_t BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32_t BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32_t            : 5;
      __IOM uint32_t BKDFBK1E   : 1;            /*!< [8..8] BRK dfsdm1_break[1] enable                                         */
      __IOM uint32_t BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32_t BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32_t BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32_t            : 20;
    } TIM17_AF1_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t TIM17_TISEL;                 /*!< (@ 0x00000068) TIM17 input selection register                             */
    
    struct {
      __IOM uint32_t TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32_t            : 28;
    } TIM17_TISEL_b;
  } ;
} TIM17_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM15                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timers (TIM15)
  */

typedef struct {                                /*!< (@ 0x40014000) TIM15 Structure                                            */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32_t            : 3;
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32_t CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32_t            : 1;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32_t CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32_t            : 1;
      __IOM uint32_t CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32_t CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32_t MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32_t TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
      __IOM uint32_t OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32_t OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
      __IOM uint32_t OIS2       : 1;            /*!< [10..10] Output Idle state 2                                              */
            uint32_t            : 21;
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t SMCR;                        /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32_t SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32_t            : 1;
      __IOM uint32_t TS_2_0     : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32_t MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
            uint32_t            : 8;
      __IOM uint32_t SMS_3      : 1;            /*!< [16..16] Slave mode selection bit 3                                       */
            uint32_t            : 3;
      __IOM uint32_t TS_4_3     : 2;            /*!< [21..20] Trigger selection - bit 4:3                                      */
            uint32_t            : 10;
    } SMCR_b;
  } ;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32_t CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32_t CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
            uint32_t            : 2;
      __IOM uint32_t COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
      __IOM uint32_t TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
      __IOM uint32_t BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32_t CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32_t CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
            uint32_t            : 2;
      __IOM uint32_t COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
      __IOM uint32_t TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32_t            : 17;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32_t CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32_t CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
            uint32_t            : 2;
      __IOM uint32_t COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
      __IOM uint32_t TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
      __IOM uint32_t BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
            uint32_t            : 1;
      __IOM uint32_t CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32_t CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
            uint32_t            : 21;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32_t CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32_t CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
            uint32_t            : 2;
      __OM  uint32_t COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
      __OM  uint32_t TG         : 1;            /*!< [6..6] Trigger generation                                                 */
      __OM  uint32_t BG         : 1;            /*!< [7..7] Break generation                                                   */
            uint32_t            : 24;
    } EGR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CCMR1_Output;              /*!< (@ 0x00000018) capture/compare mode register (output mode)                */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32_t OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32_t OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
              uint32_t          : 1;
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32_t OC2FE    : 1;            /*!< [10..10] Output Compare 2 fast enable                                     */
        __IOM uint32_t OC2PE    : 1;            /*!< [11..11] Output Compare 2 preload enable                                  */
        __IOM uint32_t OC2M     : 3;            /*!< [14..12] Output Compare 2 mode                                            */
              uint32_t          : 1;
        __IOM uint32_t OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode bit 3                                      */
              uint32_t          : 7;
        __IOM uint32_t OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode bit 3                                      */
              uint32_t          : 7;
      } CCMR1_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR1_Input;               /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t IC1PSC   : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32_t IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32_t IC2PSC   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32_t IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32_t          : 16;
      } CCMR1_Input_b;
    } ;
  };
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t CCER;                        /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32_t CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32_t CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32_t CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32_t CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
            uint32_t            : 1;
      __IOM uint32_t CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
            uint32_t            : 24;
    } CCER_b;
  } ;
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32_t            : 15;
      __IM  uint32_t UIFCPY     : 1;            /*!< [31..31] UIF copy                                                         */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IOM uint32_t RCR;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32_t REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32_t            : 24;
    } RCR_b;
  } ;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32_t CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32_t            : 16;
    } CCR1_b;
  } ;
  
  union {
    __IOM uint32_t CCR2;                        /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32_t CCR2       : 16;           /*!< [15..0] Capture/Compare 2 value                                           */
            uint32_t            : 16;
    } CCR2_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t BDTR;                        /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32_t DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32_t LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32_t OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32_t OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32_t BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32_t BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32_t AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32_t MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32_t BKF        : 4;            /*!< [19..16] Break filter                                                     */
            uint32_t            : 12;
    } BDTR_b;
  } ;
  
  union {
    __IOM uint32_t DCR;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32_t DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32_t            : 3;
      __IOM uint32_t DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32_t            : 19;
    } DCR_b;
  } ;
  
  union {
    __IOM uint32_t DMAR;                        /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32_t DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32_t            : 16;
    } DMAR_b;
  } ;
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t AF1;                         /*!< (@ 0x00000060) TIM15 alternate fdfsdm1_breakon register 1                 */
    
    struct {
      __IOM uint32_t BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32_t BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32_t BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32_t            : 5;
      __IOM uint32_t BKDF1BK0E  : 1;            /*!< [8..8] BRK dfsdm1_break[0] enable                                         */
      __IOM uint32_t BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32_t BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32_t BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32_t            : 20;
    } AF1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t TISEL;                       /*!< (@ 0x00000068) TIM15 input selection register                             */
    
    struct {
      __IOM uint32_t TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32_t            : 4;
      __IOM uint32_t TI2SEL     : 4;            /*!< [11..8] selects TI2[0] to TI2[15] input                                   */
            uint32_t            : 20;
    } TISEL_b;
  } ;
} TIM15_Type;                                   /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                          USART1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal synchronous asynchronous receiver
      transmitter (USART1)
  */

typedef struct {                                /*!< (@ 0x40011000) USART1 Structure                                           */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) Control register 1                                         */
    
    struct {
      __IOM uint32_t UE         : 1;            /*!< [0..0] USART enable                                                       */
      __IOM uint32_t UESM       : 1;            /*!< [1..1] USART enable in Stop mode                                          */
      __IOM uint32_t RE         : 1;            /*!< [2..2] Receiver enable                                                    */
      __IOM uint32_t TE         : 1;            /*!< [3..3] Transmitter enable                                                 */
      __IOM uint32_t IDLEIE     : 1;            /*!< [4..4] IDLE interrupt enable                                              */
      __IOM uint32_t RXNEIE     : 1;            /*!< [5..5] RXNE interrupt enable                                              */
      __IOM uint32_t TCIE       : 1;            /*!< [6..6] Transmission complete interrupt enable                             */
      __IOM uint32_t TXEIE      : 1;            /*!< [7..7] interrupt enable                                                   */
      __IOM uint32_t PEIE       : 1;            /*!< [8..8] PE interrupt enable                                                */
      __IOM uint32_t PS         : 1;            /*!< [9..9] Parity selection                                                   */
      __IOM uint32_t PCE        : 1;            /*!< [10..10] Parity control enable                                            */
      __IOM uint32_t WAKE       : 1;            /*!< [11..11] Receiver wakeup method                                           */
      __IOM uint32_t M0         : 1;            /*!< [12..12] Word length                                                      */
      __IOM uint32_t MME        : 1;            /*!< [13..13] Mute mode enable                                                 */
      __IOM uint32_t CMIE       : 1;            /*!< [14..14] Character match interrupt enable                                 */
      __IOM uint32_t OVER8      : 1;            /*!< [15..15] Oversampling mode                                                */
      __IOM uint32_t DEDT0      : 1;            /*!< [16..16] DEDT0                                                            */
      __IOM uint32_t DEDT1      : 1;            /*!< [17..17] DEDT1                                                            */
      __IOM uint32_t DEDT2      : 1;            /*!< [18..18] DEDT2                                                            */
      __IOM uint32_t DEDT3      : 1;            /*!< [19..19] DEDT3                                                            */
      __IOM uint32_t DEDT4      : 1;            /*!< [20..20] Driver Enable de-assertion time                                  */
      __IOM uint32_t DEAT0      : 1;            /*!< [21..21] DEAT0                                                            */
      __IOM uint32_t DEAT1      : 1;            /*!< [22..22] DEAT1                                                            */
      __IOM uint32_t DEAT2      : 1;            /*!< [23..23] DEAT2                                                            */
      __IOM uint32_t DEAT3      : 1;            /*!< [24..24] DEAT3                                                            */
      __IOM uint32_t DEAT4      : 1;            /*!< [25..25] Driver Enable assertion time                                     */
      __IOM uint32_t RTOIE      : 1;            /*!< [26..26] Receiver timeout interrupt enable                                */
      __IOM uint32_t EOBIE      : 1;            /*!< [27..27] End of Block interrupt enable                                    */
      __IOM uint32_t M1         : 1;            /*!< [28..28] Word length                                                      */
      __IOM uint32_t FIFOEN     : 1;            /*!< [29..29] FIFO mode enable                                                 */
      __IOM uint32_t TXFEIE     : 1;            /*!< [30..30] TXFIFO empty interrupt enable                                    */
      __IOM uint32_t RXFFIE     : 1;            /*!< [31..31] RXFIFO Full interrupt enable                                     */
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) Control register 2                                         */
    
    struct {
      __IOM uint32_t SLVEN      : 1;            /*!< [0..0] Synchronous Slave mode enable                                      */
            uint32_t            : 2;
      __IOM uint32_t DIS_NSS    : 1;            /*!< [3..3] When the DSI_NSS bit is set, the NSS pin input is ignored          */
      __IOM uint32_t ADDM7      : 1;            /*!< [4..4] 7-bit Address Detection/4-bit Address Detection                    */
      __IOM uint32_t LBDL       : 1;            /*!< [5..5] LIN break detection length                                         */
      __IOM uint32_t LBDIE      : 1;            /*!< [6..6] LIN break detection interrupt enable                               */
            uint32_t            : 1;
      __IOM uint32_t LBCL       : 1;            /*!< [8..8] Last bit clock pulse                                               */
      __IOM uint32_t CPHA       : 1;            /*!< [9..9] Clock phase                                                        */
      __IOM uint32_t CPOL       : 1;            /*!< [10..10] Clock polarity                                                   */
      __IOM uint32_t CLKEN      : 1;            /*!< [11..11] Clock enable                                                     */
      __IOM uint32_t STOP       : 2;            /*!< [13..12] STOP bits                                                        */
      __IOM uint32_t LINEN      : 1;            /*!< [14..14] LIN mode enable                                                  */
      __IOM uint32_t SWAP       : 1;            /*!< [15..15] Swap TX/RX pins                                                  */
      __IOM uint32_t RXINV      : 1;            /*!< [16..16] RX pin active level inversion                                    */
      __IOM uint32_t TXINV      : 1;            /*!< [17..17] TX pin active level inversion                                    */
      __IOM uint32_t TAINV      : 1;            /*!< [18..18] Binary data inversion                                            */
      __IOM uint32_t MSBFIRST   : 1;            /*!< [19..19] Most significant bit first                                       */
      __IOM uint32_t ABREN      : 1;            /*!< [20..20] Auto baud rate enable                                            */
      __IOM uint32_t ABRMOD0    : 1;            /*!< [21..21] ABRMOD0                                                          */
      __IOM uint32_t ABRMOD1    : 1;            /*!< [22..22] Auto baud rate mode                                              */
      __IOM uint32_t RTOEN      : 1;            /*!< [23..23] Receiver timeout enable                                          */
      __IOM uint32_t ADD0_3     : 4;            /*!< [27..24] Address of the USART node                                        */
      __IOM uint32_t ADD4_7     : 4;            /*!< [31..28] Address of the USART node                                        */
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t CR3;                         /*!< (@ 0x00000008) Control register 3                                         */
    
    struct {
      __IOM uint32_t EIE        : 1;            /*!< [0..0] Error interrupt enable                                             */
      __IOM uint32_t IREN       : 1;            /*!< [1..1] Ir mode enable                                                     */
      __IOM uint32_t IRLP       : 1;            /*!< [2..2] Ir low-power                                                       */
      __IOM uint32_t HDSEL      : 1;            /*!< [3..3] Half-duplex selection                                              */
      __IOM uint32_t NACK       : 1;            /*!< [4..4] Smartcard NACK enable                                              */
      __IOM uint32_t SCEN       : 1;            /*!< [5..5] Smartcard mode enable                                              */
      __IOM uint32_t DMAR       : 1;            /*!< [6..6] DMA enable receiver                                                */
      __IOM uint32_t DMAT       : 1;            /*!< [7..7] DMA enable transmitter                                             */
      __IOM uint32_t RTSE       : 1;            /*!< [8..8] RTS enable                                                         */
      __IOM uint32_t CTSE       : 1;            /*!< [9..9] CTS enable                                                         */
      __IOM uint32_t CTSIE      : 1;            /*!< [10..10] CTS interrupt enable                                             */
      __IOM uint32_t ONEBIT     : 1;            /*!< [11..11] One sample bit method enable                                     */
      __IOM uint32_t OVRDIS     : 1;            /*!< [12..12] Overrun Disable                                                  */
      __IOM uint32_t DDRE       : 1;            /*!< [13..13] DMA Disable on Reception Error                                   */
      __IOM uint32_t DEM        : 1;            /*!< [14..14] Driver enable mode                                               */
      __IOM uint32_t DEP        : 1;            /*!< [15..15] Driver enable polarity selection                                 */
            uint32_t            : 1;
      __IOM uint32_t SCARCNT    : 3;            /*!< [19..17] Smartcard auto-retry count                                       */
      __IOM uint32_t WUS        : 2;            /*!< [21..20] Wakeup from Stop mode interrupt flag selection                   */
      __IOM uint32_t WUFIE      : 1;            /*!< [22..22] Wakeup from Stop mode interrupt enable                           */
      __IOM uint32_t TXFTIE     : 1;            /*!< [23..23] TXFIFO threshold interrupt enable                                */
      __IOM uint32_t TCBGTIE    : 1;            /*!< [24..24] Transmission Complete before guard time, interrupt
                                                     enable                                                                    */
      __IOM uint32_t RXFTCFG    : 3;            /*!< [27..25] Receive FIFO threshold configuration                             */
      __IOM uint32_t RXFTIE     : 1;            /*!< [28..28] RXFIFO threshold interrupt enable                                */
      __IOM uint32_t TXFTCFG    : 3;            /*!< [31..29] TXFIFO threshold configuration                                   */
    } CR3_b;
  } ;
  
  union {
    __IOM uint32_t BRR;                         /*!< (@ 0x0000000C) Baud rate register                                         */
    
    struct {
      __IOM uint32_t BRR_0_3    : 4;            /*!< [3..0] DIV_Fraction                                                       */
      __IOM uint32_t BRR_4_15   : 12;           /*!< [15..4] DIV_Mantissa                                                      */
            uint32_t            : 16;
    } BRR_b;
  } ;
  
  union {
    __IOM uint32_t GTPR;                        /*!< (@ 0x00000010) Guard time and prescaler register                          */
    
    struct {
      __IOM uint32_t PSC        : 8;            /*!< [7..0] Prescaler value                                                    */
      __IOM uint32_t GT         : 8;            /*!< [15..8] Guard time value                                                  */
            uint32_t            : 16;
    } GTPR_b;
  } ;
  
  union {
    __IOM uint32_t RTOR;                        /*!< (@ 0x00000014) Receiver timeout register                                  */
    
    struct {
      __IOM uint32_t RTO        : 24;           /*!< [23..0] Receiver timeout value                                            */
      __IOM uint32_t BLEN       : 8;            /*!< [31..24] Block Length                                                     */
    } RTOR_b;
  } ;
  
  union {
    __OM  uint32_t RQR;                         /*!< (@ 0x00000018) Request register                                           */
    
    struct {
      __OM  uint32_t ABRRQ      : 1;            /*!< [0..0] Auto baud rate request                                             */
      __OM  uint32_t SBKRQ      : 1;            /*!< [1..1] Send break request                                                 */
      __OM  uint32_t MMRQ       : 1;            /*!< [2..2] Mute mode request                                                  */
      __OM  uint32_t RXFRQ      : 1;            /*!< [3..3] Receive data flush request                                         */
      __OM  uint32_t TXFRQ      : 1;            /*!< [4..4] Transmit data flush request                                        */
            uint32_t            : 27;
    } RQR_b;
  } ;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x0000001C) Interrupt & status register                                */
    
    struct {
      __IM  uint32_t PE         : 1;            /*!< [0..0] PE                                                                 */
      __IM  uint32_t FE         : 1;            /*!< [1..1] FE                                                                 */
      __IM  uint32_t NF         : 1;            /*!< [2..2] NF                                                                 */
      __IM  uint32_t ORE        : 1;            /*!< [3..3] ORE                                                                */
      __IM  uint32_t IDLE       : 1;            /*!< [4..4] IDLE                                                               */
      __IM  uint32_t RXNE       : 1;            /*!< [5..5] RXNE                                                               */
      __IM  uint32_t TC         : 1;            /*!< [6..6] TC                                                                 */
      __IM  uint32_t TXE        : 1;            /*!< [7..7] TXE                                                                */
      __IM  uint32_t LBDF       : 1;            /*!< [8..8] LBDF                                                               */
      __IM  uint32_t CTSIF      : 1;            /*!< [9..9] CTSIF                                                              */
      __IM  uint32_t CTS        : 1;            /*!< [10..10] CTS                                                              */
      __IM  uint32_t RTOF       : 1;            /*!< [11..11] RTOF                                                             */
      __IM  uint32_t EOBF       : 1;            /*!< [12..12] EOBF                                                             */
      __IM  uint32_t UDR        : 1;            /*!< [13..13] SPI slave underrun error flag                                    */
      __IM  uint32_t ABRE       : 1;            /*!< [14..14] ABRE                                                             */
      __IM  uint32_t ABRF       : 1;            /*!< [15..15] ABRF                                                             */
      __IM  uint32_t BUSY       : 1;            /*!< [16..16] BUSY                                                             */
      __IM  uint32_t CMF        : 1;            /*!< [17..17] CMF                                                              */
      __IM  uint32_t SBKF       : 1;            /*!< [18..18] SBKF                                                             */
      __IM  uint32_t RWU        : 1;            /*!< [19..19] RWU                                                              */
      __IM  uint32_t WUF        : 1;            /*!< [20..20] WUF                                                              */
      __IM  uint32_t TEACK      : 1;            /*!< [21..21] TEACK                                                            */
      __IM  uint32_t REACK      : 1;            /*!< [22..22] REACK                                                            */
      __IM  uint32_t TXFE       : 1;            /*!< [23..23] TXFIFO Empty                                                     */
      __IM  uint32_t RXFF       : 1;            /*!< [24..24] RXFIFO Full                                                      */
      __IM  uint32_t TCBGT      : 1;            /*!< [25..25] Transmission complete before guard time flag                     */
      __IM  uint32_t RXFT       : 1;            /*!< [26..26] RXFIFO threshold flag                                            */
      __IM  uint32_t TXFT       : 1;            /*!< [27..27] TXFIFO threshold flag                                            */
            uint32_t            : 4;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000020) Interrupt flag clear register                              */
    
    struct {
      __OM  uint32_t PECF       : 1;            /*!< [0..0] Parity error clear flag                                            */
      __OM  uint32_t FECF       : 1;            /*!< [1..1] Framing error clear flag                                           */
      __OM  uint32_t NCF        : 1;            /*!< [2..2] Noise detected clear flag                                          */
      __OM  uint32_t ORECF      : 1;            /*!< [3..3] Overrun error clear flag                                           */
      __OM  uint32_t IDLECF     : 1;            /*!< [4..4] Idle line detected clear flag                                      */
      __OM  uint32_t TXFECF     : 1;            /*!< [5..5] TXFIFO empty clear flag                                            */
      __OM  uint32_t TCCF       : 1;            /*!< [6..6] Transmission complete clear flag                                   */
      __OM  uint32_t TCBGTC     : 1;            /*!< [7..7] Transmission complete before Guard time clear flag                 */
      __OM  uint32_t LBDCF      : 1;            /*!< [8..8] LIN break detection clear flag                                     */
      __OM  uint32_t CTSCF      : 1;            /*!< [9..9] CTS clear flag                                                     */
            uint32_t            : 1;
      __OM  uint32_t RTOCF      : 1;            /*!< [11..11] Receiver timeout clear flag                                      */
      __OM  uint32_t EOBCF      : 1;            /*!< [12..12] End of block clear flag                                          */
      __OM  uint32_t UDRCF      : 1;            /*!< [13..13] SPI slave underrun clear flag                                    */
            uint32_t            : 3;
      __OM  uint32_t CMCF       : 1;            /*!< [17..17] Character match clear flag                                       */
            uint32_t            : 2;
      __OM  uint32_t WUCF       : 1;            /*!< [20..20] Wakeup from Stop mode clear flag                                 */
            uint32_t            : 11;
    } ICR_b;
  } ;
  
  union {
    __IM  uint32_t RDR;                         /*!< (@ 0x00000024) Receive data register                                      */
    
    struct {
      __IM  uint32_t RDR        : 9;            /*!< [8..0] Receive data value                                                 */
            uint32_t            : 23;
    } RDR_b;
  } ;
  
  union {
    __IOM uint32_t TDR;                         /*!< (@ 0x00000028) Transmit data register                                     */
    
    struct {
      __IOM uint32_t TDR        : 9;            /*!< [8..0] Transmit data value                                                */
            uint32_t            : 23;
    } TDR_b;
  } ;
  
  union {
    __IOM uint32_t PRESC;                       /*!< (@ 0x0000002C) USART prescaler register                                   */
    
    struct {
      __IOM uint32_t PRESCALER  : 4;            /*!< [3..0] Clock prescaler                                                    */
            uint32_t            : 28;
    } PRESC_b;
  } ;
} USART1_Type;                                  /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           TIM1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Advanced-timers (TIM1)
  */

typedef struct {                                /*!< (@ 0x40010000) TIM1 Structure                                             */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Direction                                                          */
      __IOM uint32_t CMS        : 2;            /*!< [6..5] Center-aligned mode selection                                      */
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32_t CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32_t            : 1;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
      __IOM uint32_t CCPC       : 1;            /*!< [0..0] Capture/compare preloaded control                                  */
            uint32_t            : 1;
      __IOM uint32_t CCUS       : 1;            /*!< [2..2] Capture/compare control update selection                           */
      __IOM uint32_t CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32_t MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32_t TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
      __IOM uint32_t OIS1       : 1;            /*!< [8..8] Output Idle state 1                                                */
      __IOM uint32_t OIS1N      : 1;            /*!< [9..9] Output Idle state 1                                                */
      __IOM uint32_t OIS2       : 1;            /*!< [10..10] Output Idle state 2                                              */
      __IOM uint32_t OIS2N      : 1;            /*!< [11..11] Output Idle state 2                                              */
      __IOM uint32_t OIS3       : 1;            /*!< [12..12] Output Idle state 3                                              */
      __IOM uint32_t OIS3N      : 1;            /*!< [13..13] Output Idle state 3                                              */
      __IOM uint32_t OIS4       : 1;            /*!< [14..14] Output Idle state 4                                              */
            uint32_t            : 1;
      __IOM uint32_t OIS5       : 1;            /*!< [16..16] Output Idle state 5                                              */
            uint32_t            : 1;
      __IOM uint32_t OIS6       : 1;            /*!< [18..18] Output Idle state 6                                              */
            uint32_t            : 1;
      __IOM uint32_t MMS2       : 4;            /*!< [23..20] Master mode selection 2                                          */
            uint32_t            : 8;
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t SMCR;                        /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32_t SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32_t            : 1;
      __IOM uint32_t TS         : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32_t MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
      __IOM uint32_t ETF        : 4;            /*!< [11..8] External trigger filter                                           */
      __IOM uint32_t ETPS       : 2;            /*!< [13..12] External trigger prescaler                                       */
      __IOM uint32_t ECE        : 1;            /*!< [14..14] External clock enable                                            */
      __IOM uint32_t ETP        : 1;            /*!< [15..15] External trigger polarity                                        */
      __IOM uint32_t SMS_3      : 1;            /*!< [16..16] Slave mode selection - bit 3                                     */
            uint32_t            : 3;
      __IOM uint32_t TS_4_3     : 2;            /*!< [21..20] Trigger selection - bit 4:3                                      */
            uint32_t            : 10;
    } SMCR_b;
  } ;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32_t CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32_t CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
      __IOM uint32_t CC3IE      : 1;            /*!< [3..3] Capture/Compare 3 interrupt enable                                 */
      __IOM uint32_t CC4IE      : 1;            /*!< [4..4] Capture/Compare 4 interrupt enable                                 */
      __IOM uint32_t COMIE      : 1;            /*!< [5..5] COM interrupt enable                                               */
      __IOM uint32_t TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
      __IOM uint32_t BIE        : 1;            /*!< [7..7] Break interrupt enable                                             */
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32_t CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32_t CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
      __IOM uint32_t CC3DE      : 1;            /*!< [11..11] Capture/Compare 3 DMA request enable                             */
      __IOM uint32_t CC4DE      : 1;            /*!< [12..12] Capture/Compare 4 DMA request enable                             */
      __IOM uint32_t COMDE      : 1;            /*!< [13..13] COM DMA request enable                                           */
      __IOM uint32_t TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32_t            : 17;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32_t CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32_t CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
      __IOM uint32_t CC3IF      : 1;            /*!< [3..3] Capture/Compare 3 interrupt flag                                   */
      __IOM uint32_t CC4IF      : 1;            /*!< [4..4] Capture/Compare 4 interrupt flag                                   */
      __IOM uint32_t COMIF      : 1;            /*!< [5..5] COM interrupt flag                                                 */
      __IOM uint32_t TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
      __IOM uint32_t BIF        : 1;            /*!< [7..7] Break interrupt flag                                               */
      __IOM uint32_t B2IF       : 1;            /*!< [8..8] Break 2 interrupt flag                                             */
      __IOM uint32_t CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32_t CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
      __IOM uint32_t CC3OF      : 1;            /*!< [11..11] Capture/Compare 3 overcapture flag                               */
      __IOM uint32_t CC4OF      : 1;            /*!< [12..12] Capture/Compare 4 overcapture flag                               */
      __IOM uint32_t SBIF       : 1;            /*!< [13..13] System Break interrupt flag                                      */
            uint32_t            : 2;
      __IOM uint32_t CC5IF      : 1;            /*!< [16..16] Compare 5 interrupt flag                                         */
      __IOM uint32_t CC6IF      : 1;            /*!< [17..17] Compare 6 interrupt flag                                         */
            uint32_t            : 14;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32_t CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32_t CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
      __OM  uint32_t CC3G       : 1;            /*!< [3..3] Capture/compare 3 generation                                       */
      __OM  uint32_t CC4G       : 1;            /*!< [4..4] Capture/compare 4 generation                                       */
      __OM  uint32_t COMG       : 1;            /*!< [5..5] Capture/Compare control update generation                          */
      __OM  uint32_t TG         : 1;            /*!< [6..6] Trigger generation                                                 */
      __OM  uint32_t BG         : 1;            /*!< [7..7] Break generation                                                   */
      __OM  uint32_t B2G        : 1;            /*!< [8..8] Break 2 generation                                                 */
            uint32_t            : 23;
    } EGR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CCMR1_Output;              /*!< (@ 0x00000018) capture/compare mode register 1 (output mode)              */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t OC1FE    : 1;            /*!< [2..2] Output Compare 1 fast enable                                       */
        __IOM uint32_t OC1PE    : 1;            /*!< [3..3] Output Compare 1 preload enable                                    */
        __IOM uint32_t OC1M     : 3;            /*!< [6..4] Output Compare 1 mode                                              */
        __IOM uint32_t OC1CE    : 1;            /*!< [7..7] Output Compare 1 clear enable                                      */
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32_t OC2FE    : 1;            /*!< [10..10] Output Compare 2 fast enable                                     */
        __IOM uint32_t OC2PE    : 1;            /*!< [11..11] Output Compare 2 preload enable                                  */
        __IOM uint32_t OC2M     : 3;            /*!< [14..12] Output Compare 2 mode                                            */
        __IOM uint32_t OC2CE    : 1;            /*!< [15..15] Output Compare 2 clear enable                                    */
        __IOM uint32_t OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32_t          : 7;
        __IOM uint32_t OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32_t          : 7;
      } CCMR1_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR1_Input;               /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t ICPCS    : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32_t IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32_t IC2PCS   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32_t IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32_t          : 16;
      } CCMR1_Input_b;
    } ;
  };
  
  union {
    union {
      __IOM uint32_t CCMR2_Output;              /*!< (@ 0x0000001C) capture/compare mode register 2 (output mode)              */
      
      struct {
        __IOM uint32_t CC3S     : 2;            /*!< [1..0] Capture/Compare 3 selection                                        */
        __IOM uint32_t OC3FE    : 1;            /*!< [2..2] Output compare 3 fast enable                                       */
        __IOM uint32_t OC3PE    : 1;            /*!< [3..3] Output compare 3 preload enable                                    */
        __IOM uint32_t OC3M     : 3;            /*!< [6..4] Output compare 3 mode                                              */
        __IOM uint32_t OC3CE    : 1;            /*!< [7..7] Output compare 3 clear enable                                      */
        __IOM uint32_t CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32_t OC4FE    : 1;            /*!< [10..10] Output compare 4 fast enable                                     */
        __IOM uint32_t OC4PE    : 1;            /*!< [11..11] Output compare 4 preload enable                                  */
        __IOM uint32_t OC4M     : 3;            /*!< [14..12] Output compare 4 mode                                            */
        __IOM uint32_t OC4CE    : 1;            /*!< [15..15] Output compare 4 clear enable                                    */
        __IOM uint32_t OC3M_3   : 1;            /*!< [16..16] Output Compare 3 mode - bit 3                                    */
              uint32_t          : 7;
        __IOM uint32_t OC4M_4   : 1;            /*!< [24..24] Output Compare 4 mode - bit 3                                    */
              uint32_t          : 7;
      } CCMR2_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR2_Input;               /*!< (@ 0x0000001C) capture/compare mode register 2 (input mode)               */
      
      struct {
        __IOM uint32_t CC3S     : 2;            /*!< [1..0] Capture/compare 3 selection                                        */
        __IOM uint32_t IC3PSC   : 2;            /*!< [3..2] Input capture 3 prescaler                                          */
        __IOM uint32_t IC3F     : 4;            /*!< [7..4] Input capture 3 filter                                             */
        __IOM uint32_t CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32_t IC4PSC   : 2;            /*!< [11..10] Input capture 4 prescaler                                        */
        __IOM uint32_t IC4F     : 4;            /*!< [15..12] Input capture 4 filter                                           */
              uint32_t          : 16;
      } CCMR2_Input_b;
    } ;
  };
  
  union {
    __IOM uint32_t CCER;                        /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32_t CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32_t CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC1NE      : 1;            /*!< [2..2] Capture/Compare 1 complementary output enable                      */
      __IOM uint32_t CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32_t CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
      __IOM uint32_t CC2NE      : 1;            /*!< [6..6] Capture/Compare 2 complementary output enable                      */
      __IOM uint32_t CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
      __IOM uint32_t CC3E       : 1;            /*!< [8..8] Capture/Compare 3 output enable                                    */
      __IOM uint32_t CC3P       : 1;            /*!< [9..9] Capture/Compare 3 output Polarity                                  */
      __IOM uint32_t CC3NE      : 1;            /*!< [10..10] Capture/Compare 3 complementary output enable                    */
      __IOM uint32_t CC3NP      : 1;            /*!< [11..11] Capture/Compare 3 output Polarity                                */
      __IOM uint32_t CC4E       : 1;            /*!< [12..12] Capture/Compare 4 output enable                                  */
      __IOM uint32_t CC4P       : 1;            /*!< [13..13] Capture/Compare 3 output Polarity                                */
            uint32_t            : 1;
      __IOM uint32_t CC4NP      : 1;            /*!< [15..15] Capture/Compare 4 complementary output polarity                  */
      __IOM uint32_t CC5E       : 1;            /*!< [16..16] Capture/Compare 5 output enable                                  */
      __IOM uint32_t CC5P       : 1;            /*!< [17..17] Capture/Compare 5 output polarity                                */
            uint32_t            : 2;
      __IOM uint32_t CC6E       : 1;            /*!< [20..20] Capture/Compare 6 output enable                                  */
      __IOM uint32_t CC6P       : 1;            /*!< [21..21] Capture/Compare 6 output polarity                                */
            uint32_t            : 10;
    } CCER_b;
  } ;
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT        : 16;           /*!< [15..0] counter value                                                     */
            uint32_t            : 15;
      __IM  uint32_t UIFCPY     : 1;            /*!< [31..31] UIF copy                                                         */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Auto-reload value                                                 */
            uint32_t            : 16;
    } ARR_b;
  } ;
  
  union {
    __IOM uint32_t RCR;                         /*!< (@ 0x00000030) repetition counter register                                */
    
    struct {
      __IOM uint32_t REP        : 8;            /*!< [7..0] Repetition counter value                                           */
            uint32_t            : 24;
    } RCR_b;
  } ;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32_t CCR1       : 16;           /*!< [15..0] Capture/Compare 1 value                                           */
            uint32_t            : 16;
    } CCR1_b;
  } ;
  
  union {
    __IOM uint32_t CCR2;                        /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32_t CCR2       : 16;           /*!< [15..0] Capture/Compare 2 value                                           */
            uint32_t            : 16;
    } CCR2_b;
  } ;
  
  union {
    __IOM uint32_t CCR3;                        /*!< (@ 0x0000003C) capture/compare register 3                                 */
    
    struct {
      __IOM uint32_t CCR3       : 16;           /*!< [15..0] Capture/Compare value                                             */
            uint32_t            : 16;
    } CCR3_b;
  } ;
  
  union {
    __IOM uint32_t CCR4;                        /*!< (@ 0x00000040) capture/compare register 4                                 */
    
    struct {
      __IOM uint32_t CCR4       : 16;           /*!< [15..0] Capture/Compare value                                             */
            uint32_t            : 16;
    } CCR4_b;
  } ;
  
  union {
    __IOM uint32_t BDTR;                        /*!< (@ 0x00000044) break and dead-time register                               */
    
    struct {
      __IOM uint32_t DTG        : 8;            /*!< [7..0] Dead-time generator setup                                          */
      __IOM uint32_t LOCK       : 2;            /*!< [9..8] Lock configuration                                                 */
      __IOM uint32_t OSSI       : 1;            /*!< [10..10] Off-state selection for Idle mode                                */
      __IOM uint32_t OSSR       : 1;            /*!< [11..11] Off-state selection for Run mode                                 */
      __IOM uint32_t BKE        : 1;            /*!< [12..12] Break enable                                                     */
      __IOM uint32_t BKP        : 1;            /*!< [13..13] Break polarity                                                   */
      __IOM uint32_t AOE        : 1;            /*!< [14..14] Automatic output enable                                          */
      __IOM uint32_t MOE        : 1;            /*!< [15..15] Main output enable                                               */
      __IOM uint32_t BKF        : 4;            /*!< [19..16] Break filter                                                     */
      __IOM uint32_t BK2F       : 4;            /*!< [23..20] Break 2 filter                                                   */
      __IOM uint32_t BK2E       : 1;            /*!< [24..24] Break 2 enable                                                   */
      __IOM uint32_t BK2P       : 1;            /*!< [25..25] Break 2 polarity                                                 */
            uint32_t            : 6;
    } BDTR_b;
  } ;
  
  union {
    __IOM uint32_t DCR;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32_t DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32_t            : 3;
      __IOM uint32_t DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32_t            : 19;
    } DCR_b;
  } ;
  
  union {
    __IOM uint32_t DMAR;                        /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32_t DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32_t            : 16;
    } DMAR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t CCMR3_Output;                /*!< (@ 0x00000054) capture/compare mode register 3 (output mode)              */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t OC5FE      : 1;            /*!< [2..2] Output compare 5 fast enable                                       */
      __IOM uint32_t OC5PE      : 1;            /*!< [3..3] Output compare 5 preload enable                                    */
      __IOM uint32_t OC5M       : 3;            /*!< [6..4] Output compare 5 mode                                              */
      __IOM uint32_t OC5CE      : 1;            /*!< [7..7] Output compare 5 clear enable                                      */
            uint32_t            : 2;
      __IOM uint32_t OC6FE      : 1;            /*!< [10..10] Output compare 6 fast enable                                     */
      __IOM uint32_t OC6PE      : 1;            /*!< [11..11] Output compare 6 preload enable                                  */
      __IOM uint32_t OC6M       : 3;            /*!< [14..12] Output compare 6 mode                                            */
      __IOM uint32_t OC6CE      : 1;            /*!< [15..15] Output compare 6 clear enable                                    */
      __IOM uint32_t OC5M3      : 1;            /*!< [16..16] Output Compare 5 mode                                            */
            uint32_t            : 7;
      __IOM uint32_t OC6M3      : 1;            /*!< [24..24] Output Compare 6 mode                                            */
            uint32_t            : 7;
    } CCMR3_Output_b;
  } ;
  
  union {
    __IOM uint32_t CCR5;                        /*!< (@ 0x00000058) capture/compare register 5                                 */
    
    struct {
      __IOM uint32_t CCR5       : 16;           /*!< [15..0] Capture/Compare 5 value                                           */
            uint32_t            : 13;
      __IOM uint32_t GC5C1      : 1;            /*!< [29..29] Group Channel 5 and Channel 1                                    */
      __IOM uint32_t GC5C2      : 1;            /*!< [30..30] Group Channel 5 and Channel 2                                    */
      __IOM uint32_t GC5C3      : 1;            /*!< [31..31] Group Channel 5 and Channel 3                                    */
    } CCR5_b;
  } ;
  
  union {
    __IOM uint32_t CRR6;                        /*!< (@ 0x0000005C) capture/compare register 6                                 */
    
    struct {
      __IOM uint32_t CCR6       : 16;           /*!< [15..0] Capture/Compare 6 value                                           */
            uint32_t            : 16;
    } CRR6_b;
  } ;
  
  union {
    __IOM uint32_t AF1;                         /*!< (@ 0x00000060) TIM1 alternate function option register 1                  */
    
    struct {
      __IOM uint32_t BKINE      : 1;            /*!< [0..0] BRK BKIN input enable                                              */
      __IOM uint32_t BKCMP1E    : 1;            /*!< [1..1] BRK COMP1 enable                                                   */
      __IOM uint32_t BKCMP2E    : 1;            /*!< [2..2] BRK COMP2 enable                                                   */
            uint32_t            : 5;
      __IOM uint32_t BKDF1BK0E  : 1;            /*!< [8..8] BRK dfsdm1_break[0] enable                                         */
      __IOM uint32_t BKINP      : 1;            /*!< [9..9] BRK BKIN input polarity                                            */
      __IOM uint32_t BKCMP1P    : 1;            /*!< [10..10] BRK COMP1 input polarity                                         */
      __IOM uint32_t BKCMP2P    : 1;            /*!< [11..11] BRK COMP2 input polarity                                         */
            uint32_t            : 2;
      __IOM uint32_t ETRSEL     : 4;            /*!< [17..14] ETR source selection                                             */
            uint32_t            : 14;
    } AF1_b;
  } ;
  
  union {
    __IOM uint32_t AF2;                         /*!< (@ 0x00000064) TIM1 Alternate function odfsdm1_breakster 2                */
    
    struct {
      __IOM uint32_t BK2INE     : 1;            /*!< [0..0] BRK2 BKIN input enable                                             */
      __IOM uint32_t BK2CMP1E   : 1;            /*!< [1..1] BRK2 COMP1 enable                                                  */
      __IOM uint32_t BK2CMP2E   : 1;            /*!< [2..2] BRK2 COMP2 enable                                                  */
            uint32_t            : 5;
      __IOM uint32_t BK2DF1BK1E : 1;            /*!< [8..8] BRK2 dfsdm1_break[1] enable                                        */
      __IOM uint32_t BK2INP     : 1;            /*!< [9..9] BRK2 BKIN2 input polarity                                          */
      __IOM uint32_t BK2CMP1P   : 1;            /*!< [10..10] BRK2 COMP1 input polarit                                         */
      __IOM uint32_t BK2CMP2P   : 1;            /*!< [11..11] BRK2 COMP2 input polarity                                        */
            uint32_t            : 20;
    } AF2_b;
  } ;
  
  union {
    __IOM uint32_t TISEL;                       /*!< (@ 0x00000068) TIM1 timer input selection register                        */
    
    struct {
      __IOM uint32_t TI1SEL     : 4;            /*!< [3..0] selects TI1[0] to TI1[15] input                                    */
            uint32_t            : 4;
      __IOM uint32_t TI2SEL     : 4;            /*!< [11..8] selects TI2[0] to TI2[15] input                                   */
            uint32_t            : 4;
      __IOM uint32_t TI3SEL     : 4;            /*!< [19..16] selects TI3[0] to TI3[15] input                                  */
            uint32_t            : 4;
      __IOM uint32_t TI4SEL     : 4;            /*!< [27..24] selects TI4[0] to TI4[15] input                                  */
            uint32_t            : 4;
    } TISEL_b;
  } ;
} TIM1_Type;                                    /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                          FDCAN1                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief FDCAN1 (FDCAN1)
  */

typedef struct {                                /*!< (@ 0x4000A000) FDCAN1 Structure                                           */
  
  union {
    __IM  uint32_t FDCAN_CREL;                  /*!< (@ 0x00000000) FDCAN Core Release Register                                */
    
    struct {
      __IM  uint32_t DAY        : 8;            /*!< [7..0] Timestamp Day                                                      */
      __IM  uint32_t MON        : 8;            /*!< [15..8] Timestamp Month                                                   */
      __IM  uint32_t YEAR       : 4;            /*!< [19..16] Timestamp Year                                                   */
      __IM  uint32_t SUBSTEP    : 4;            /*!< [23..20] Sub-step of Core release                                         */
      __IM  uint32_t STEP       : 4;            /*!< [27..24] Step of Core release                                             */
      __IM  uint32_t REL        : 4;            /*!< [31..28] Core release                                                     */
    } FDCAN_CREL_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_ENDN;                  /*!< (@ 0x00000004) FDCAN Core Release Register                                */
    
    struct {
      __IM  uint32_t ETV        : 32;           /*!< [31..0] Endiannes Test Value                                              */
    } FDCAN_ENDN_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t FDCAN_DBTP;                  /*!< (@ 0x0000000C) FDCAN Data Bit Timing and Prescaler Register               */
    
    struct {
      __IM  uint32_t DSJW       : 4;            /*!< [3..0] Synchronization Jump Width                                         */
      __IM  uint32_t DTSEG2     : 4;            /*!< [7..4] Data time segment after sample point                               */
      __IM  uint32_t DTSEG1     : 5;            /*!< [12..8] Data time segment after sample point                              */
            uint32_t            : 3;
      __IM  uint32_t DBRP       : 5;            /*!< [20..16] Data BIt Rate Prescaler                                          */
            uint32_t            : 2;
      __IM  uint32_t TDC        : 1;            /*!< [23..23] Transceiver Delay Compensation                                   */
            uint32_t            : 8;
    } FDCAN_DBTP_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TEST;                  /*!< (@ 0x00000010) FDCAN Test Register                                        */
    
    struct {
            uint32_t            : 4;
      __IM  uint32_t LBCK       : 1;            /*!< [4..4] Loop Back mode                                                     */
      __IM  uint32_t TX         : 2;            /*!< [6..5] Loop Back mode                                                     */
      __IM  uint32_t RX         : 1;            /*!< [7..7] Control of Transmit Pin                                            */
            uint32_t            : 24;
    } FDCAN_TEST_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_RWD;                   /*!< (@ 0x00000014) FDCAN RAM Watchdog Register                                */
    
    struct {
      __IM  uint32_t WDC        : 8;            /*!< [7..0] Watchdog configuration                                             */
      __IM  uint32_t WDV        : 8;            /*!< [15..8] Watchdog value                                                    */
            uint32_t            : 16;
    } FDCAN_RWD_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_CCCR;                  /*!< (@ 0x00000018) FDCAN CC Control Register                                  */
    
    struct {
      __IOM uint32_t INIT       : 1;            /*!< [0..0] Initialization                                                     */
      __IOM uint32_t CCE        : 1;            /*!< [1..1] Configuration Change Enable                                        */
      __IOM uint32_t ASM        : 1;            /*!< [2..2] ASM Restricted Operation Mode                                      */
      __IOM uint32_t CSA        : 1;            /*!< [3..3] Clock Stop Acknowledge                                             */
      __IOM uint32_t CSR        : 1;            /*!< [4..4] Clock Stop Request                                                 */
      __IOM uint32_t MON        : 1;            /*!< [5..5] Bus Monitoring Mode                                                */
      __IOM uint32_t DAR        : 1;            /*!< [6..6] Disable Automatic Retransmission                                   */
      __IOM uint32_t TEST       : 1;            /*!< [7..7] Test Mode Enable                                                   */
      __IOM uint32_t FDOE       : 1;            /*!< [8..8] FD Operation Enable                                                */
      __IOM uint32_t BSE        : 1;            /*!< [9..9] FDCAN Bit Rate Switching                                           */
            uint32_t            : 2;
      __IOM uint32_t PXHD       : 1;            /*!< [12..12] Protocol Exception Handling Disable                              */
      __IOM uint32_t EFBI       : 1;            /*!< [13..13] Edge Filtering during Bus Integration                            */
      __IOM uint32_t TXP        : 1;            /*!< [14..14] TXP                                                              */
      __IOM uint32_t NISO       : 1;            /*!< [15..15] Non ISO Operation                                                */
            uint32_t            : 16;
    } FDCAN_CCCR_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_NBTP;                  /*!< (@ 0x0000001C) FDCAN Nominal Bit Timing and Prescaler Register            */
    
    struct {
      __IOM uint32_t TSEG2      : 7;            /*!< [6..0] Nominal Time segment after sample point                            */
            uint32_t            : 1;
      __IOM uint32_t NTSEG1     : 8;            /*!< [15..8] Nominal Time segment before sample point                          */
      __IOM uint32_t NBRP       : 9;            /*!< [24..16] Bit Rate Prescaler                                               */
      __IOM uint32_t NSJW       : 7;            /*!< [31..25] NSJW: Nominal (Re)Synchronization Jump Width                     */
    } FDCAN_NBTP_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TSCC;                  /*!< (@ 0x00000020) FDCAN Timestamp Counter Configuration Register             */
    
    struct {
      __IOM uint32_t TSS        : 2;            /*!< [1..0] Timestamp Select                                                   */
            uint32_t            : 14;
      __IOM uint32_t TCP        : 4;            /*!< [19..16] Timestamp Counter Prescaler                                      */
            uint32_t            : 12;
    } FDCAN_TSCC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TSCV;                  /*!< (@ 0x00000024) FDCAN Timestamp Counter Value Register                     */
    
    struct {
      __IOM uint32_t TSC        : 16;           /*!< [15..0] Timestamp Counter                                                 */
            uint32_t            : 16;
    } FDCAN_TSCV_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TOCC;                  /*!< (@ 0x00000028) FDCAN Timeout Counter Configuration Register               */
    
    struct {
      __IOM uint32_t ETOC       : 1;            /*!< [0..0] Enable Timeout Counter                                             */
      __IOM uint32_t TOS        : 2;            /*!< [2..1] Timeout Select                                                     */
            uint32_t            : 13;
      __IOM uint32_t TOP        : 16;           /*!< [31..16] Timeout Period                                                   */
    } FDCAN_TOCC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TOCV;                  /*!< (@ 0x0000002C) FDCAN Timeout Counter Value Register                       */
    
    struct {
      __IOM uint32_t TOC        : 16;           /*!< [15..0] Timeout Counter                                                   */
            uint32_t            : 16;
    } FDCAN_TOCV_b;
  } ;
  __IM  uint32_t  RESERVED1[4];
  
  union {
    __IOM uint32_t FDCAN_ECR;                   /*!< (@ 0x00000040) FDCAN Error Counter Register                               */
    
    struct {
      __IOM uint32_t TEC        : 8;            /*!< [7..0] Transmit Error Counter                                             */
      __IOM uint32_t TREC       : 7;            /*!< [14..8] Receive Error Counter                                             */
      __IOM uint32_t RP         : 1;            /*!< [15..15] Receive Error Passive                                            */
      __IOM uint32_t CEL        : 8;            /*!< [23..16] AN Error Logging                                                 */
            uint32_t            : 8;
    } FDCAN_ECR_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_PSR;                   /*!< (@ 0x00000044) FDCAN Protocol Status Register                             */
    
    struct {
      __IOM uint32_t LEC        : 3;            /*!< [2..0] Last Error Code                                                    */
      __IOM uint32_t ACT        : 2;            /*!< [4..3] Activity                                                           */
      __IOM uint32_t EP         : 1;            /*!< [5..5] Error Passive                                                      */
      __IOM uint32_t EW         : 1;            /*!< [6..6] Warning Status                                                     */
      __IOM uint32_t BO         : 1;            /*!< [7..7] Bus_Off Status                                                     */
      __IOM uint32_t DLEC       : 3;            /*!< [10..8] Data Last Error Code                                              */
      __IOM uint32_t RESI       : 1;            /*!< [11..11] ESI flag of last received FDCAN Message                          */
      __IOM uint32_t RBRS       : 1;            /*!< [12..12] BRS flag of last received FDCAN Message                          */
      __IOM uint32_t REDL       : 1;            /*!< [13..13] Received FDCAN Message                                           */
      __IOM uint32_t PXE        : 1;            /*!< [14..14] Protocol Exception Event                                         */
            uint32_t            : 1;
      __IOM uint32_t TDCV       : 7;            /*!< [22..16] Transmitter Delay Compensation Value                             */
            uint32_t            : 9;
    } FDCAN_PSR_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TDCR;                  /*!< (@ 0x00000048) FDCAN Transmitter Delay Compensation Register              */
    
    struct {
      __IM  uint32_t TDCF       : 7;            /*!< [6..0] Transmitter Delay Compensation Filter Window Length                */
            uint32_t            : 1;
      __IM  uint32_t TDCO       : 7;            /*!< [14..8] Transmitter Delay Compensation Offset                             */
            uint32_t            : 17;
    } FDCAN_TDCR_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IM  uint32_t FDCAN_IR;                    /*!< (@ 0x00000050) FDCAN Interrupt Register                                   */
    
    struct {
      __IM  uint32_t RF0N       : 1;            /*!< [0..0] Rx FIFO 0 New Message                                              */
      __IM  uint32_t RF0W       : 1;            /*!< [1..1] Rx FIFO 0 Full                                                     */
      __IM  uint32_t RF0F       : 1;            /*!< [2..2] Rx FIFO 0 Full                                                     */
      __IM  uint32_t RF0L       : 1;            /*!< [3..3] Rx FIFO 0 Message Lost                                             */
      __IM  uint32_t RF1N       : 1;            /*!< [4..4] Rx FIFO 1 New Message                                              */
      __IM  uint32_t RF1W       : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached                                        */
      __IM  uint32_t RF1F       : 1;            /*!< [6..6] Rx FIFO 1 Watermark Reached                                        */
      __IM  uint32_t RF1L       : 1;            /*!< [7..7] Rx FIFO 1 Message Lost                                             */
      __IM  uint32_t HPM        : 1;            /*!< [8..8] High Priority Message                                              */
      __IM  uint32_t TC         : 1;            /*!< [9..9] Transmission Completed                                             */
      __IM  uint32_t TCF        : 1;            /*!< [10..10] Transmission Cancellation Finished                               */
      __IM  uint32_t TEF        : 1;            /*!< [11..11] Tx FIFO Empty                                                    */
      __IM  uint32_t TEFN       : 1;            /*!< [12..12] Tx Event FIFO New Entry                                          */
      __IM  uint32_t TEFW       : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached                                  */
      __IM  uint32_t TEFF       : 1;            /*!< [14..14] Tx Event FIFO Full                                               */
      __IM  uint32_t TEFL       : 1;            /*!< [15..15] Tx Event FIFO Element Lost                                       */
      __IM  uint32_t TSW        : 1;            /*!< [16..16] Timestamp Wraparound                                             */
      __IM  uint32_t MRAF       : 1;            /*!< [17..17] Message RAM Access Failure                                       */
      __IM  uint32_t TOO        : 1;            /*!< [18..18] Timeout Occurred                                                 */
      __IM  uint32_t DRX        : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer                            */
            uint32_t            : 2;
      __IM  uint32_t ELO        : 1;            /*!< [22..22] Error Logging Overflow                                           */
      __IM  uint32_t EP         : 1;            /*!< [23..23] Error Passive                                                    */
      __IM  uint32_t EW         : 1;            /*!< [24..24] Warning Status                                                   */
      __IM  uint32_t BO         : 1;            /*!< [25..25] Bus_Off Status                                                   */
      __IM  uint32_t WDI        : 1;            /*!< [26..26] Watchdog Interrupt                                               */
      __IM  uint32_t PEA        : 1;            /*!< [27..27] Protocol Error in Arbitration Phase (Nominal Bit Time
                                                     is used)                                                                  */
      __IM  uint32_t PED        : 1;            /*!< [28..28] Protocol Error in Data Phase (Data Bit Time is used)             */
      __IM  uint32_t ARA        : 1;            /*!< [29..29] Access to Reserved Address                                       */
            uint32_t            : 2;
    } FDCAN_IR_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_IE;                    /*!< (@ 0x00000054) FDCAN Interrupt Enable Register                            */
    
    struct {
      __IM  uint32_t RF0NE      : 1;            /*!< [0..0] Rx FIFO 0 New Message Enable                                       */
      __IM  uint32_t RF0WE      : 1;            /*!< [1..1] Rx FIFO 0 Full Enable                                              */
      __IM  uint32_t RF0FE      : 1;            /*!< [2..2] Rx FIFO 0 Full Enable                                              */
      __IM  uint32_t RF0LE      : 1;            /*!< [3..3] Rx FIFO 0 Message Lost Enable                                      */
      __IM  uint32_t RF1NE      : 1;            /*!< [4..4] Rx FIFO 1 New Message Enable                                       */
      __IM  uint32_t RF1WE      : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached Enable                                 */
      __IM  uint32_t RF1FE      : 1;            /*!< [6..6] Rx FIFO 1 Watermark Reached Enable                                 */
      __IM  uint32_t RF1LE      : 1;            /*!< [7..7] Rx FIFO 1 Message Lost Enable                                      */
      __IM  uint32_t HPME       : 1;            /*!< [8..8] High Priority Message Enable                                       */
      __IM  uint32_t TCE        : 1;            /*!< [9..9] Transmission Completed Enable                                      */
      __IM  uint32_t TCFE       : 1;            /*!< [10..10] Transmission Cancellation Finished Enable                        */
      __IM  uint32_t TEFE       : 1;            /*!< [11..11] Tx FIFO Empty Enable                                             */
      __IM  uint32_t TEFNE      : 1;            /*!< [12..12] Tx Event FIFO New Entry Enable                                   */
      __IM  uint32_t TEFWE      : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached Enable                           */
      __IM  uint32_t TEFFE      : 1;            /*!< [14..14] Tx Event FIFO Full Enable                                        */
      __IM  uint32_t TEFLE      : 1;            /*!< [15..15] Tx Event FIFO Element Lost Enable                                */
      __IM  uint32_t TSWE       : 1;            /*!< [16..16] Timestamp Wraparound Enable                                      */
      __IM  uint32_t MRAFE      : 1;            /*!< [17..17] Message RAM Access Failure Enable                                */
      __IM  uint32_t TOOE       : 1;            /*!< [18..18] Timeout Occurred Enable                                          */
      __IM  uint32_t DRXE       : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer Enable                     */
      __IM  uint32_t BECE       : 1;            /*!< [20..20] Bit Error Corrected Interrupt Enable                             */
      __IM  uint32_t BEUE       : 1;            /*!< [21..21] Bit Error Uncorrected Interrupt Enable                           */
      __IM  uint32_t ELOE       : 1;            /*!< [22..22] Error Logging Overflow Enable                                    */
      __IM  uint32_t EPE        : 1;            /*!< [23..23] Error Passive Enable                                             */
      __IM  uint32_t EWE        : 1;            /*!< [24..24] Warning Status Enable                                            */
      __IM  uint32_t BOE        : 1;            /*!< [25..25] Bus_Off Status Enable                                            */
      __IM  uint32_t WDIE       : 1;            /*!< [26..26] Watchdog Interrupt Enable                                        */
      __IM  uint32_t PEAE       : 1;            /*!< [27..27] Protocol Error in Arbitration Phase Enable                       */
      __IM  uint32_t PEDE       : 1;            /*!< [28..28] Protocol Error in Data Phase Enable                              */
      __IM  uint32_t ARAE       : 1;            /*!< [29..29] Access to Reserved Address Enable                                */
            uint32_t            : 2;
    } FDCAN_IE_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_ILS;                   /*!< (@ 0x00000058) FDCAN Interrupt Line Select Register                       */
    
    struct {
      __IM  uint32_t RF0NL      : 1;            /*!< [0..0] Rx FIFO 0 New Message Interrupt Line                               */
      __IM  uint32_t RF0WL      : 1;            /*!< [1..1] Rx FIFO 0 Watermark Reached Interrupt Line                         */
      __IM  uint32_t RF0FL      : 1;            /*!< [2..2] Rx FIFO 0 Full Interrupt Line                                      */
      __IM  uint32_t RF0LL      : 1;            /*!< [3..3] Rx FIFO 0 Message Lost Interrupt Line                              */
      __IM  uint32_t RF1NL      : 1;            /*!< [4..4] Rx FIFO 1 New Message Interrupt Line                               */
      __IM  uint32_t RF1WL      : 1;            /*!< [5..5] Rx FIFO 1 Watermark Reached Interrupt Line                         */
      __IM  uint32_t RF1FL      : 1;            /*!< [6..6] Rx FIFO 1 Full Interrupt Line                                      */
      __IM  uint32_t RF1LL      : 1;            /*!< [7..7] Rx FIFO 1 Message Lost Interrupt Line                              */
      __IM  uint32_t HPML       : 1;            /*!< [8..8] High Priority Message Interrupt Line                               */
      __IM  uint32_t TCL        : 1;            /*!< [9..9] Transmission Completed Interrupt Line                              */
      __IM  uint32_t TCFL       : 1;            /*!< [10..10] Transmission Cancellation Finished Interrupt Line                */
      __IM  uint32_t TEFL       : 1;            /*!< [11..11] Tx FIFO Empty Interrupt Line                                     */
      __IM  uint32_t TEFNL      : 1;            /*!< [12..12] Tx Event FIFO New Entry Interrupt Line                           */
      __IM  uint32_t TEFWL      : 1;            /*!< [13..13] Tx Event FIFO Watermark Reached Interrupt Line                   */
      __IM  uint32_t TEFFL      : 1;            /*!< [14..14] Tx Event FIFO Full Interrupt Line                                */
      __IM  uint32_t TEFLL      : 1;            /*!< [15..15] Tx Event FIFO Element Lost Interrupt Line                        */
      __IM  uint32_t TSWL       : 1;            /*!< [16..16] Timestamp Wraparound Interrupt Line                              */
      __IM  uint32_t MRAFL      : 1;            /*!< [17..17] Message RAM Access Failure Interrupt Line                        */
      __IM  uint32_t TOOL       : 1;            /*!< [18..18] Timeout Occurred Interrupt Line                                  */
      __IM  uint32_t DRXL       : 1;            /*!< [19..19] Message stored to Dedicated Rx Buffer Interrupt Line             */
      __IM  uint32_t BECL       : 1;            /*!< [20..20] Bit Error Corrected Interrupt Line                               */
      __IM  uint32_t BEUL       : 1;            /*!< [21..21] Bit Error Uncorrected Interrupt Line                             */
      __IM  uint32_t ELOL       : 1;            /*!< [22..22] Error Logging Overflow Interrupt Line                            */
      __IM  uint32_t EPL        : 1;            /*!< [23..23] Error Passive Interrupt Line                                     */
      __IM  uint32_t EWL        : 1;            /*!< [24..24] Warning Status Interrupt Line                                    */
      __IM  uint32_t BOL        : 1;            /*!< [25..25] Bus_Off Status                                                   */
      __IM  uint32_t WDIL       : 1;            /*!< [26..26] Watchdog Interrupt Line                                          */
      __IM  uint32_t PEAL       : 1;            /*!< [27..27] Protocol Error in Arbitration Phase Line                         */
      __IM  uint32_t PEDL       : 1;            /*!< [28..28] Protocol Error in Data Phase Line                                */
      __IM  uint32_t ARAL       : 1;            /*!< [29..29] Access to Reserved Address Line                                  */
            uint32_t            : 2;
    } FDCAN_ILS_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_ILE;                   /*!< (@ 0x0000005C) FDCAN Interrupt Line Enable Register                       */
    
    struct {
      __IOM uint32_t EINT0      : 1;            /*!< [0..0] Enable Interrupt Line 0                                            */
      __IOM uint32_t EINT1      : 1;            /*!< [1..1] Enable Interrupt Line 1                                            */
            uint32_t            : 30;
    } FDCAN_ILE_b;
  } ;
  __IM  uint32_t  RESERVED3[8];
  
  union {
    __IOM uint32_t FDCAN_GFC;                   /*!< (@ 0x00000080) FDCAN Global Filter Configuration Register                 */
    
    struct {
      __IOM uint32_t RRFE       : 1;            /*!< [0..0] Reject Remote Frames Extended                                      */
      __IOM uint32_t RRFS       : 1;            /*!< [1..1] Reject Remote Frames Standard                                      */
      __IOM uint32_t ANFE       : 2;            /*!< [3..2] Accept Non-matching Frames Extended                                */
      __IOM uint32_t ANFS       : 2;            /*!< [5..4] Accept Non-matching Frames Standard                                */
            uint32_t            : 26;
    } FDCAN_GFC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_SIDFC;                 /*!< (@ 0x00000084) FDCAN Standard ID Filter Configuration Register            */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t FLSSA      : 14;           /*!< [15..2] Filter List Standard Start Address                                */
      __IOM uint32_t LSS        : 8;            /*!< [23..16] List Size Standard                                               */
            uint32_t            : 8;
    } FDCAN_SIDFC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_XIDFC;                 /*!< (@ 0x00000088) FDCAN Extended ID Filter Configuration Register            */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t FLESA      : 14;           /*!< [15..2] Filter List Standard Start Address                                */
      __IOM uint32_t LSE        : 8;            /*!< [23..16] List Size Extended                                               */
            uint32_t            : 8;
    } FDCAN_XIDFC_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t FDCAN_XIDAM;                 /*!< (@ 0x00000090) FDCAN Extended ID and Mask Register                        */
    
    struct {
      __IOM uint32_t EIDM       : 29;           /*!< [28..0] Extended ID Mask                                                  */
            uint32_t            : 3;
    } FDCAN_XIDAM_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_HPMS;                  /*!< (@ 0x00000094) FDCAN High Priority Message Status Register                */
    
    struct {
      __IM  uint32_t BIDX       : 6;            /*!< [5..0] Buffer Index                                                       */
      __IM  uint32_t MSI        : 2;            /*!< [7..6] Message Storage Indicator                                          */
      __IM  uint32_t FIDX       : 7;            /*!< [14..8] Filter Index                                                      */
      __IM  uint32_t FLST       : 1;            /*!< [15..15] Filter List                                                      */
            uint32_t            : 16;
    } FDCAN_HPMS_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_NDAT1;                 /*!< (@ 0x00000098) FDCAN New Data 1 Register                                  */
    
    struct {
      __IM  uint32_t ND0        : 1;            /*!< [0..0] New data                                                           */
      __IM  uint32_t ND1        : 1;            /*!< [1..1] New data                                                           */
      __IM  uint32_t ND2        : 1;            /*!< [2..2] New data                                                           */
      __IM  uint32_t ND3        : 1;            /*!< [3..3] New data                                                           */
      __IM  uint32_t ND4        : 1;            /*!< [4..4] New data                                                           */
      __IM  uint32_t ND5        : 1;            /*!< [5..5] New data                                                           */
      __IM  uint32_t ND6        : 1;            /*!< [6..6] New data                                                           */
      __IM  uint32_t ND7        : 1;            /*!< [7..7] New data                                                           */
      __IM  uint32_t ND8        : 1;            /*!< [8..8] New data                                                           */
      __IM  uint32_t ND9        : 1;            /*!< [9..9] New data                                                           */
      __IM  uint32_t ND10       : 1;            /*!< [10..10] New data                                                         */
      __IM  uint32_t ND11       : 1;            /*!< [11..11] New data                                                         */
      __IM  uint32_t ND12       : 1;            /*!< [12..12] New data                                                         */
      __IM  uint32_t ND13       : 1;            /*!< [13..13] New data                                                         */
      __IM  uint32_t ND14       : 1;            /*!< [14..14] New data                                                         */
      __IM  uint32_t ND15       : 1;            /*!< [15..15] New data                                                         */
      __IM  uint32_t ND16       : 1;            /*!< [16..16] New data                                                         */
      __IM  uint32_t ND17       : 1;            /*!< [17..17] New data                                                         */
      __IM  uint32_t ND18       : 1;            /*!< [18..18] New data                                                         */
      __IM  uint32_t ND19       : 1;            /*!< [19..19] New data                                                         */
      __IM  uint32_t ND20       : 1;            /*!< [20..20] New data                                                         */
      __IM  uint32_t ND21       : 1;            /*!< [21..21] New data                                                         */
      __IM  uint32_t ND22       : 1;            /*!< [22..22] New data                                                         */
      __IM  uint32_t ND23       : 1;            /*!< [23..23] New data                                                         */
      __IM  uint32_t ND24       : 1;            /*!< [24..24] New data                                                         */
      __IM  uint32_t ND25       : 1;            /*!< [25..25] New data                                                         */
      __IM  uint32_t ND26       : 1;            /*!< [26..26] New data                                                         */
      __IM  uint32_t ND27       : 1;            /*!< [27..27] New data                                                         */
      __IM  uint32_t ND28       : 1;            /*!< [28..28] New data                                                         */
      __IM  uint32_t ND29       : 1;            /*!< [29..29] New data                                                         */
      __IM  uint32_t ND30       : 1;            /*!< [30..30] New data                                                         */
      __IM  uint32_t ND31       : 1;            /*!< [31..31] New data                                                         */
    } FDCAN_NDAT1_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_NDAT2;                 /*!< (@ 0x0000009C) FDCAN New Data 2 Register                                  */
    
    struct {
      __IM  uint32_t ND32       : 1;            /*!< [0..0] New data                                                           */
      __IM  uint32_t ND33       : 1;            /*!< [1..1] New data                                                           */
      __IM  uint32_t ND34       : 1;            /*!< [2..2] New data                                                           */
      __IM  uint32_t ND35       : 1;            /*!< [3..3] New data                                                           */
      __IM  uint32_t ND36       : 1;            /*!< [4..4] New data                                                           */
      __IM  uint32_t ND37       : 1;            /*!< [5..5] New data                                                           */
      __IM  uint32_t ND38       : 1;            /*!< [6..6] New data                                                           */
      __IM  uint32_t ND39       : 1;            /*!< [7..7] New data                                                           */
      __IM  uint32_t ND40       : 1;            /*!< [8..8] New data                                                           */
      __IM  uint32_t ND41       : 1;            /*!< [9..9] New data                                                           */
      __IM  uint32_t ND42       : 1;            /*!< [10..10] New data                                                         */
      __IM  uint32_t ND43       : 1;            /*!< [11..11] New data                                                         */
      __IM  uint32_t ND44       : 1;            /*!< [12..12] New data                                                         */
      __IM  uint32_t ND45       : 1;            /*!< [13..13] New data                                                         */
      __IM  uint32_t ND46       : 1;            /*!< [14..14] New data                                                         */
      __IM  uint32_t ND47       : 1;            /*!< [15..15] New data                                                         */
      __IM  uint32_t ND48       : 1;            /*!< [16..16] New data                                                         */
      __IM  uint32_t ND49       : 1;            /*!< [17..17] New data                                                         */
      __IM  uint32_t ND50       : 1;            /*!< [18..18] New data                                                         */
      __IM  uint32_t ND51       : 1;            /*!< [19..19] New data                                                         */
      __IM  uint32_t ND52       : 1;            /*!< [20..20] New data                                                         */
      __IM  uint32_t ND53       : 1;            /*!< [21..21] New data                                                         */
      __IM  uint32_t ND54       : 1;            /*!< [22..22] New data                                                         */
      __IM  uint32_t ND55       : 1;            /*!< [23..23] New data                                                         */
      __IM  uint32_t ND56       : 1;            /*!< [24..24] New data                                                         */
      __IM  uint32_t ND57       : 1;            /*!< [25..25] New data                                                         */
      __IM  uint32_t ND58       : 1;            /*!< [26..26] New data                                                         */
      __IM  uint32_t ND59       : 1;            /*!< [27..27] New data                                                         */
      __IM  uint32_t ND60       : 1;            /*!< [28..28] New data                                                         */
      __IM  uint32_t ND61       : 1;            /*!< [29..29] New data                                                         */
      __IM  uint32_t ND62       : 1;            /*!< [30..30] New data                                                         */
      __IM  uint32_t ND63       : 1;            /*!< [31..31] New data                                                         */
    } FDCAN_NDAT2_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF0C;                 /*!< (@ 0x000000A0) FDCAN Rx FIFO 0 Configuration Register                     */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t F0SA       : 14;           /*!< [15..2] Rx FIFO 0 Start Address                                           */
      __IOM uint32_t F0S        : 8;            /*!< [23..16] Rx FIFO 0 Size                                                   */
      __IOM uint32_t F0WM       : 8;            /*!< [31..24] FIFO 0 Watermark                                                 */
    } FDCAN_RXF0C_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF0S;                 /*!< (@ 0x000000A4) FDCAN Rx FIFO 0 Status Register                            */
    
    struct {
      __IOM uint32_t F0FL       : 7;            /*!< [6..0] Rx FIFO 0 Fill Level                                               */
            uint32_t            : 1;
      __IOM uint32_t F0G        : 6;            /*!< [13..8] Rx FIFO 0 Get Index                                               */
            uint32_t            : 2;
      __IOM uint32_t F0P        : 6;            /*!< [21..16] Rx FIFO 0 Put Index                                              */
            uint32_t            : 2;
      __IOM uint32_t F0F        : 1;            /*!< [24..24] Rx FIFO 0 Full                                                   */
      __IOM uint32_t RF0L       : 1;            /*!< [25..25] Rx FIFO 0 Message Lost                                           */
            uint32_t            : 6;
    } FDCAN_RXF0S_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF0A;                 /*!< (@ 0x000000A8) CAN Rx FIFO 0 Acknowledge Register                         */
    
    struct {
      __IOM uint32_t FA01       : 6;            /*!< [5..0] Rx FIFO 0 Acknowledge Index                                        */
            uint32_t            : 26;
    } FDCAN_RXF0A_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXBC;                  /*!< (@ 0x000000AC) FDCAN Rx Buffer Configuration Register                     */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t RBSA       : 14;           /*!< [15..2] Rx Buffer Start Address                                           */
            uint32_t            : 16;
    } FDCAN_RXBC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF1C;                 /*!< (@ 0x000000B0) FDCAN Rx FIFO 1 Configuration Register                     */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t F1SA       : 14;           /*!< [15..2] Rx FIFO 1 Start Address                                           */
      __IOM uint32_t F1S        : 7;            /*!< [22..16] Rx FIFO 1 Size                                                   */
            uint32_t            : 1;
      __IOM uint32_t F1WM       : 7;            /*!< [30..24] Rx FIFO 1 Watermark                                              */
            uint32_t            : 1;
    } FDCAN_RXF1C_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF1S;                 /*!< (@ 0x000000B4) FDCAN Rx FIFO 1 Status Register                            */
    
    struct {
      __IOM uint32_t F1FL       : 7;            /*!< [6..0] Rx FIFO 1 Fill Level                                               */
            uint32_t            : 1;
      __IOM uint32_t F1GI       : 7;            /*!< [14..8] Rx FIFO 1 Get Index                                               */
            uint32_t            : 1;
      __IOM uint32_t F1PI       : 7;            /*!< [22..16] Rx FIFO 1 Put Index                                              */
            uint32_t            : 1;
      __IOM uint32_t F1F        : 1;            /*!< [24..24] Rx FIFO 1 Full                                                   */
      __IOM uint32_t RF1L       : 1;            /*!< [25..25] Rx FIFO 1 Message Lost                                           */
            uint32_t            : 4;
      __IOM uint32_t DMS        : 2;            /*!< [31..30] Debug Message Status                                             */
    } FDCAN_RXF1S_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXF1A;                 /*!< (@ 0x000000B8) FDCAN Rx FIFO 1 Acknowledge Register                       */
    
    struct {
      __IOM uint32_t F1AI       : 6;            /*!< [5..0] Rx FIFO 1 Acknowledge Index                                        */
            uint32_t            : 26;
    } FDCAN_RXF1A_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_RXESC;                 /*!< (@ 0x000000BC) FDCAN Rx Buffer Element Size Configuration Register        */
    
    struct {
      __IOM uint32_t F0DS       : 3;            /*!< [2..0] Rx FIFO 1 Data Field Size:                                         */
            uint32_t            : 1;
      __IOM uint32_t F1DS       : 3;            /*!< [6..4] Rx FIFO 0 Data Field Size:                                         */
            uint32_t            : 1;
      __IOM uint32_t RBDS       : 3;            /*!< [10..8] Rx Buffer Data Field Size:                                        */
            uint32_t            : 21;
    } FDCAN_RXESC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBC;                  /*!< (@ 0x000000C0) FDCAN Tx Buffer Configuration Register                     */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TBSA       : 14;           /*!< [15..2] Tx Buffers Start Address                                          */
      __IOM uint32_t NDTB       : 6;            /*!< [21..16] Number of Dedicated Transmit Buffers                             */
            uint32_t            : 2;
      __IOM uint32_t TFQS       : 6;            /*!< [29..24] Transmit FIFO/Queue Size                                         */
      __IOM uint32_t TFQM       : 1;            /*!< [30..30] Tx FIFO/Queue Mode                                               */
            uint32_t            : 1;
    } FDCAN_TXBC_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TXFQS;                 /*!< (@ 0x000000C4) FDCAN Tx FIFO/Queue Status Register                        */
    
    struct {
      __IM  uint32_t TFFL       : 6;            /*!< [5..0] Tx FIFO Free Level                                                 */
            uint32_t            : 2;
      __IM  uint32_t TFGI       : 5;            /*!< [12..8] TFGI                                                              */
            uint32_t            : 3;
      __IM  uint32_t TFQPI      : 5;            /*!< [20..16] Tx FIFO/Queue Put Index                                          */
      __IM  uint32_t TFQF       : 1;            /*!< [21..21] Tx FIFO/Queue Full                                               */
            uint32_t            : 10;
    } FDCAN_TXFQS_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXESC;                 /*!< (@ 0x000000C8) FDCAN Tx Buffer Element Size Configuration Register        */
    
    struct {
      __IOM uint32_t TBDS       : 3;            /*!< [2..0] Tx Buffer Data Field Size:                                         */
            uint32_t            : 29;
    } FDCAN_TXESC_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TXBRP;                 /*!< (@ 0x000000CC) FDCAN Tx Buffer Request Pending Register                   */
    
    struct {
      __IM  uint32_t TRP        : 32;           /*!< [31..0] Transmission Request Pending                                      */
    } FDCAN_TXBRP_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBAR;                 /*!< (@ 0x000000D0) FDCAN Tx Buffer Add Request Register                       */
    
    struct {
      __IOM uint32_t AR         : 32;           /*!< [31..0] Add Request                                                       */
    } FDCAN_TXBAR_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBCR;                 /*!< (@ 0x000000D4) FDCAN Tx Buffer Cancellation Request Register              */
    
    struct {
      __IOM uint32_t CR         : 32;           /*!< [31..0] Cancellation Request                                              */
    } FDCAN_TXBCR_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBTO;                 /*!< (@ 0x000000D8) FDCAN Tx Buffer Transmission Occurred Register             */
    
    struct {
      __IOM uint32_t TO         : 32;           /*!< [31..0] Transmission Occurred.                                            */
    } FDCAN_TXBTO_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TXBCF;                 /*!< (@ 0x000000DC) FDCAN Tx Buffer Cancellation Finished Register             */
    
    struct {
      __IM  uint32_t CF         : 32;           /*!< [31..0] Cancellation Finished                                             */
    } FDCAN_TXBCF_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBTIE;                /*!< (@ 0x000000E0) FDCAN Tx Buffer Transmission Interrupt Enable
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t TIE        : 32;           /*!< [31..0] Transmission Interrupt Enable                                     */
    } FDCAN_TXBTIE_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXBCIE;                /*!< (@ 0x000000E4) FDCAN Tx Buffer Cancellation Finished Interrupt
                                                                    Enable Register                                            */
    
    struct {
      __IOM uint32_t CF         : 32;           /*!< [31..0] Cancellation Finished Interrupt Enable                            */
    } FDCAN_TXBCIE_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t FDCAN_TXEFC;                 /*!< (@ 0x000000F0) FDCAN Tx Event FIFO Configuration Register                 */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t EFSA       : 14;           /*!< [15..2] Event FIFO Start Address                                          */
      __IOM uint32_t EFS        : 6;            /*!< [21..16] Event FIFO Size                                                  */
            uint32_t            : 2;
      __IOM uint32_t EFWM       : 6;            /*!< [29..24] Event FIFO Watermark                                             */
            uint32_t            : 2;
    } FDCAN_TXEFC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXEFS;                 /*!< (@ 0x000000F4) FDCAN Tx Event FIFO Status Register                        */
    
    struct {
      __IOM uint32_t EFFL       : 6;            /*!< [5..0] Event FIFO Fill Level                                              */
            uint32_t            : 2;
      __IOM uint32_t EFGI       : 5;            /*!< [12..8] Event FIFO Get Index.                                             */
            uint32_t            : 11;
      __IOM uint32_t EFF        : 1;            /*!< [24..24] Event FIFO Full.                                                 */
      __IOM uint32_t TEFL       : 1;            /*!< [25..25] Tx Event FIFO Element Lost.                                      */
            uint32_t            : 6;
    } FDCAN_TXEFS_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TXEFA;                 /*!< (@ 0x000000F8) FDCAN Tx Event FIFO Acknowledge Register                   */
    
    struct {
      __IOM uint32_t EFAI       : 5;            /*!< [4..0] Event FIFO Acknowledge Index                                       */
            uint32_t            : 27;
    } FDCAN_TXEFA_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t FDCAN_TTTMC;                 /*!< (@ 0x00000100) FDCAN TT Trigger Memory Configuration Register             */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TMSA       : 14;           /*!< [15..2] Trigger Memory Start Address                                      */
      __IOM uint32_t TME        : 7;            /*!< [22..16] Trigger Memory Elements                                          */
            uint32_t            : 9;
    } FDCAN_TTTMC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTRMC;                 /*!< (@ 0x00000104) FDCAN TT Reference Message Configuration Register          */
    
    struct {
      __IOM uint32_t RID        : 29;           /*!< [28..0] Reference Identifier.                                             */
            uint32_t            : 1;
      __IOM uint32_t XTD        : 1;            /*!< [30..30] Extended Identifier                                              */
      __IOM uint32_t RMPS       : 1;            /*!< [31..31] Reference Message Payload Select                                 */
    } FDCAN_TTRMC_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTOCF;                 /*!< (@ 0x00000108) FDCAN TT Operation Configuration Register                  */
    
    struct {
      __IOM uint32_t OM         : 2;            /*!< [1..0] Operation Mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t GEN        : 1;            /*!< [3..3] Gap Enable                                                         */
      __IOM uint32_t TM         : 1;            /*!< [4..4] Time Master                                                        */
      __IOM uint32_t LDSDL      : 3;            /*!< [7..5] LD of Synchronization Deviation Limit                              */
      __IOM uint32_t IRTO       : 7;            /*!< [14..8] Initial Reference Trigger Offset                                  */
      __IOM uint32_t EECS       : 1;            /*!< [15..15] Enable External Clock Synchronization                            */
      __IOM uint32_t AWL        : 8;            /*!< [23..16] Application Watchdog Limit                                       */
      __IOM uint32_t EGTF       : 1;            /*!< [24..24] Enable Global Time Filtering                                     */
      __IOM uint32_t ECC        : 1;            /*!< [25..25] Enable Clock Calibration                                         */
      __IOM uint32_t EVTP       : 1;            /*!< [26..26] Event Trigger Polarity                                           */
            uint32_t            : 5;
    } FDCAN_TTOCF_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTMLM;                 /*!< (@ 0x0000010C) FDCAN TT Matrix Limits Register                            */
    
    struct {
      __IOM uint32_t CCM        : 6;            /*!< [5..0] Cycle Count Max                                                    */
      __IOM uint32_t CSS        : 2;            /*!< [7..6] Cycle Start Synchronization                                        */
      __IOM uint32_t TXEW       : 4;            /*!< [11..8] Tx Enable Window                                                  */
            uint32_t            : 4;
      __IOM uint32_t ENTT       : 12;           /*!< [27..16] Expected Number of Tx Triggers                                   */
            uint32_t            : 4;
    } FDCAN_TTMLM_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TURCF;                 /*!< (@ 0x00000110) FDCAN TUR Configuration Register                           */
    
    struct {
      __IOM uint32_t NCL        : 16;           /*!< [15..0] Numerator Configuration Low.                                      */
      __IOM uint32_t DC         : 14;           /*!< [29..16] Denominator Configuration.                                       */
            uint32_t            : 1;
      __IOM uint32_t ELT        : 1;            /*!< [31..31] Enable Local Time                                                */
    } FDCAN_TURCF_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTOCN;                 /*!< (@ 0x00000114) FDCAN TT Operation Control Register                        */
    
    struct {
      __IOM uint32_t SGT        : 1;            /*!< [0..0] Set Global time                                                    */
      __IOM uint32_t ECS        : 1;            /*!< [1..1] External Clock Synchronization                                     */
      __IOM uint32_t SWP        : 1;            /*!< [2..2] Stop Watch Polarity                                                */
      __IOM uint32_t SWS        : 2;            /*!< [4..3] Stop Watch Source.                                                 */
      __IOM uint32_t RTIE       : 1;            /*!< [5..5] Register Time Mark Interrupt Pulse Enable                          */
      __IOM uint32_t TMC        : 2;            /*!< [7..6] Register Time Mark Compare                                         */
      __IOM uint32_t TTIE       : 1;            /*!< [8..8] Trigger Time Mark Interrupt Pulse Enable                           */
      __IOM uint32_t GCS        : 1;            /*!< [9..9] Gap Control Select                                                 */
      __IOM uint32_t FGP        : 1;            /*!< [10..10] Finish Gap.                                                      */
      __IOM uint32_t TMG        : 1;            /*!< [11..11] Time Mark Gap                                                    */
      __IOM uint32_t NIG        : 1;            /*!< [12..12] Next is Gap                                                      */
      __IOM uint32_t ESCN       : 1;            /*!< [13..13] External Synchronization Control                                 */
            uint32_t            : 1;
      __IOM uint32_t LCKC       : 1;            /*!< [15..15] TT Operation Control Register Locked                             */
            uint32_t            : 16;
    } FDCAN_TTOCN_b;
  } ;
  
  union {
    __IOM uint32_t CAN_TTGTP;                   /*!< (@ 0x00000118) FDCAN TT Global Time Preset Register                       */
    
    struct {
      __IOM uint32_t NCL        : 16;           /*!< [15..0] Time Preset                                                       */
      __IOM uint32_t CTP        : 16;           /*!< [31..16] Cycle Time Target Phase                                          */
    } CAN_TTGTP_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTTMK;                 /*!< (@ 0x0000011C) FDCAN TT Time Mark Register                                */
    
    struct {
      __IOM uint32_t TM         : 16;           /*!< [15..0] Time Mark                                                         */
      __IOM uint32_t TICC       : 7;            /*!< [22..16] Time Mark Cycle Code                                             */
            uint32_t            : 8;
      __IOM uint32_t LCKM       : 1;            /*!< [31..31] TT Time Mark Register Locked                                     */
    } FDCAN_TTTMK_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTIR;                  /*!< (@ 0x00000120) FDCAN TT Interrupt Register                                */
    
    struct {
      __IOM uint32_t SBC        : 1;            /*!< [0..0] Start of Basic Cycle                                               */
      __IOM uint32_t SMC        : 1;            /*!< [1..1] Start of Matrix Cycle                                              */
      __IOM uint32_t CSM        : 1;            /*!< [2..2] Change of Synchronization Mode                                     */
      __IOM uint32_t SOG        : 1;            /*!< [3..3] Start of Gap                                                       */
      __IOM uint32_t RTMI       : 1;            /*!< [4..4] Register Time Mark Interrupt.                                      */
      __IOM uint32_t TTMI       : 1;            /*!< [5..5] Trigger Time Mark Event Internal                                   */
      __IOM uint32_t SWE        : 1;            /*!< [6..6] Stop Watch Event                                                   */
      __IOM uint32_t GTW        : 1;            /*!< [7..7] Global Time Wrap                                                   */
      __IOM uint32_t GTD        : 1;            /*!< [8..8] Global Time Discontinuity                                          */
      __IOM uint32_t GTE        : 1;            /*!< [9..9] Global Time Error                                                  */
      __IOM uint32_t TXU        : 1;            /*!< [10..10] Tx Count Underflow                                               */
      __IOM uint32_t TXO        : 1;            /*!< [11..11] Tx Count Overflow                                                */
      __IOM uint32_t SE1        : 1;            /*!< [12..12] Scheduling Error 1                                               */
      __IOM uint32_t SE2        : 1;            /*!< [13..13] Scheduling Error 2                                               */
      __IOM uint32_t ELC        : 1;            /*!< [14..14] Error Level Changed.                                             */
      __IOM uint32_t IWTG       : 1;            /*!< [15..15] Initialization Watch Trigger                                     */
      __IOM uint32_t WT         : 1;            /*!< [16..16] Watch Trigger                                                    */
      __IOM uint32_t AW         : 1;            /*!< [17..17] Application Watchdog                                             */
      __IOM uint32_t CER        : 1;            /*!< [18..18] Configuration Error                                              */
            uint32_t            : 13;
    } FDCAN_TTIR_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTIE;                  /*!< (@ 0x00000124) FDCAN TT Interrupt Enable Register                         */
    
    struct {
      __IOM uint32_t SBCE       : 1;            /*!< [0..0] Start of Basic Cycle Interrupt Enable                              */
      __IOM uint32_t SMCE       : 1;            /*!< [1..1] Start of Matrix Cycle Interrupt Enable                             */
      __IOM uint32_t CSME       : 1;            /*!< [2..2] Change of Synchronization Mode Interrupt Enable                    */
      __IOM uint32_t SOGE       : 1;            /*!< [3..3] Start of Gap Interrupt Enable                                      */
      __IOM uint32_t RTMIE      : 1;            /*!< [4..4] Register Time Mark Interrupt Enable                                */
      __IOM uint32_t TTMIE      : 1;            /*!< [5..5] Trigger Time Mark Event Internal Interrupt Enable                  */
      __IOM uint32_t SWEE       : 1;            /*!< [6..6] Stop Watch Event Interrupt Enable                                  */
      __IOM uint32_t GTWE       : 1;            /*!< [7..7] Global Time Wrap Interrupt Enable                                  */
      __IOM uint32_t GTDE       : 1;            /*!< [8..8] Global Time Discontinuity Interrupt Enable                         */
      __IOM uint32_t GTEE       : 1;            /*!< [9..9] Global Time Error Interrupt Enable                                 */
      __IOM uint32_t TXUE       : 1;            /*!< [10..10] Tx Count Underflow Interrupt Enable                              */
      __IOM uint32_t TXOE       : 1;            /*!< [11..11] Tx Count Overflow Interrupt Enable                               */
      __IOM uint32_t SE1E       : 1;            /*!< [12..12] Scheduling Error 1 Interrupt Enable                              */
      __IOM uint32_t SE2E       : 1;            /*!< [13..13] Scheduling Error 2 Interrupt Enable                              */
      __IOM uint32_t ELCE       : 1;            /*!< [14..14] Change Error Level Interrupt Enable                              */
      __IOM uint32_t IWTGE      : 1;            /*!< [15..15] Initialization Watch Trigger Interrupt Enable                    */
      __IOM uint32_t WTE        : 1;            /*!< [16..16] Watch Trigger Interrupt Enable                                   */
      __IOM uint32_t AWE        : 1;            /*!< [17..17] Application Watchdog Interrupt Enable                            */
      __IOM uint32_t CERE       : 1;            /*!< [18..18] Configuration Error Interrupt Enable                             */
            uint32_t            : 13;
    } FDCAN_TTIE_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTILS;                 /*!< (@ 0x00000128) FDCAN TT Interrupt Line Select Register                    */
    
    struct {
      __IOM uint32_t SBCL       : 1;            /*!< [0..0] Start of Basic Cycle Interrupt Line                                */
      __IOM uint32_t SMCL       : 1;            /*!< [1..1] Start of Matrix Cycle Interrupt Line                               */
      __IOM uint32_t CSML       : 1;            /*!< [2..2] Change of Synchronization Mode Interrupt Line                      */
      __IOM uint32_t SOGL       : 1;            /*!< [3..3] Start of Gap Interrupt Line                                        */
      __IOM uint32_t RTMIL      : 1;            /*!< [4..4] Register Time Mark Interrupt Line                                  */
      __IOM uint32_t TTMIL      : 1;            /*!< [5..5] Trigger Time Mark Event Internal Interrupt Line                    */
      __IOM uint32_t SWEL       : 1;            /*!< [6..6] Stop Watch Event Interrupt Line                                    */
      __IOM uint32_t GTWL       : 1;            /*!< [7..7] Global Time Wrap Interrupt Line                                    */
      __IOM uint32_t GTDL       : 1;            /*!< [8..8] Global Time Discontinuity Interrupt Line                           */
      __IOM uint32_t GTEL       : 1;            /*!< [9..9] Global Time Error Interrupt Line                                   */
      __IOM uint32_t TXUL       : 1;            /*!< [10..10] Tx Count Underflow Interrupt Line                                */
      __IOM uint32_t TXOL       : 1;            /*!< [11..11] Tx Count Overflow Interrupt Line                                 */
      __IOM uint32_t SE1L       : 1;            /*!< [12..12] Scheduling Error 1 Interrupt Line                                */
      __IOM uint32_t SE2L       : 1;            /*!< [13..13] Scheduling Error 2 Interrupt Line                                */
      __IOM uint32_t ELCL       : 1;            /*!< [14..14] Change Error Level Interrupt Line                                */
      __IOM uint32_t IWTGL      : 1;            /*!< [15..15] Initialization Watch Trigger Interrupt Line                      */
      __IOM uint32_t WTL        : 1;            /*!< [16..16] Watch Trigger Interrupt Line                                     */
      __IOM uint32_t AWL        : 1;            /*!< [17..17] Application Watchdog Interrupt Line                              */
      __IOM uint32_t CERL       : 1;            /*!< [18..18] Configuration Error Interrupt Line                               */
            uint32_t            : 13;
    } FDCAN_TTILS_b;
  } ;
  
  union {
    __IOM uint32_t FDCAN_TTOST;                 /*!< (@ 0x0000012C) FDCAN TT Operation Status Register                         */
    
    struct {
      __IOM uint32_t EL         : 2;            /*!< [1..0] Error Level                                                        */
      __IOM uint32_t MS         : 2;            /*!< [3..2] Master State.                                                      */
      __IOM uint32_t SYS        : 2;            /*!< [5..4] Synchronization State                                              */
      __IOM uint32_t GTP        : 1;            /*!< [6..6] Quality of Global Time Phase                                       */
      __IOM uint32_t QCS        : 1;            /*!< [7..7] Quality of Clock Speed                                             */
      __IOM uint32_t RTO        : 8;            /*!< [15..8] Reference Trigger Offset                                          */
            uint32_t            : 6;
      __IOM uint32_t WGTD       : 1;            /*!< [22..22] Wait for Global Time Discontinuity                               */
      __IOM uint32_t GFI        : 1;            /*!< [23..23] Gap Finished Indicator.                                          */
      __IOM uint32_t TMP        : 3;            /*!< [26..24] Time Master Priority                                             */
      __IOM uint32_t GSI        : 1;            /*!< [27..27] Gap Started Indicator.                                           */
      __IOM uint32_t WFE        : 1;            /*!< [28..28] Wait for Event                                                   */
      __IOM uint32_t AWE        : 1;            /*!< [29..29] Application Watchdog Event                                       */
      __IOM uint32_t WECS       : 1;            /*!< [30..30] Wait for External Clock Synchronization                          */
      __IOM uint32_t SPL        : 1;            /*!< [31..31] Schedule Phase Lock                                              */
    } FDCAN_TTOST_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TURNA;                 /*!< (@ 0x00000130) FDCAN TUR Numerator Actual Register                        */
    
    struct {
      __IM  uint32_t NAV        : 18;           /*!< [17..0] Numerator Actual Value                                            */
            uint32_t            : 14;
    } FDCAN_TURNA_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TTLGT;                 /*!< (@ 0x00000134) FDCAN TT Local and Global Time Register                    */
    
    struct {
      __IM  uint32_t LT         : 16;           /*!< [15..0] Local Time                                                        */
      __IM  uint32_t GT         : 16;           /*!< [31..16] Global Time                                                      */
    } FDCAN_TTLGT_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TTCTC;                 /*!< (@ 0x00000138) FDCAN TT Cycle Time and Count Register                     */
    
    struct {
      __IM  uint32_t CT         : 16;           /*!< [15..0] Cycle Time                                                        */
      __IM  uint32_t CC         : 6;            /*!< [21..16] Cycle Count                                                      */
            uint32_t            : 10;
    } FDCAN_TTCTC_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TTCPT;                 /*!< (@ 0x0000013C) FDCAN TT Capture Time Register                             */
    
    struct {
      __IM  uint32_t CT         : 6;            /*!< [5..0] Cycle Count Value                                                  */
            uint32_t            : 10;
      __IM  uint32_t SWV        : 16;           /*!< [31..16] Stop Watch Value                                                 */
    } FDCAN_TTCPT_b;
  } ;
  
  union {
    __IM  uint32_t FDCAN_TTCSM;                 /*!< (@ 0x00000140) FDCAN TT Cycle Sync Mark Register                          */
    
    struct {
      __IM  uint32_t CSM        : 16;           /*!< [15..0] Cycle Sync Mark                                                   */
            uint32_t            : 16;
    } FDCAN_TTCSM_b;
  } ;
  __IM  uint32_t  RESERVED7[111];
  
  union {
    __IOM uint32_t FDCAN_TTTS;                  /*!< (@ 0x00000300) FDCAN TT Trigger Select Register                           */
    
    struct {
      __IOM uint32_t SWTDEL     : 2;            /*!< [1..0] Stop watch trigger input selection                                 */
            uint32_t            : 2;
      __IOM uint32_t EVTSEL     : 2;            /*!< [5..4] Event trigger input selection                                      */
            uint32_t            : 26;
    } FDCAN_TTTS_b;
  } ;
} FDCAN1_Type;                                  /*!< Size = 772 (0x304)                                                        */



/* =========================================================================================================================== */
/* ================                                          CAN_CCU                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CCU registers (CAN_CCU)
  */

typedef struct {                                /*!< (@ 0x4000A800) CAN_CCU Structure                                          */
  
  union {
    __IOM uint32_t CREL;                        /*!< (@ 0x00000000) Clock Calibration Unit Core Release Register               */
    
    struct {
      __IOM uint32_t DAY        : 8;            /*!< [7..0] Time Stamp Day                                                     */
      __IOM uint32_t MON        : 8;            /*!< [15..8] Time Stamp Month                                                  */
      __IOM uint32_t YEAR       : 4;            /*!< [19..16] Time Stamp Year                                                  */
      __IOM uint32_t SUBSTEP    : 4;            /*!< [23..20] Sub-step of Core Release                                         */
      __IOM uint32_t STEP       : 4;            /*!< [27..24] Step of Core Release                                             */
      __IOM uint32_t REL        : 4;            /*!< [31..28] Core Release                                                     */
    } CREL_b;
  } ;
  
  union {
    __IOM uint32_t CCFG;                        /*!< (@ 0x00000004) Calibration Configuration Register                         */
    
    struct {
      __IOM uint32_t TQBT       : 5;            /*!< [4..0] Time Quanta per Bit Time                                           */
            uint32_t            : 1;
      __IOM uint32_t BCC        : 1;            /*!< [6..6] Bypass Clock Calibration                                           */
      __IOM uint32_t CFL        : 1;            /*!< [7..7] Calibration Field Length                                           */
      __IOM uint32_t OCPM       : 8;            /*!< [15..8] Oscillator Clock Periods Minimum                                  */
      __IOM uint32_t CDIV       : 4;            /*!< [19..16] Clock Divider                                                    */
            uint32_t            : 11;
      __IOM uint32_t SWR        : 1;            /*!< [31..31] Software Reset                                                   */
    } CCFG_b;
  } ;
  
  union {
    __IOM uint32_t CSTAT;                       /*!< (@ 0x00000008) Calibration Status Register                                */
    
    struct {
      __IOM uint32_t OCPC       : 18;           /*!< [17..0] Oscillator Clock Period Counter                                   */
      __IOM uint32_t TQC        : 11;           /*!< [28..18] Time Quanta Counter                                              */
            uint32_t            : 1;
      __IOM uint32_t CALS       : 2;            /*!< [31..30] Calibration State                                                */
    } CSTAT_b;
  } ;
  
  union {
    __IOM uint32_t CWD;                         /*!< (@ 0x0000000C) Calibration Watchdog Register                              */
    
    struct {
      __IOM uint32_t WDC        : 16;           /*!< [15..0] WDC                                                               */
      __IOM uint32_t WDV        : 16;           /*!< [31..16] WDV                                                              */
    } CWD_b;
  } ;
  
  union {
    __IOM uint32_t IR;                          /*!< (@ 0x00000010) Clock Calibration Unit Interrupt Register                  */
    
    struct {
      __IOM uint32_t CWE        : 1;            /*!< [0..0] Calibration Watchdog Event                                         */
      __IOM uint32_t CSC        : 1;            /*!< [1..1] Calibration State Changed                                          */
            uint32_t            : 30;
    } IR_b;
  } ;
  
  union {
    __IOM uint32_t IE;                          /*!< (@ 0x00000014) Clock Calibration Unit Interrupt Enable Register           */
    
    struct {
      __IOM uint32_t CWEE       : 1;            /*!< [0..0] Calibration Watchdog Event Enable                                  */
      __IOM uint32_t CSCE       : 1;            /*!< [1..1] Calibration State Changed Enable                                   */
            uint32_t            : 30;
    } IE_b;
  } ;
} CAN_CCU_Type;                                 /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           MDIOS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Management data input/output slave (MDIOS)
  */

typedef struct {                                /*!< (@ 0x40009400) MDIOS Structure                                            */
  
  union {
    __IOM uint32_t MDIOS_CR;                    /*!< (@ 0x00000000) MDIOS configuration register                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Peripheral enable                                                  */
      __IOM uint32_t WRIE       : 1;            /*!< [1..1] Register write interrupt enable                                    */
      __IOM uint32_t RDIE       : 1;            /*!< [2..2] Register Read Interrupt Enable                                     */
      __IOM uint32_t EIE        : 1;            /*!< [3..3] Error interrupt enable                                             */
            uint32_t            : 3;
      __IOM uint32_t DPC        : 1;            /*!< [7..7] Disable Preamble Check                                             */
      __IOM uint32_t PORT_ADDRESS : 5;          /*!< [12..8] Slaves's address                                                  */
            uint32_t            : 19;
    } MDIOS_CR_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_WRFR;                  /*!< (@ 0x00000004) MDIOS write flag register                                  */
    
    struct {
      __IM  uint32_t WRF        : 32;           /*!< [31..0] Write flags for MDIO registers 0 to 31                            */
    } MDIOS_WRFR_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_CWRFR;                 /*!< (@ 0x00000008) MDIOS clear write flag register                            */
    
    struct {
      __IOM uint32_t CWRF       : 32;           /*!< [31..0] Clear the write flag                                              */
    } MDIOS_CWRFR_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_RDFR;                  /*!< (@ 0x0000000C) MDIOS read flag register                                   */
    
    struct {
      __IM  uint32_t RDF        : 32;           /*!< [31..0] Read flags for MDIO registers 0 to 31                             */
    } MDIOS_RDFR_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_CRDFR;                 /*!< (@ 0x00000010) MDIOS clear read flag register                             */
    
    struct {
      __IOM uint32_t CRDF       : 32;           /*!< [31..0] Clear the read flag                                               */
    } MDIOS_CRDFR_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_SR;                    /*!< (@ 0x00000014) MDIOS status register                                      */
    
    struct {
      __IM  uint32_t PERF       : 1;            /*!< [0..0] Preamble error flag                                                */
      __IM  uint32_t SERF       : 1;            /*!< [1..1] Start error flag                                                   */
      __IM  uint32_t TERF       : 1;            /*!< [2..2] Turnaround error flag                                              */
            uint32_t            : 29;
    } MDIOS_SR_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_CLRFR;                 /*!< (@ 0x00000018) MDIOS clear flag register                                  */
    
    struct {
      __IOM uint32_t CPERF      : 1;            /*!< [0..0] Clear the preamble error flag                                      */
      __IOM uint32_t CSERF      : 1;            /*!< [1..1] Clear the start error flag                                         */
      __IOM uint32_t CTERF      : 1;            /*!< [2..2] Clear the turnaround error flag                                    */
            uint32_t            : 29;
    } MDIOS_CLRFR_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR0;                 /*!< (@ 0x0000001C) MDIOS input data register 0                                */
    
    struct {
      __IM  uint32_t DIN0       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR0_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR1;                 /*!< (@ 0x00000020) MDIOS input data register 1                                */
    
    struct {
      __IM  uint32_t DIN1       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR1_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR2;                 /*!< (@ 0x00000024) MDIOS input data register 2                                */
    
    struct {
      __IM  uint32_t DIN2       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR2_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR3;                 /*!< (@ 0x00000028) MDIOS input data register 3                                */
    
    struct {
      __IM  uint32_t DIN3       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR3_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR4;                 /*!< (@ 0x0000002C) MDIOS input data register 4                                */
    
    struct {
      __IM  uint32_t DIN4       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR4_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR5;                 /*!< (@ 0x00000030) MDIOS input data register 5                                */
    
    struct {
      __IM  uint32_t DIN5       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR5_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR6;                 /*!< (@ 0x00000034) MDIOS input data register 6                                */
    
    struct {
      __IM  uint32_t DIN6       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR6_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR7;                 /*!< (@ 0x00000038) MDIOS input data register 7                                */
    
    struct {
      __IM  uint32_t DIN7       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR7_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR8;                 /*!< (@ 0x0000003C) MDIOS input data register 8                                */
    
    struct {
      __IM  uint32_t DIN8       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR8_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR9;                 /*!< (@ 0x00000040) MDIOS input data register 9                                */
    
    struct {
      __IM  uint32_t DIN9       : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR9_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR10;                /*!< (@ 0x00000044) MDIOS input data register 10                               */
    
    struct {
      __IM  uint32_t DIN10      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR10_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR11;                /*!< (@ 0x00000048) MDIOS input data register 11                               */
    
    struct {
      __IM  uint32_t DIN11      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR11_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR12;                /*!< (@ 0x0000004C) MDIOS input data register 12                               */
    
    struct {
      __IM  uint32_t DIN12      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR12_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR13;                /*!< (@ 0x00000050) MDIOS input data register 13                               */
    
    struct {
      __IM  uint32_t DIN13      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR13_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR14;                /*!< (@ 0x00000054) MDIOS input data register 14                               */
    
    struct {
      __IM  uint32_t DIN14      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR14_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR15;                /*!< (@ 0x00000058) MDIOS input data register 15                               */
    
    struct {
      __IM  uint32_t DIN15      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR15_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR16;                /*!< (@ 0x0000005C) MDIOS input data register 16                               */
    
    struct {
      __IM  uint32_t DIN16      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR16_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR17;                /*!< (@ 0x00000060) MDIOS input data register 17                               */
    
    struct {
      __IM  uint32_t DIN17      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR17_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR18;                /*!< (@ 0x00000064) MDIOS input data register 18                               */
    
    struct {
      __IM  uint32_t DIN18      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR18_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR19;                /*!< (@ 0x00000068) MDIOS input data register 19                               */
    
    struct {
      __IM  uint32_t DIN19      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR19_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR20;                /*!< (@ 0x0000006C) MDIOS input data register 20                               */
    
    struct {
      __IM  uint32_t DIN20      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR20_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR21;                /*!< (@ 0x00000070) MDIOS input data register 21                               */
    
    struct {
      __IM  uint32_t DIN21      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR21_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR22;                /*!< (@ 0x00000074) MDIOS input data register 22                               */
    
    struct {
      __IM  uint32_t DIN22      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR22_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR23;                /*!< (@ 0x00000078) MDIOS input data register 23                               */
    
    struct {
      __IM  uint32_t DIN23      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR23_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR24;                /*!< (@ 0x0000007C) MDIOS input data register 24                               */
    
    struct {
      __IM  uint32_t DIN24      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR24_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR25;                /*!< (@ 0x00000080) MDIOS input data register 25                               */
    
    struct {
      __IM  uint32_t DIN25      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR25_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR26;                /*!< (@ 0x00000084) MDIOS input data register 26                               */
    
    struct {
      __IM  uint32_t DIN26      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR26_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR27;                /*!< (@ 0x00000088) MDIOS input data register 27                               */
    
    struct {
      __IM  uint32_t DIN27      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR27_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR28;                /*!< (@ 0x0000008C) MDIOS input data register 28                               */
    
    struct {
      __IM  uint32_t DIN28      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR28_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR29;                /*!< (@ 0x00000090) MDIOS input data register 29                               */
    
    struct {
      __IM  uint32_t DIN29      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR29_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR30;                /*!< (@ 0x00000094) MDIOS input data register 30                               */
    
    struct {
      __IM  uint32_t DIN30      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR30_b;
  } ;
  
  union {
    __IM  uint32_t MDIOS_DINR31;                /*!< (@ 0x00000098) MDIOS input data register 31                               */
    
    struct {
      __IM  uint32_t DIN31      : 16;           /*!< [15..0] Input data received from MDIO Master during write frames          */
            uint32_t            : 16;
    } MDIOS_DINR31_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR0;                /*!< (@ 0x0000009C) MDIOS output data register 0                               */
    
    struct {
      __IOM uint32_t DOUT0      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR0_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR1;                /*!< (@ 0x000000A0) MDIOS output data register 1                               */
    
    struct {
      __IOM uint32_t DOUT1      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR1_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR2;                /*!< (@ 0x000000A4) MDIOS output data register 2                               */
    
    struct {
      __IOM uint32_t DOUT2      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR2_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR3;                /*!< (@ 0x000000A8) MDIOS output data register 3                               */
    
    struct {
      __IOM uint32_t DOUT3      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR3_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR4;                /*!< (@ 0x000000AC) MDIOS output data register 4                               */
    
    struct {
      __IOM uint32_t DOUT4      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR4_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR5;                /*!< (@ 0x000000B0) MDIOS output data register 5                               */
    
    struct {
      __IOM uint32_t DOUT5      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR5_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR6;                /*!< (@ 0x000000B4) MDIOS output data register 6                               */
    
    struct {
      __IOM uint32_t DOUT6      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR6_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR7;                /*!< (@ 0x000000B8) MDIOS output data register 7                               */
    
    struct {
      __IOM uint32_t DOUT7      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR7_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR8;                /*!< (@ 0x000000BC) MDIOS output data register 8                               */
    
    struct {
      __IOM uint32_t DOUT8      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR8_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR9;                /*!< (@ 0x000000C0) MDIOS output data register 9                               */
    
    struct {
      __IOM uint32_t DOUT9      : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR9_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR10;               /*!< (@ 0x000000C4) MDIOS output data register 10                              */
    
    struct {
      __IOM uint32_t DOUT10     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR10_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR11;               /*!< (@ 0x000000C8) MDIOS output data register 11                              */
    
    struct {
      __IOM uint32_t DOUT11     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR11_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR12;               /*!< (@ 0x000000CC) MDIOS output data register 12                              */
    
    struct {
      __IOM uint32_t DOUT12     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR12_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR13;               /*!< (@ 0x000000D0) MDIOS output data register 13                              */
    
    struct {
      __IOM uint32_t DOUT13     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR13_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR14;               /*!< (@ 0x000000D4) MDIOS output data register 14                              */
    
    struct {
      __IOM uint32_t DOUT14     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR14_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR15;               /*!< (@ 0x000000D8) MDIOS output data register 15                              */
    
    struct {
      __IOM uint32_t DOUT15     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR15_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR16;               /*!< (@ 0x000000DC) MDIOS output data register 16                              */
    
    struct {
      __IOM uint32_t DOUT16     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR16_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR17;               /*!< (@ 0x000000E0) MDIOS output data register 17                              */
    
    struct {
      __IOM uint32_t DOUT17     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR17_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR18;               /*!< (@ 0x000000E4) MDIOS output data register 18                              */
    
    struct {
      __IOM uint32_t DOUT18     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR18_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR19;               /*!< (@ 0x000000E8) MDIOS output data register 19                              */
    
    struct {
      __IOM uint32_t DOUT19     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR19_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR20;               /*!< (@ 0x000000EC) MDIOS output data register 20                              */
    
    struct {
      __IOM uint32_t DOUT20     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR20_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR21;               /*!< (@ 0x000000F0) MDIOS output data register 21                              */
    
    struct {
      __IOM uint32_t DOUT21     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR21_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR22;               /*!< (@ 0x000000F4) MDIOS output data register 22                              */
    
    struct {
      __IOM uint32_t DOUT22     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR22_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR23;               /*!< (@ 0x000000F8) MDIOS output data register 23                              */
    
    struct {
      __IOM uint32_t DOUT23     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR23_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR24;               /*!< (@ 0x000000FC) MDIOS output data register 24                              */
    
    struct {
      __IOM uint32_t DOUT24     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR24_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR25;               /*!< (@ 0x00000100) MDIOS output data register 25                              */
    
    struct {
      __IOM uint32_t DOUT25     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR25_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR26;               /*!< (@ 0x00000104) MDIOS output data register 26                              */
    
    struct {
      __IOM uint32_t DOUT26     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR26_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR27;               /*!< (@ 0x00000108) MDIOS output data register 27                              */
    
    struct {
      __IOM uint32_t DOUT27     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR27_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR28;               /*!< (@ 0x0000010C) MDIOS output data register 28                              */
    
    struct {
      __IOM uint32_t DOUT28     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR28_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR29;               /*!< (@ 0x00000110) MDIOS output data register 29                              */
    
    struct {
      __IOM uint32_t DOUT29     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR29_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR30;               /*!< (@ 0x00000114) MDIOS output data register 30                              */
    
    struct {
      __IOM uint32_t DOUT30     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR30_b;
  } ;
  
  union {
    __IOM uint32_t MDIOS_DOUTR31;               /*!< (@ 0x00000118) MDIOS output data register 31                              */
    
    struct {
      __IOM uint32_t DOUT31     : 16;           /*!< [15..0] Output data sent to MDIO Master during read frames                */
            uint32_t            : 16;
    } MDIOS_DOUTR31_b;
  } ;
} MDIOS_Type;                                   /*!< Size = 284 (0x11c)                                                        */



/* =========================================================================================================================== */
/* ================                                           OPAMP                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Operational amplifiers (OPAMP)
  */

typedef struct {                                /*!< (@ 0x40009000) OPAMP Structure                                            */
  
  union {
    __IOM uint32_t OPAMP1_CSR;                  /*!< (@ 0x00000000) OPAMP1 control/status register                             */
    
    struct {
      __IOM uint32_t OPAEN      : 1;            /*!< [0..0] Operational amplifier Enable                                       */
      __IOM uint32_t FORCE_VP   : 1;            /*!< [1..1] Force internal reference on VP (reserved for test                  */
      __IOM uint32_t VP_SEL     : 2;            /*!< [3..2] Operational amplifier PGA mode                                     */
            uint32_t            : 1;
      __IOM uint32_t VM_SEL     : 2;            /*!< [6..5] Inverting input selection                                          */
            uint32_t            : 1;
      __IOM uint32_t OPAHSM     : 1;            /*!< [8..8] Operational amplifier high-speed mode                              */
            uint32_t            : 2;
      __IOM uint32_t CALON      : 1;            /*!< [11..11] Calibration mode enabled                                         */
      __IOM uint32_t CALSEL     : 2;            /*!< [13..12] Calibration selection                                            */
      __IOM uint32_t PGA_GAIN   : 4;            /*!< [17..14] allows to switch from AOP offset trimmed values to
                                                     AOP offset                                                                */
      __IOM uint32_t USERTRIM   : 1;            /*!< [18..18] User trimming enable                                             */
            uint32_t            : 10;
      __IOM uint32_t TSTREF     : 1;            /*!< [29..29] OPAMP calibration reference voltage output control
                                                     (reserved for test)                                                       */
      __IOM uint32_t CALOUT     : 1;            /*!< [30..30] Operational amplifier calibration output                         */
            uint32_t            : 1;
    } OPAMP1_CSR_b;
  } ;
  
  union {
    __IOM uint32_t OPAMP1_OTR;                  /*!< (@ 0x00000004) OPAMP1 offset trimming register in normal mode             */
    
    struct {
      __IOM uint32_t TRIMOFFSETN : 5;           /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32_t            : 3;
      __IOM uint32_t TRIMOFFSETP : 5;           /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32_t            : 19;
    } OPAMP1_OTR_b;
  } ;
  
  union {
    __IOM uint32_t OPAMP1_HSOTR;                /*!< (@ 0x00000008) OPAMP1 offset trimming register in low-power
                                                                    mode                                                       */
    
    struct {
      __IOM uint32_t TRIMLPOFFSETN : 5;         /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32_t            : 3;
      __IOM uint32_t TRIMLPOFFSETP : 5;         /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32_t            : 19;
    } OPAMP1_HSOTR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t OPAMP2_CSR;                  /*!< (@ 0x00000010) OPAMP2 control/status register                             */
    
    struct {
      __IOM uint32_t OPAEN      : 1;            /*!< [0..0] Operational amplifier Enable                                       */
      __IOM uint32_t FORCE_VP   : 1;            /*!< [1..1] Force internal reference on VP (reserved for test)                 */
            uint32_t            : 3;
      __IOM uint32_t VM_SEL     : 2;            /*!< [6..5] Inverting input selection                                          */
            uint32_t            : 1;
      __IOM uint32_t OPAHSM     : 1;            /*!< [8..8] Operational amplifier high-speed mode                              */
            uint32_t            : 2;
      __IOM uint32_t CALON      : 1;            /*!< [11..11] Calibration mode enabled                                         */
      __IOM uint32_t CALSEL     : 2;            /*!< [13..12] Calibration selection                                            */
      __IOM uint32_t PGA_GAIN   : 4;            /*!< [17..14] Operational amplifier Programmable amplifier gain value          */
      __IOM uint32_t USERTRIM   : 1;            /*!< [18..18] User trimming enable                                             */
            uint32_t            : 10;
      __IOM uint32_t TSTREF     : 1;            /*!< [29..29] OPAMP calibration reference voltage output control
                                                     (reserved for test)                                                       */
      __IOM uint32_t CALOUT     : 1;            /*!< [30..30] Operational amplifier calibration output                         */
            uint32_t            : 1;
    } OPAMP2_CSR_b;
  } ;
  
  union {
    __IOM uint32_t OPAMP2_OTR;                  /*!< (@ 0x00000014) OPAMP2 offset trimming register in normal mode             */
    
    struct {
      __IOM uint32_t TRIMOFFSETN : 5;           /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32_t            : 3;
      __IOM uint32_t TRIMOFFSETP : 5;           /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32_t            : 19;
    } OPAMP2_OTR_b;
  } ;
  
  union {
    __IOM uint32_t OPAMP2_HSOTR;                /*!< (@ 0x00000018) OPAMP2 offset trimming register in low-power
                                                                    mode                                                       */
    
    struct {
      __IOM uint32_t TRIMLPOFFSETN : 5;         /*!< [4..0] Trim for NMOS differential pairs                                   */
            uint32_t            : 3;
      __IOM uint32_t TRIMLPOFFSETP : 5;         /*!< [12..8] Trim for PMOS differential pairs                                  */
            uint32_t            : 19;
    } OPAMP2_HSOTR_b;
  } ;
} OPAMP_Type;                                   /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                           SWPMI                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Single Wire Protocol Master
      Interface (SWPMI)
  */

typedef struct {                                /*!< (@ 0x40008800) SWPMI Structure                                            */
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000000) SWPMI Configuration/Control register                       */
    
    struct {
      __IOM uint32_t RXDMA      : 1;            /*!< [0..0] Reception DMA enable                                               */
      __IOM uint32_t TXDMA      : 1;            /*!< [1..1] Transmission DMA enable                                            */
      __IOM uint32_t RXMODE     : 1;            /*!< [2..2] Reception buffering mode                                           */
      __IOM uint32_t TXMODE     : 1;            /*!< [3..3] Transmission buffering mode                                        */
      __IOM uint32_t LPBK       : 1;            /*!< [4..4] Loopback mode enable                                               */
      __IOM uint32_t SWPACT     : 1;            /*!< [5..5] Single wire protocol master interface activate                     */
            uint32_t            : 4;
      __IOM uint32_t DEACT      : 1;            /*!< [10..10] Single wire protocol master interface deactivate                 */
      __IOM uint32_t SWPTEN     : 1;            /*!< [11..11] Single wire protocol master transceiver enable                   */
            uint32_t            : 20;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t BRR;                         /*!< (@ 0x00000004) SWPMI Bitrate register                                     */
    
    struct {
      __IOM uint32_t BR         : 8;            /*!< [7..0] Bitrate prescaler                                                  */
            uint32_t            : 24;
    } BRR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t ISR;                         /*!< (@ 0x0000000C) SWPMI Interrupt and Status register                        */
    
    struct {
      __IM  uint32_t RXBFF      : 1;            /*!< [0..0] Receive buffer full flag                                           */
      __IM  uint32_t TXBEF      : 1;            /*!< [1..1] Transmit buffer empty flag                                         */
      __IM  uint32_t RXBERF     : 1;            /*!< [2..2] Receive CRC error flag                                             */
      __IM  uint32_t RXOVRF     : 1;            /*!< [3..3] Receive overrun error flag                                         */
      __IM  uint32_t TXUNRF     : 1;            /*!< [4..4] Transmit underrun error flag                                       */
      __IM  uint32_t RXNE       : 1;            /*!< [5..5] Receive data register not empty                                    */
      __IM  uint32_t TXE        : 1;            /*!< [6..6] Transmit data register empty                                       */
      __IM  uint32_t TCF        : 1;            /*!< [7..7] Transfer complete flag                                             */
      __IM  uint32_t SRF        : 1;            /*!< [8..8] Slave resume flag                                                  */
      __IM  uint32_t SUSP       : 1;            /*!< [9..9] SUSPEND flag                                                       */
      __IM  uint32_t DEACTF     : 1;            /*!< [10..10] DEACTIVATED flag                                                 */
      __IM  uint32_t RDYF       : 1;            /*!< [11..11] transceiver ready flag                                           */
            uint32_t            : 20;
    } ISR_b;
  } ;
  
  union {
    __OM  uint32_t ICR;                         /*!< (@ 0x00000010) SWPMI Interrupt Flag Clear register                        */
    
    struct {
      __OM  uint32_t CRXBFF     : 1;            /*!< [0..0] Clear receive buffer full flag                                     */
      __OM  uint32_t CTXBEF     : 1;            /*!< [1..1] Clear transmit buffer empty flag                                   */
      __OM  uint32_t CRXBERF    : 1;            /*!< [2..2] Clear receive CRC error flag                                       */
      __OM  uint32_t CRXOVRF    : 1;            /*!< [3..3] Clear receive overrun error flag                                   */
      __OM  uint32_t CTXUNRF    : 1;            /*!< [4..4] Clear transmit underrun error flag                                 */
            uint32_t            : 2;
      __OM  uint32_t CTCF       : 1;            /*!< [7..7] Clear transfer complete flag                                       */
      __OM  uint32_t CSRF       : 1;            /*!< [8..8] Clear slave resume flag                                            */
            uint32_t            : 2;
      __OM  uint32_t CRDYF      : 1;            /*!< [11..11] Clear transceiver ready flag                                     */
            uint32_t            : 20;
    } ICR_b;
  } ;
  
  union {
    __IOM uint32_t IER;                         /*!< (@ 0x00000014) SWPMI Interrupt Enable register                            */
    
    struct {
      __IOM uint32_t RXBFIE     : 1;            /*!< [0..0] Receive buffer full interrupt enable                               */
      __IOM uint32_t TXBEIE     : 1;            /*!< [1..1] Transmit buffer empty interrupt enable                             */
      __IOM uint32_t RXBERIE    : 1;            /*!< [2..2] Receive CRC error interrupt enable                                 */
      __IOM uint32_t RXOVRIE    : 1;            /*!< [3..3] Receive overrun error interrupt enable                             */
      __IOM uint32_t TXUNRIE    : 1;            /*!< [4..4] Transmit underrun error interrupt enable                           */
      __IOM uint32_t RIE        : 1;            /*!< [5..5] Receive interrupt enable                                           */
      __IOM uint32_t TIE        : 1;            /*!< [6..6] Transmit interrupt enable                                          */
      __IOM uint32_t TCIE       : 1;            /*!< [7..7] Transmit complete interrupt enable                                 */
      __IOM uint32_t SRIE       : 1;            /*!< [8..8] Slave resume interrupt enable                                      */
            uint32_t            : 2;
      __IOM uint32_t RDYIE      : 1;            /*!< [11..11] Transceiver ready interrupt enable                               */
            uint32_t            : 20;
    } IER_b;
  } ;
  
  union {
    __IM  uint32_t RFL;                         /*!< (@ 0x00000018) SWPMI Receive Frame Length register                        */
    
    struct {
      __IM  uint32_t RFL        : 5;            /*!< [4..0] Receive frame length                                               */
            uint32_t            : 27;
    } RFL_b;
  } ;
  
  union {
    __OM  uint32_t TDR;                         /*!< (@ 0x0000001C) SWPMI Transmit data register                               */
    
    struct {
      __OM  uint32_t TD         : 32;           /*!< [31..0] Transmit data                                                     */
    } TDR_b;
  } ;
  
  union {
    __IM  uint32_t RDR;                         /*!< (@ 0x00000020) SWPMI Receive data register                                */
    
    struct {
      __IM  uint32_t RD         : 32;           /*!< [31..0] received data                                                     */
    } RDR_b;
  } ;
  
  union {
    __IOM uint32_t OR;                          /*!< (@ 0x00000024) SWPMI Option register                                      */
    
    struct {
      __IOM uint32_t SWP_TBYP   : 1;            /*!< [0..0] SWP transceiver bypass                                             */
      __IOM uint32_t SWP_CLASS  : 1;            /*!< [1..1] SWP class selection                                                */
            uint32_t            : 30;
    } OR_b;
  } ;
} SWPMI_Type;                                   /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                           TIM2                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timers (TIM2)
  */

typedef struct {                                /*!< (@ 0x40000000) TIM2 Structure                                             */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
      __IOM uint32_t DIR        : 1;            /*!< [4..4] Direction                                                          */
      __IOM uint32_t CMS        : 2;            /*!< [6..5] Center-aligned mode selection                                      */
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
      __IOM uint32_t CKD        : 2;            /*!< [9..8] Clock division                                                     */
            uint32_t            : 1;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t CCDS       : 1;            /*!< [3..3] Capture/compare DMA selection                                      */
      __IOM uint32_t MMS        : 3;            /*!< [6..4] Master mode selection                                              */
      __IOM uint32_t TI1S       : 1;            /*!< [7..7] TI1 selection                                                      */
            uint32_t            : 24;
    } CR2_b;
  } ;
  
  union {
    __IOM uint32_t SMCR;                        /*!< (@ 0x00000008) slave mode control register                                */
    
    struct {
      __IOM uint32_t SMS        : 3;            /*!< [2..0] Slave mode selection                                               */
            uint32_t            : 1;
      __IOM uint32_t TS         : 3;            /*!< [6..4] Trigger selection                                                  */
      __IOM uint32_t MSM        : 1;            /*!< [7..7] Master/Slave mode                                                  */
      __IOM uint32_t ETF        : 4;            /*!< [11..8] External trigger filter                                           */
      __IOM uint32_t ETPS       : 2;            /*!< [13..12] External trigger prescaler                                       */
      __IOM uint32_t ECE        : 1;            /*!< [14..14] External clock enable                                            */
      __IOM uint32_t ETP        : 1;            /*!< [15..15] External trigger polarity                                        */
      __IOM uint32_t SMS_3      : 1;            /*!< [16..16] Slave mode selection - bit 3                                     */
            uint32_t            : 3;
      __IOM uint32_t TS_4_3     : 2;            /*!< [21..20] Trigger selection                                                */
            uint32_t            : 10;
    } SMCR_b;
  } ;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
      __IOM uint32_t CC1IE      : 1;            /*!< [1..1] Capture/Compare 1 interrupt enable                                 */
      __IOM uint32_t CC2IE      : 1;            /*!< [2..2] Capture/Compare 2 interrupt enable                                 */
      __IOM uint32_t CC3IE      : 1;            /*!< [3..3] Capture/Compare 3 interrupt enable                                 */
      __IOM uint32_t CC4IE      : 1;            /*!< [4..4] Capture/Compare 4 interrupt enable                                 */
            uint32_t            : 1;
      __IOM uint32_t TIE        : 1;            /*!< [6..6] Trigger interrupt enable                                           */
            uint32_t            : 1;
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
      __IOM uint32_t CC1DE      : 1;            /*!< [9..9] Capture/Compare 1 DMA request enable                               */
      __IOM uint32_t CC2DE      : 1;            /*!< [10..10] Capture/Compare 2 DMA request enable                             */
      __IOM uint32_t CC3DE      : 1;            /*!< [11..11] Capture/Compare 3 DMA request enable                             */
      __IOM uint32_t CC4DE      : 1;            /*!< [12..12] Capture/Compare 4 DMA request enable                             */
            uint32_t            : 1;
      __IOM uint32_t TDE        : 1;            /*!< [14..14] Trigger DMA request enable                                       */
            uint32_t            : 17;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
      __IOM uint32_t CC1IF      : 1;            /*!< [1..1] Capture/compare 1 interrupt flag                                   */
      __IOM uint32_t CC2IF      : 1;            /*!< [2..2] Capture/Compare 2 interrupt flag                                   */
      __IOM uint32_t CC3IF      : 1;            /*!< [3..3] Capture/Compare 3 interrupt flag                                   */
      __IOM uint32_t CC4IF      : 1;            /*!< [4..4] Capture/Compare 4 interrupt flag                                   */
            uint32_t            : 1;
      __IOM uint32_t TIF        : 1;            /*!< [6..6] Trigger interrupt flag                                             */
            uint32_t            : 2;
      __IOM uint32_t CC1OF      : 1;            /*!< [9..9] Capture/Compare 1 overcapture flag                                 */
      __IOM uint32_t CC2OF      : 1;            /*!< [10..10] Capture/compare 2 overcapture flag                               */
      __IOM uint32_t CC3OF      : 1;            /*!< [11..11] Capture/Compare 3 overcapture flag                               */
      __IOM uint32_t CC4OF      : 1;            /*!< [12..12] Capture/Compare 4 overcapture flag                               */
            uint32_t            : 19;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
      __OM  uint32_t CC1G       : 1;            /*!< [1..1] Capture/compare 1 generation                                       */
      __OM  uint32_t CC2G       : 1;            /*!< [2..2] Capture/compare 2 generation                                       */
      __OM  uint32_t CC3G       : 1;            /*!< [3..3] Capture/compare 3 generation                                       */
      __OM  uint32_t CC4G       : 1;            /*!< [4..4] Capture/compare 4 generation                                       */
            uint32_t            : 1;
      __OM  uint32_t TG         : 1;            /*!< [6..6] Trigger generation                                                 */
            uint32_t            : 25;
    } EGR_b;
  } ;
  
  union {
    union {
      __IOM uint32_t CCMR1_Output;              /*!< (@ 0x00000018) capture/compare mode register 1 (output mode)              */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] CC1S                                                               */
        __IOM uint32_t OC1FE    : 1;            /*!< [2..2] OC1FE                                                              */
        __IOM uint32_t OC1PE    : 1;            /*!< [3..3] OC1PE                                                              */
        __IOM uint32_t OC1M     : 3;            /*!< [6..4] OC1M                                                               */
        __IOM uint32_t OC1CE    : 1;            /*!< [7..7] OC1CE                                                              */
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] CC2S                                                               */
        __IOM uint32_t OC2FE    : 1;            /*!< [10..10] OC2FE                                                            */
        __IOM uint32_t OC2PE    : 1;            /*!< [11..11] OC2PE                                                            */
        __IOM uint32_t OC2M     : 3;            /*!< [14..12] OC2M                                                             */
        __IOM uint32_t OC2CE    : 1;            /*!< [15..15] OC2CE                                                            */
        __IOM uint32_t OC1M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32_t          : 7;
        __IOM uint32_t OC2M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32_t          : 7;
      } CCMR1_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR1_Input;               /*!< (@ 0x00000018) capture/compare mode register 1 (input mode)               */
      
      struct {
        __IOM uint32_t CC1S     : 2;            /*!< [1..0] Capture/Compare 1 selection                                        */
        __IOM uint32_t ICPCS    : 2;            /*!< [3..2] Input capture 1 prescaler                                          */
        __IOM uint32_t IC1F     : 4;            /*!< [7..4] Input capture 1 filter                                             */
        __IOM uint32_t CC2S     : 2;            /*!< [9..8] Capture/Compare 2 selection                                        */
        __IOM uint32_t IC2PCS   : 2;            /*!< [11..10] Input capture 2 prescaler                                        */
        __IOM uint32_t IC2F     : 4;            /*!< [15..12] Input capture 2 filter                                           */
              uint32_t          : 16;
      } CCMR1_Input_b;
    } ;
  };
  
  union {
    union {
      __IOM uint32_t CCMR2_Output;              /*!< (@ 0x0000001C) capture/compare mode register 2 (output mode)              */
      
      struct {
        __IOM uint32_t CC3S     : 2;            /*!< [1..0] CC3S                                                               */
        __IOM uint32_t OC3FE    : 1;            /*!< [2..2] OC3FE                                                              */
        __IOM uint32_t OC3PE    : 1;            /*!< [3..3] OC3PE                                                              */
        __IOM uint32_t OC3M     : 3;            /*!< [6..4] OC3M                                                               */
        __IOM uint32_t OC3CE    : 1;            /*!< [7..7] OC3CE                                                              */
        __IOM uint32_t CC4S     : 2;            /*!< [9..8] CC4S                                                               */
        __IOM uint32_t OC4FE    : 1;            /*!< [10..10] OC4FE                                                            */
        __IOM uint32_t OC4PE    : 1;            /*!< [11..11] OC4PE                                                            */
        __IOM uint32_t OC4M     : 3;            /*!< [14..12] OC4M                                                             */
        __IOM uint32_t OC4CE    : 1;            /*!< [15..15] OC4CE                                                            */
        __IOM uint32_t OC3M_3   : 1;            /*!< [16..16] Output Compare 1 mode - bit 3                                    */
              uint32_t          : 7;
        __IOM uint32_t OC4M_3   : 1;            /*!< [24..24] Output Compare 2 mode - bit 3                                    */
              uint32_t          : 7;
      } CCMR2_Output_b;
    } ;
    
    union {
      __IOM uint32_t CCMR2_Input;               /*!< (@ 0x0000001C) capture/compare mode register 2 (input mode)               */
      
      struct {
        __IOM uint32_t CC3S     : 2;            /*!< [1..0] Capture/compare 3 selection                                        */
        __IOM uint32_t IC3PSC   : 2;            /*!< [3..2] Input capture 3 prescaler                                          */
        __IOM uint32_t IC3F     : 4;            /*!< [7..4] Input capture 3 filter                                             */
        __IOM uint32_t CC4S     : 2;            /*!< [9..8] Capture/Compare 4 selection                                        */
        __IOM uint32_t IC4PSC   : 2;            /*!< [11..10] Input capture 4 prescaler                                        */
        __IOM uint32_t IC4F     : 4;            /*!< [15..12] Input capture 4 filter                                           */
              uint32_t          : 16;
      } CCMR2_Input_b;
    } ;
  };
  
  union {
    __IOM uint32_t CCER;                        /*!< (@ 0x00000020) capture/compare enable register                            */
    
    struct {
      __IOM uint32_t CC1E       : 1;            /*!< [0..0] Capture/Compare 1 output enable                                    */
      __IOM uint32_t CC1P       : 1;            /*!< [1..1] Capture/Compare 1 output Polarity                                  */
            uint32_t            : 1;
      __IOM uint32_t CC1NP      : 1;            /*!< [3..3] Capture/Compare 1 output Polarity                                  */
      __IOM uint32_t CC2E       : 1;            /*!< [4..4] Capture/Compare 2 output enable                                    */
      __IOM uint32_t CC2P       : 1;            /*!< [5..5] Capture/Compare 2 output Polarity                                  */
            uint32_t            : 1;
      __IOM uint32_t CC2NP      : 1;            /*!< [7..7] Capture/Compare 2 output Polarity                                  */
      __IOM uint32_t CC3E       : 1;            /*!< [8..8] Capture/Compare 3 output enable                                    */
      __IOM uint32_t CC3P       : 1;            /*!< [9..9] Capture/Compare 3 output Polarity                                  */
            uint32_t            : 1;
      __IOM uint32_t CC3NP      : 1;            /*!< [11..11] Capture/Compare 3 output Polarity                                */
      __IOM uint32_t CC4E       : 1;            /*!< [12..12] Capture/Compare 4 output enable                                  */
      __IOM uint32_t CC4P       : 1;            /*!< [13..13] Capture/Compare 3 output Polarity                                */
            uint32_t            : 1;
      __IOM uint32_t CC4NP      : 1;            /*!< [15..15] Capture/Compare 4 output Polarity                                */
            uint32_t            : 16;
    } CCER_b;
  } ;
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT_L      : 16;           /*!< [15..0] low counter value                                                 */
      __IOM uint32_t CNT_H      : 16;           /*!< [31..16] High counter value                                               */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR_L      : 16;           /*!< [15..0] Low Auto-reload value                                             */
      __IOM uint32_t ARR_H      : 16;           /*!< [31..16] High Auto-reload value                                           */
    } ARR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t CCR1;                        /*!< (@ 0x00000034) capture/compare register 1                                 */
    
    struct {
      __IOM uint32_t CCR1_L     : 16;           /*!< [15..0] Low Capture/Compare 1 value                                       */
      __IOM uint32_t CCR1_H     : 16;           /*!< [31..16] High Capture/Compare 1 value                                     */
    } CCR1_b;
  } ;
  
  union {
    __IOM uint32_t CCR2;                        /*!< (@ 0x00000038) capture/compare register 2                                 */
    
    struct {
      __IOM uint32_t CCR2_L     : 16;           /*!< [15..0] Low Capture/Compare 2 value                                       */
      __IOM uint32_t CCR2_H     : 16;           /*!< [31..16] High Capture/Compare 2 value                                     */
    } CCR2_b;
  } ;
  
  union {
    __IOM uint32_t CCR3;                        /*!< (@ 0x0000003C) capture/compare register 3                                 */
    
    struct {
      __IOM uint32_t CCR3_L     : 16;           /*!< [15..0] Low Capture/Compare value                                         */
      __IOM uint32_t CCR3_H     : 16;           /*!< [31..16] High Capture/Compare value                                       */
    } CCR3_b;
  } ;
  
  union {
    __IOM uint32_t CCR4;                        /*!< (@ 0x00000040) capture/compare register 4                                 */
    
    struct {
      __IOM uint32_t CCR4_L     : 16;           /*!< [15..0] Low Capture/Compare value                                         */
      __IOM uint32_t CCR4_H     : 16;           /*!< [31..16] High Capture/Compare value                                       */
    } CCR4_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t DCR;                         /*!< (@ 0x00000048) DMA control register                                       */
    
    struct {
      __IOM uint32_t DBA        : 5;            /*!< [4..0] DMA base address                                                   */
            uint32_t            : 3;
      __IOM uint32_t DBL        : 5;            /*!< [12..8] DMA burst length                                                  */
            uint32_t            : 19;
    } DCR_b;
  } ;
  
  union {
    __IOM uint32_t DMAR;                        /*!< (@ 0x0000004C) DMA address for full transfer                              */
    
    struct {
      __IOM uint32_t DMAB       : 16;           /*!< [15..0] DMA register for burst accesses                                   */
            uint32_t            : 16;
    } DMAR_b;
  } ;
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t AF1;                         /*!< (@ 0x00000060) TIM alternate function option register 1                   */
    
    struct {
            uint32_t            : 14;
      __IOM uint32_t ETRSEL     : 4;            /*!< [17..14] ETR source selection                                             */
            uint32_t            : 14;
    } AF1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t TISEL;                       /*!< (@ 0x00000068) TIM timer input selection register                         */
    
    struct {
      __IOM uint32_t TI1SEL     : 4;            /*!< [3..0] TI1[0] to TI1[15] input selection                                  */
            uint32_t            : 4;
      __IOM uint32_t TI2SEL     : 4;            /*!< [11..8] TI2[0] to TI2[15] input selection                                 */
            uint32_t            : 4;
      __IOM uint32_t TI3SEL     : 4;            /*!< [19..16] TI3[0] to TI3[15] input selection                                */
            uint32_t            : 4;
      __IOM uint32_t TI4SEL     : 4;            /*!< [27..24] TI4[0] to TI4[15] input selection                                */
            uint32_t            : 4;
    } TISEL_b;
  } ;
} TIM2_Type;                                    /*!< Size = 108 (0x6c)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIM6                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Basic timers (TIM6)
  */

typedef struct {                                /*!< (@ 0x40001000) TIM6 Structure                                             */
  
  union {
    __IOM uint32_t CR1;                         /*!< (@ 0x00000000) control register 1                                         */
    
    struct {
      __IOM uint32_t CEN        : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t UDIS       : 1;            /*!< [1..1] Update disable                                                     */
      __IOM uint32_t URS        : 1;            /*!< [2..2] Update request source                                              */
      __IOM uint32_t OPM        : 1;            /*!< [3..3] One-pulse mode                                                     */
            uint32_t            : 3;
      __IOM uint32_t ARPE       : 1;            /*!< [7..7] Auto-reload preload enable                                         */
            uint32_t            : 3;
      __IOM uint32_t UIFREMAP   : 1;            /*!< [11..11] UIF status bit remapping                                         */
            uint32_t            : 20;
    } CR1_b;
  } ;
  
  union {
    __IOM uint32_t CR2;                         /*!< (@ 0x00000004) control register 2                                         */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t MMS        : 3;            /*!< [6..4] Master mode selection                                              */
            uint32_t            : 25;
    } CR2_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t DIER;                        /*!< (@ 0x0000000C) DMA/Interrupt enable register                              */
    
    struct {
      __IOM uint32_t UIE        : 1;            /*!< [0..0] Update interrupt enable                                            */
            uint32_t            : 7;
      __IOM uint32_t UDE        : 1;            /*!< [8..8] Update DMA request enable                                          */
            uint32_t            : 23;
    } DIER_b;
  } ;
  
  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000010) status register                                            */
    
    struct {
      __IOM uint32_t UIF        : 1;            /*!< [0..0] Update interrupt flag                                              */
            uint32_t            : 31;
    } SR_b;
  } ;
  
  union {
    __OM  uint32_t EGR;                         /*!< (@ 0x00000014) event generation register                                  */
    
    struct {
      __OM  uint32_t UG         : 1;            /*!< [0..0] Update generation                                                  */
            uint32_t            : 31;
    } EGR_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t CNT;                         /*!< (@ 0x00000024) counter                                                    */
    
    struct {
      __IOM uint32_t CNT        : 16;           /*!< [15..0] Low counter value                                                 */
            uint32_t            : 15;
      __IOM uint32_t UIFCPY     : 1;            /*!< [31..31] UIF Copy                                                         */
    } CNT_b;
  } ;
  
  union {
    __IOM uint32_t PSC;                         /*!< (@ 0x00000028) prescaler                                                  */
    
    struct {
      __IOM uint32_t PSC        : 16;           /*!< [15..0] Prescaler value                                                   */
            uint32_t            : 16;
    } PSC_b;
  } ;
  
  union {
    __IOM uint32_t ARR;                         /*!< (@ 0x0000002C) auto-reload register                                       */
    
    struct {
      __IOM uint32_t ARR        : 16;           /*!< [15..0] Low Auto-reload value                                             */
            uint32_t            : 16;
    } ARR_b;
  } ;
} TIM6_Type;                                    /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           NVIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Nested Vectored Interrupt
      Controller (NVIC)
  */

typedef struct {                                /*!< (@ 0xE000E100) NVIC Structure                                             */
  
  union {
    __IOM uint32_t ISER0;                       /*!< (@ 0x00000000) Interrupt Set-Enable Register                              */
    
    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] SETENA                                                            */
    } ISER0_b;
  } ;
  
  union {
    __IOM uint32_t ISER1;                       /*!< (@ 0x00000004) Interrupt Set-Enable Register                              */
    
    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] SETENA                                                            */
    } ISER1_b;
  } ;
  
  union {
    __IOM uint32_t ISER2;                       /*!< (@ 0x00000008) Interrupt Set-Enable Register                              */
    
    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] SETENA                                                            */
    } ISER2_b;
  } ;
  __IM  uint32_t  RESERVED[29];
  
  union {
    __IOM uint32_t ICER0;                       /*!< (@ 0x00000080) Interrupt Clear-Enable Register                            */
    
    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] CLRENA                                                            */
    } ICER0_b;
  } ;
  
  union {
    __IOM uint32_t ICER1;                       /*!< (@ 0x00000084) Interrupt Clear-Enable Register                            */
    
    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] CLRENA                                                            */
    } ICER1_b;
  } ;
  
  union {
    __IOM uint32_t ICER2;                       /*!< (@ 0x00000088) Interrupt Clear-Enable Register                            */
    
    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] CLRENA                                                            */
    } ICER2_b;
  } ;
  __IM  uint32_t  RESERVED1[29];
  
  union {
    __IOM uint32_t ISPR0;                       /*!< (@ 0x00000100) Interrupt Set-Pending Register                             */
    
    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] SETPEND                                                           */
    } ISPR0_b;
  } ;
  
  union {
    __IOM uint32_t ISPR1;                       /*!< (@ 0x00000104) Interrupt Set-Pending Register                             */
    
    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] SETPEND                                                           */
    } ISPR1_b;
  } ;
  
  union {
    __IOM uint32_t ISPR2;                       /*!< (@ 0x00000108) Interrupt Set-Pending Register                             */
    
    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] SETPEND                                                           */
    } ISPR2_b;
  } ;
  __IM  uint32_t  RESERVED2[29];
  
  union {
    __IOM uint32_t ICPR0;                       /*!< (@ 0x00000180) Interrupt Clear-Pending Register                           */
    
    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] CLRPEND                                                           */
    } ICPR0_b;
  } ;
  
  union {
    __IOM uint32_t ICPR1;                       /*!< (@ 0x00000184) Interrupt Clear-Pending Register                           */
    
    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] CLRPEND                                                           */
    } ICPR1_b;
  } ;
  
  union {
    __IOM uint32_t ICPR2;                       /*!< (@ 0x00000188) Interrupt Clear-Pending Register                           */
    
    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] CLRPEND                                                           */
    } ICPR2_b;
  } ;
  __IM  uint32_t  RESERVED3[29];
  
  union {
    __IM  uint32_t IABR0;                       /*!< (@ 0x00000200) Interrupt Active Bit Register                              */
    
    struct {
      __IM  uint32_t ACTIVE     : 32;           /*!< [31..0] ACTIVE                                                            */
    } IABR0_b;
  } ;
  
  union {
    __IM  uint32_t IABR1;                       /*!< (@ 0x00000204) Interrupt Active Bit Register                              */
    
    struct {
      __IM  uint32_t ACTIVE     : 32;           /*!< [31..0] ACTIVE                                                            */
    } IABR1_b;
  } ;
  
  union {
    __IM  uint32_t IABR2;                       /*!< (@ 0x00000208) Interrupt Active Bit Register                              */
    
    struct {
      __IM  uint32_t ACTIVE     : 32;           /*!< [31..0] ACTIVE                                                            */
    } IABR2_b;
  } ;
  __IM  uint32_t  RESERVED4[61];
  
  union {
    __IOM uint32_t IPR0;                        /*!< (@ 0x00000300) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR0_b;
  } ;
  
  union {
    __IOM uint32_t IPR1;                        /*!< (@ 0x00000304) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR1_b;
  } ;
  
  union {
    __IOM uint32_t IPR2;                        /*!< (@ 0x00000308) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR2_b;
  } ;
  
  union {
    __IOM uint32_t IPR3;                        /*!< (@ 0x0000030C) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR3_b;
  } ;
  
  union {
    __IOM uint32_t IPR4;                        /*!< (@ 0x00000310) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR4_b;
  } ;
  
  union {
    __IOM uint32_t IPR5;                        /*!< (@ 0x00000314) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR5_b;
  } ;
  
  union {
    __IOM uint32_t IPR6;                        /*!< (@ 0x00000318) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR6_b;
  } ;
  
  union {
    __IOM uint32_t IPR7;                        /*!< (@ 0x0000031C) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR7_b;
  } ;
  
  union {
    __IOM uint32_t IPR8;                        /*!< (@ 0x00000320) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR8_b;
  } ;
  
  union {
    __IOM uint32_t IPR9;                        /*!< (@ 0x00000324) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR9_b;
  } ;
  
  union {
    __IOM uint32_t IPR10;                       /*!< (@ 0x00000328) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR10_b;
  } ;
  
  union {
    __IOM uint32_t IPR11;                       /*!< (@ 0x0000032C) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR11_b;
  } ;
  
  union {
    __IOM uint32_t IPR12;                       /*!< (@ 0x00000330) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR12_b;
  } ;
  
  union {
    __IOM uint32_t IPR13;                       /*!< (@ 0x00000334) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR13_b;
  } ;
  
  union {
    __IOM uint32_t IPR14;                       /*!< (@ 0x00000338) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR14_b;
  } ;
  
  union {
    __IOM uint32_t IPR15;                       /*!< (@ 0x0000033C) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR15_b;
  } ;
  
  union {
    __IOM uint32_t IPR16;                       /*!< (@ 0x00000340) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR16_b;
  } ;
  
  union {
    __IOM uint32_t IPR17;                       /*!< (@ 0x00000344) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR17_b;
  } ;
  
  union {
    __IOM uint32_t IPR18;                       /*!< (@ 0x00000348) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR18_b;
  } ;
  
  union {
    __IOM uint32_t IPR19;                       /*!< (@ 0x0000034C) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR19_b;
  } ;
  
  union {
    __IOM uint32_t IPR20;                       /*!< (@ 0x00000350) Interrupt Priority Register                                */
    
    struct {
      __IOM uint32_t IPR_N0     : 8;            /*!< [7..0] IPR_N0                                                             */
      __IOM uint32_t IPR_N1     : 8;            /*!< [15..8] IPR_N1                                                            */
      __IOM uint32_t IPR_N2     : 8;            /*!< [23..16] IPR_N2                                                           */
      __IOM uint32_t IPR_N3     : 8;            /*!< [31..24] IPR_N3                                                           */
    } IPR20_b;
  } ;
} NVIC_Type;                                    /*!< Size = 852 (0x354)                                                        */



/* =========================================================================================================================== */
/* ================                                          DBGMCU                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Microcontroller Debug Unit (DBGMCU)
  */

typedef struct {                                /*!< (@ 0x5C001000) DBGMCU Structure                                           */
  
  union {
    __IM  uint32_t IDC;                         /*!< (@ 0x00000000) DBGMCU Identity Code Register                              */
    
    struct {
      __IM  uint32_t DEV_ID     : 12;           /*!< [11..0] Device ID                                                         */
            uint32_t            : 4;
      __IM  uint32_t REV_ID     : 16;           /*!< [31..16] Revision                                                         */
    } IDC_b;
  } ;
  
  union {
    __IOM uint32_t CR;                          /*!< (@ 0x00000004) DBGMCU Configuration Register                              */
    
    struct {
      __IOM uint32_t DBGSLEEP_D1 : 1;           /*!< [0..0] Allow D1 domain debug in Sleep mode                                */
      __IOM uint32_t DBGSTOP_D1 : 1;            /*!< [1..1] Allow D1 domain debug in Stop mode                                 */
      __IOM uint32_t DBGSTBY_D1 : 1;            /*!< [2..2] Allow D1 domain debug in Standby mode                              */
      __IOM uint32_t DBGSLEEP_D2 : 1;           /*!< [3..3] Allow D2 domain debug in Sleep mode                                */
      __IOM uint32_t DBGSTOP_D2 : 1;            /*!< [4..4] Allow D2 domain debug in Stop mode                                 */
      __IOM uint32_t DBGSTBY_D2 : 1;            /*!< [5..5] Allow D2 domain debug in Standby mode                              */
            uint32_t            : 1;
      __IOM uint32_t DBGSTOP_D3 : 1;            /*!< [7..7] Allow debug in D3 Stop mode                                        */
      __IOM uint32_t DBGSTBY_D3 : 1;            /*!< [8..8] Allow debug in D3 Standby mode                                     */
            uint32_t            : 11;
      __IOM uint32_t TRACECLKEN : 1;            /*!< [20..20] Trace port clock enable                                          */
      __IOM uint32_t D1DBGCKEN  : 1;            /*!< [21..21] D1 debug clock enable                                            */
      __IOM uint32_t D3DBGCKEN  : 1;            /*!< [22..22] D3 debug clock enable                                            */
            uint32_t            : 5;
      __IOM uint32_t TRGOEN     : 1;            /*!< [28..28] External trigger output enable                                   */
            uint32_t            : 3;
    } CR_b;
  } ;
  __IM  uint32_t  RESERVED[11];
  
  union {
    __IOM uint32_t APB3FZ1;                     /*!< (@ 0x00000034) DBGMCU APB3 peripheral freeze register                     */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t WWDG1      : 1;            /*!< [6..6] WWDG1 stop in debug                                                */
            uint32_t            : 25;
    } APB3FZ1_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t APB1LFZ1;                    /*!< (@ 0x0000003C) DBGMCU APB1L peripheral freeze register                    */
    
    struct {
      __IOM uint32_t DBG_TIM2   : 1;            /*!< [0..0] TIM2 stop in debug                                                 */
      __IOM uint32_t DBG_TIM3   : 1;            /*!< [1..1] TIM3 stop in debug                                                 */
      __IOM uint32_t DBG_TIM4   : 1;            /*!< [2..2] TIM4 stop in debug                                                 */
      __IOM uint32_t DBG_TIM5   : 1;            /*!< [3..3] TIM5 stop in debug                                                 */
      __IOM uint32_t DBG_TIM6   : 1;            /*!< [4..4] TIM6 stop in debug                                                 */
      __IOM uint32_t DBG_TIM7   : 1;            /*!< [5..5] TIM7 stop in debug                                                 */
      __IOM uint32_t DBG_TIM12  : 1;            /*!< [6..6] TIM12 stop in debug                                                */
      __IOM uint32_t DBG_TIM13  : 1;            /*!< [7..7] TIM13 stop in debug                                                */
      __IOM uint32_t DBG_TIM14  : 1;            /*!< [8..8] TIM14 stop in debug                                                */
      __IOM uint32_t DBG_LPTIM1 : 1;            /*!< [9..9] LPTIM1 stop in debug                                               */
            uint32_t            : 11;
      __IOM uint32_t DBG_I2C1   : 1;            /*!< [21..21] I2C1 SMBUS timeout stop in debug                                 */
      __IOM uint32_t DBG_I2C2   : 1;            /*!< [22..22] I2C2 SMBUS timeout stop in debug                                 */
      __IOM uint32_t DBG_I2C3   : 1;            /*!< [23..23] I2C3 SMBUS timeout stop in debug                                 */
            uint32_t            : 8;
    } APB1LFZ1_b;
  } ;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t APB2FZ1;                     /*!< (@ 0x0000004C) DBGMCU APB2 peripheral freeze register                     */
    
    struct {
      __IOM uint32_t DBG_TIM1   : 1;            /*!< [0..0] TIM1 stop in debug                                                 */
      __IOM uint32_t DBG_TIM8   : 1;            /*!< [1..1] TIM8 stop in debug                                                 */
            uint32_t            : 14;
      __IOM uint32_t DBG_TIM15  : 1;            /*!< [16..16] TIM15 stop in debug                                              */
      __IOM uint32_t DBG_TIM16  : 1;            /*!< [17..17] TIM16 stop in debug                                              */
      __IOM uint32_t DBG_TIM17  : 1;            /*!< [18..18] TIM17 stop in debug                                              */
            uint32_t            : 10;
      __IOM uint32_t DBG_HRTIM  : 1;            /*!< [29..29] HRTIM stop in debug                                              */
            uint32_t            : 2;
    } APB2FZ1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t APB4FZ1;                     /*!< (@ 0x00000054) DBGMCU APB4 peripheral freeze register                     */
    
    struct {
            uint32_t            : 7;
      __IOM uint32_t DBG_I2C4   : 1;            /*!< [7..7] I2C4 SMBUS timeout stop in debug                                   */
            uint32_t            : 1;
      __IOM uint32_t DBG_LPTIM2 : 1;            /*!< [9..9] LPTIM2 stop in debug                                               */
      __IOM uint32_t DBG_LPTIM3 : 1;            /*!< [10..10] LPTIM2 stop in debug                                             */
      __IOM uint32_t DBG_LPTIM4 : 1;            /*!< [11..11] LPTIM4 stop in debug                                             */
      __IOM uint32_t DBG_LPTIM5 : 1;            /*!< [12..12] LPTIM5 stop in debug                                             */
            uint32_t            : 3;
      __IOM uint32_t DBG_RTC    : 1;            /*!< [16..16] RTC stop in debug                                                */
            uint32_t            : 1;
      __IOM uint32_t DBG_WDGLSD1 : 1;           /*!< [18..18] Independent watchdog for D1 stop in debug                        */
            uint32_t            : 13;
    } APB4FZ1_b;
  } ;
} DBGMCU_Type;                                  /*!< Size = 88 (0x58)                                                          */



/* =========================================================================================================================== */
/* ================                                            MPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Memory protection unit (MPU)
  */

typedef struct {                                /*!< (@ 0xE000ED90) MPU Structure                                              */
  
  union {
    __IM  uint32_t MPU_TYPER;                   /*!< (@ 0x00000000) MPU type register                                          */
    
    struct {
      __IM  uint32_t SEPARATE   : 1;            /*!< [0..0] Separate flag                                                      */
            uint32_t            : 7;
      __IM  uint32_t DREGION    : 8;            /*!< [15..8] Number of MPU data regions                                        */
      __IM  uint32_t IREGION    : 8;            /*!< [23..16] Number of MPU instruction regions                                */
            uint32_t            : 8;
    } MPU_TYPER_b;
  } ;
  
  union {
    __IOM uint32_t MPU_CTRL;                    /*!< (@ 0x00000004) MPU control register                                       */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the MPU                                                    */
      __IOM uint32_t HFNMIENA   : 1;            /*!< [1..1] Enables the operation of MPU during hard fault                     */
      __IOM uint32_t PRIVDEFENA : 1;            /*!< [2..2] Enable priviliged software access to default memory map            */
            uint32_t            : 29;
    } MPU_CTRL_b;
  } ;
  
  union {
    __IOM uint32_t MPU_RNR;                     /*!< (@ 0x00000008) MPU region number register                                 */
    
    struct {
      __IOM uint32_t REGION     : 8;            /*!< [7..0] MPU region                                                         */
            uint32_t            : 24;
    } MPU_RNR_b;
  } ;
  
  union {
    __IOM uint32_t MPU_RBAR;                    /*!< (@ 0x0000000C) MPU region base address register                           */
    
    struct {
      __IOM uint32_t REGION     : 4;            /*!< [3..0] MPU region field                                                   */
      __IOM uint32_t VALID      : 1;            /*!< [4..4] MPU region number valid                                            */
      __IOM uint32_t ADDR       : 27;           /*!< [31..5] Region base address field                                         */
    } MPU_RBAR_b;
  } ;
  
  union {
    __IOM uint32_t MPU_RASR;                    /*!< (@ 0x00000010) MPU region attribute and size register                     */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Region enable bit.                                                 */
      __IOM uint32_t SIZE       : 5;            /*!< [5..1] Size of the MPU protection region                                  */
            uint32_t            : 2;
      __IOM uint32_t SRD        : 8;            /*!< [15..8] Subregion disable bits                                            */
      __IOM uint32_t B          : 1;            /*!< [16..16] memory attribute                                                 */
      __IOM uint32_t C          : 1;            /*!< [17..17] memory attribute                                                 */
      __IOM uint32_t S          : 1;            /*!< [18..18] Shareable memory attribute                                       */
      __IOM uint32_t TEX        : 3;            /*!< [21..19] memory attribute                                                 */
            uint32_t            : 2;
      __IOM uint32_t AP         : 3;            /*!< [26..24] Access permission                                                */
            uint32_t            : 1;
      __IOM uint32_t XN         : 1;            /*!< [28..28] Instruction access disable bit                                   */
            uint32_t            : 3;
    } MPU_RASR_b;
  } ;
} MPU_Type;                                     /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            STK                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SysTick timer (STK)
  */

typedef struct {                                /*!< (@ 0xE000E010) STK Structure                                              */
  
  union {
    __IOM uint32_t CSR;                         /*!< (@ 0x00000000) SysTick control and status register                        */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Counter enable                                                     */
      __IOM uint32_t TICKINT    : 1;            /*!< [1..1] SysTick exception request enable                                   */
      __IOM uint32_t CLKSOURCE  : 1;            /*!< [2..2] Clock source selection                                             */
            uint32_t            : 13;
      __IOM uint32_t COUNTFLAG  : 1;            /*!< [16..16] COUNTFLAG                                                        */
            uint32_t            : 15;
    } CSR_b;
  } ;
  
  union {
    __IOM uint32_t RVR;                         /*!< (@ 0x00000004) SysTick reload value register                              */
    
    struct {
      __IOM uint32_t RELOAD     : 24;           /*!< [23..0] RELOAD value                                                      */
            uint32_t            : 8;
    } RVR_b;
  } ;
  
  union {
    __IOM uint32_t CVR;                         /*!< (@ 0x00000008) SysTick current value register                             */
    
    struct {
      __IOM uint32_t CURRENT    : 24;           /*!< [23..0] Current counter value                                             */
            uint32_t            : 8;
    } CVR_b;
  } ;
  
  union {
    __IOM uint32_t CALIB;                       /*!< (@ 0x0000000C) SysTick calibration value register                         */
    
    struct {
      __IOM uint32_t TENMS      : 24;           /*!< [23..0] Calibration value                                                 */
            uint32_t            : 6;
      __IOM uint32_t SKEW       : 1;            /*!< [30..30] SKEW flag: Indicates whether the TENMS value is exact            */
      __IOM uint32_t NOREF      : 1;            /*!< [31..31] NOREF flag. Reads as zero                                        */
    } CALIB_b;
  } ;
} STK_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                         NVIC_STIR                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Nested vectored interrupt
      controller (NVIC_STIR)
  */

typedef struct {                                /*!< (@ 0xE000EF00) NVIC_STIR Structure                                        */
  
  union {
    __IOM uint32_t STIR;                        /*!< (@ 0x00000000) Software trigger interrupt register                        */
    
    struct {
      __IOM uint32_t INTID      : 9;            /*!< [8..0] Software generated interrupt ID                                    */
            uint32_t            : 23;
    } STIR_b;
  } ;
} NVIC_STIR_Type;                               /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                         FPU_CPACR                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Floating point unit CPACR (FPU_CPACR)
  */

typedef struct {                                /*!< (@ 0xE000ED88) FPU_CPACR Structure                                        */
  
  union {
    __IOM uint32_t CPACR;                       /*!< (@ 0x00000000) Coprocessor access control register                        */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t CP         : 4;            /*!< [23..20] CP                                                               */
            uint32_t            : 8;
    } CPACR_b;
  } ;
} FPU_CPACR_Type;                               /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                         SCB_ACTRL                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief System control block ACTLR (SCB_ACTRL)
  */

typedef struct {                                /*!< (@ 0xE000E008) SCB_ACTRL Structure                                        */
  
  union {
    __IOM uint32_t ACTRL;                       /*!< (@ 0x00000000) Auxiliary control register                                 */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t DISFOLD    : 1;            /*!< [2..2] DISFOLD                                                            */
            uint32_t            : 7;
      __IOM uint32_t FPEXCODIS  : 1;            /*!< [10..10] FPEXCODIS                                                        */
      __IOM uint32_t DISRAMODE  : 1;            /*!< [11..11] DISRAMODE                                                        */
      __IOM uint32_t DISITMATBFLUSH : 1;        /*!< [12..12] DISITMATBFLUSH                                                   */
            uint32_t            : 19;
    } ACTRL_b;
  } ;
} SCB_ACTRL_Type;                               /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                            FPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Floting point unit (FPU)
  */

typedef struct {                                /*!< (@ 0xE000EF34) FPU Structure                                              */
  
  union {
    __IOM uint32_t FPCCR;                       /*!< (@ 0x00000000) Floating-point context control register                    */
    
    struct {
      __IOM uint32_t LSPACT     : 1;            /*!< [0..0] LSPACT                                                             */
      __IOM uint32_t USER       : 1;            /*!< [1..1] USER                                                               */
            uint32_t            : 1;
      __IOM uint32_t THREAD     : 1;            /*!< [3..3] THREAD                                                             */
      __IOM uint32_t HFRDY      : 1;            /*!< [4..4] HFRDY                                                              */
      __IOM uint32_t MMRDY      : 1;            /*!< [5..5] MMRDY                                                              */
      __IOM uint32_t BFRDY      : 1;            /*!< [6..6] BFRDY                                                              */
            uint32_t            : 1;
      __IOM uint32_t MONRDY     : 1;            /*!< [8..8] MONRDY                                                             */
            uint32_t            : 21;
      __IOM uint32_t LSPEN      : 1;            /*!< [30..30] LSPEN                                                            */
      __IOM uint32_t ASPEN      : 1;            /*!< [31..31] ASPEN                                                            */
    } FPCCR_b;
  } ;
  
  union {
    __IOM uint32_t FPCAR;                       /*!< (@ 0x00000004) Floating-point context address register                    */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t ADDRESS    : 29;           /*!< [31..3] Location of unpopulated floating-point                            */
    } FPCAR_b;
  } ;
  
  union {
    __IOM uint32_t FPSCR;                       /*!< (@ 0x00000008) Floating-point status control register                     */
    
    struct {
      __IOM uint32_t IOC        : 1;            /*!< [0..0] Invalid operation cumulative exception bit                         */
      __IOM uint32_t DZC        : 1;            /*!< [1..1] Division by zero cumulative exception bit.                         */
      __IOM uint32_t OFC        : 1;            /*!< [2..2] Overflow cumulative exception bit                                  */
      __IOM uint32_t UFC        : 1;            /*!< [3..3] Underflow cumulative exception bit                                 */
      __IOM uint32_t IXC        : 1;            /*!< [4..4] Inexact cumulative exception bit                                   */
            uint32_t            : 2;
      __IOM uint32_t IDC        : 1;            /*!< [7..7] Input denormal cumulative exception bit.                           */
            uint32_t            : 14;
      __IOM uint32_t RMode      : 2;            /*!< [23..22] Rounding Mode control field                                      */
      __IOM uint32_t FZ         : 1;            /*!< [24..24] Flush-to-zero mode control bit:                                  */
      __IOM uint32_t DN         : 1;            /*!< [25..25] Default NaN mode control bit                                     */
      __IOM uint32_t AHP        : 1;            /*!< [26..26] Alternative half-precision control bit                           */
            uint32_t            : 1;
      __IOM uint32_t V          : 1;            /*!< [28..28] Overflow condition code flag                                     */
      __IOM uint32_t C          : 1;            /*!< [29..29] Carry condition code flag                                        */
      __IOM uint32_t Z          : 1;            /*!< [30..30] Zero condition code flag                                         */
      __IOM uint32_t N          : 1;            /*!< [31..31] Negative condition code flag                                     */
    } FPSCR_b;
  } ;
} FPU_Type;                                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            SCB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System control block (SCB)
  */

typedef struct {                                /*!< (@ 0xE000ED00) SCB Structure                                              */
  
  union {
    __IM  uint32_t CPUID;                       /*!< (@ 0x00000000) CPUID base register                                        */
    
    struct {
      __IM  uint32_t Revision   : 4;            /*!< [3..0] Revision number                                                    */
      __IM  uint32_t PartNo     : 12;           /*!< [15..4] Part number of the processor                                      */
      __IM  uint32_t Constant   : 4;            /*!< [19..16] Reads as 0xF                                                     */
      __IM  uint32_t Variant    : 4;            /*!< [23..20] Variant number                                                   */
      __IM  uint32_t Implementer : 8;           /*!< [31..24] Implementer code                                                 */
    } CPUID_b;
  } ;
  
  union {
    __IOM uint32_t ICSR;                        /*!< (@ 0x00000004) Interrupt control and state register                       */
    
    struct {
      __IOM uint32_t VECTACTIVE : 9;            /*!< [8..0] Active vector                                                      */
            uint32_t            : 2;
      __IOM uint32_t RETTOBASE  : 1;            /*!< [11..11] Return to base level                                             */
      __IOM uint32_t VECTPENDING : 7;           /*!< [18..12] Pending vector                                                   */
            uint32_t            : 3;
      __IOM uint32_t ISRPENDING : 1;            /*!< [22..22] Interrupt pending flag                                           */
            uint32_t            : 2;
      __IOM uint32_t PENDSTCLR  : 1;            /*!< [25..25] SysTick exception clear-pending bit                              */
      __IOM uint32_t PENDSTSET  : 1;            /*!< [26..26] SysTick exception set-pending bit                                */
      __IOM uint32_t PENDSVCLR  : 1;            /*!< [27..27] PendSV clear-pending bit                                         */
      __IOM uint32_t PENDSVSET  : 1;            /*!< [28..28] PendSV set-pending bit                                           */
            uint32_t            : 2;
      __IOM uint32_t NMIPENDSET : 1;            /*!< [31..31] NMI set-pending bit.                                             */
    } ICSR_b;
  } ;
  
  union {
    __IOM uint32_t VTOR;                        /*!< (@ 0x00000008) Vector table offset register                               */
    
    struct {
            uint32_t            : 9;
      __IOM uint32_t TBLOFF     : 21;           /*!< [29..9] Vector table base offset field                                    */
            uint32_t            : 2;
    } VTOR_b;
  } ;
  
  union {
    __IOM uint32_t AIRCR;                       /*!< (@ 0x0000000C) Application interrupt and reset control register           */
    
    struct {
      __IOM uint32_t VECTRESET  : 1;            /*!< [0..0] VECTRESET                                                          */
      __IOM uint32_t VECTCLRACTIVE : 1;         /*!< [1..1] VECTCLRACTIVE                                                      */
      __IOM uint32_t SYSRESETREQ : 1;           /*!< [2..2] SYSRESETREQ                                                        */
            uint32_t            : 5;
      __IOM uint32_t PRIGROUP   : 3;            /*!< [10..8] PRIGROUP                                                          */
            uint32_t            : 4;
      __IOM uint32_t ENDIANESS  : 1;            /*!< [15..15] ENDIANESS                                                        */
      __IOM uint32_t VECTKEYSTAT : 16;          /*!< [31..16] Register key                                                     */
    } AIRCR_b;
  } ;
  
  union {
    __IOM uint32_t SCR;                         /*!< (@ 0x00000010) System control register                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< [1..1] SLEEPONEXIT                                                        */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< [2..2] SLEEPDEEP                                                          */
            uint32_t            : 1;
      __IOM uint32_t SEVEONPEND : 1;            /*!< [4..4] Send Event on Pending bit                                          */
            uint32_t            : 27;
    } SCR_b;
  } ;
  
  union {
    __IOM uint32_t CCR;                         /*!< (@ 0x00000014) Configuration and control register                         */
    
    struct {
      __IOM uint32_t NONBASETHRDENA : 1;        /*!< [0..0] Configures how the processor enters Thread mode                    */
      __IOM uint32_t USERSETMPEND : 1;          /*!< [1..1] USERSETMPEND                                                       */
            uint32_t            : 1;
      __IOM uint32_t UNALIGN__TRP : 1;          /*!< [3..3] UNALIGN_ TRP                                                       */
      __IOM uint32_t DIV_0_TRP  : 1;            /*!< [4..4] DIV_0_TRP                                                          */
            uint32_t            : 3;
      __IOM uint32_t BFHFNMIGN  : 1;            /*!< [8..8] BFHFNMIGN                                                          */
      __IOM uint32_t STKALIGN   : 1;            /*!< [9..9] STKALIGN                                                           */
            uint32_t            : 6;
      __IOM uint32_t DC         : 1;            /*!< [16..16] DC                                                               */
      __IOM uint32_t IC         : 1;            /*!< [17..17] IC                                                               */
      __IOM uint32_t BP         : 1;            /*!< [18..18] BP                                                               */
            uint32_t            : 13;
    } CCR_b;
  } ;
  
  union {
    __IOM uint32_t SHPR1;                       /*!< (@ 0x00000018) System handler priority registers                          */
    
    struct {
      __IOM uint32_t PRI_4      : 8;            /*!< [7..0] Priority of system handler 4                                       */
      __IOM uint32_t PRI_5      : 8;            /*!< [15..8] Priority of system handler 5                                      */
      __IOM uint32_t PRI_6      : 8;            /*!< [23..16] Priority of system handler 6                                     */
            uint32_t            : 8;
    } SHPR1_b;
  } ;
  
  union {
    __IOM uint32_t SHPR2;                       /*!< (@ 0x0000001C) System handler priority registers                          */
    
    struct {
            uint32_t            : 24;
      __IOM uint32_t PRI_11     : 8;            /*!< [31..24] Priority of system handler 11                                    */
    } SHPR2_b;
  } ;
  
  union {
    __IOM uint32_t SHPR3;                       /*!< (@ 0x00000020) System handler priority registers                          */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t PRI_14     : 8;            /*!< [23..16] Priority of system handler 14                                    */
      __IOM uint32_t PRI_15     : 8;            /*!< [31..24] Priority of system handler 15                                    */
    } SHPR3_b;
  } ;
  
  union {
    __IOM uint32_t SHCSR;                       /*!< (@ 0x00000024) System handler control and state register                  */
    
    struct {
      __IOM uint32_t MEMFAULTACT : 1;           /*!< [0..0] Memory management fault exception active bit                       */
      __IOM uint32_t BUSFAULTACT : 1;           /*!< [1..1] Bus fault exception active bit                                     */
            uint32_t            : 1;
      __IOM uint32_t USGFAULTACT : 1;           /*!< [3..3] Usage fault exception active bit                                   */
            uint32_t            : 3;
      __IOM uint32_t SVCALLACT  : 1;            /*!< [7..7] SVC call active bit                                                */
      __IOM uint32_t MONITORACT : 1;            /*!< [8..8] Debug monitor active bit                                           */
            uint32_t            : 1;
      __IOM uint32_t PENDSVACT  : 1;            /*!< [10..10] PendSV exception active bit                                      */
      __IOM uint32_t SYSTICKACT : 1;            /*!< [11..11] SysTick exception active bit                                     */
      __IOM uint32_t USGFAULTPENDED : 1;        /*!< [12..12] Usage fault exception pending bit                                */
      __IOM uint32_t MEMFAULTPENDED : 1;        /*!< [13..13] Memory management fault exception pending bit                    */
      __IOM uint32_t BUSFAULTPENDED : 1;        /*!< [14..14] Bus fault exception pending bit                                  */
      __IOM uint32_t SVCALLPENDED : 1;          /*!< [15..15] SVC call pending bit                                             */
      __IOM uint32_t MEMFAULTENA : 1;           /*!< [16..16] Memory management fault enable bit                               */
      __IOM uint32_t BUSFAULTENA : 1;           /*!< [17..17] Bus fault enable bit                                             */
      __IOM uint32_t USGFAULTENA : 1;           /*!< [18..18] Usage fault enable bit                                           */
            uint32_t            : 13;
    } SHCSR_b;
  } ;
  
  union {
    __IOM uint32_t CFSR_UFSR_BFSR_MMFSR;        /*!< (@ 0x00000028) Configurable fault status register                         */
    
    struct {
      __IOM uint32_t IACCVIOL   : 1;            /*!< [0..0] IACCVIOL                                                           */
      __IOM uint32_t DACCVIOL   : 1;            /*!< [1..1] DACCVIOL                                                           */
            uint32_t            : 1;
      __IOM uint32_t MUNSTKERR  : 1;            /*!< [3..3] MUNSTKERR                                                          */
      __IOM uint32_t MSTKERR    : 1;            /*!< [4..4] MSTKERR                                                            */
      __IOM uint32_t MLSPERR    : 1;            /*!< [5..5] MLSPERR                                                            */
            uint32_t            : 1;
      __IOM uint32_t MMARVALID  : 1;            /*!< [7..7] MMARVALID                                                          */
      __IOM uint32_t IBUSERR    : 1;            /*!< [8..8] Instruction bus error                                              */
      __IOM uint32_t PRECISERR  : 1;            /*!< [9..9] Precise data bus error                                             */
      __IOM uint32_t IMPRECISERR : 1;           /*!< [10..10] Imprecise data bus error                                         */
      __IOM uint32_t UNSTKERR   : 1;            /*!< [11..11] Bus fault on unstacking for a return from exception              */
      __IOM uint32_t STKERR     : 1;            /*!< [12..12] Bus fault on stacking for exception entry                        */
      __IOM uint32_t LSPERR     : 1;            /*!< [13..13] Bus fault on floating-point lazy state preservation              */
            uint32_t            : 1;
      __IOM uint32_t BFARVALID  : 1;            /*!< [15..15] Bus Fault Address Register (BFAR) valid flag                     */
      __IOM uint32_t UNDEFINSTR : 1;            /*!< [16..16] Undefined instruction usage fault                                */
      __IOM uint32_t INVSTATE   : 1;            /*!< [17..17] Invalid state usage fault                                        */
      __IOM uint32_t INVPC      : 1;            /*!< [18..18] Invalid PC load usage fault                                      */
      __IOM uint32_t NOCP       : 1;            /*!< [19..19] No coprocessor usage fault.                                      */
            uint32_t            : 4;
      __IOM uint32_t UNALIGNED  : 1;            /*!< [24..24] Unaligned access usage fault                                     */
      __IOM uint32_t DIVBYZERO  : 1;            /*!< [25..25] Divide by zero usage fault                                       */
            uint32_t            : 6;
    } CFSR_UFSR_BFSR_MMFSR_b;
  } ;
  
  union {
    __IOM uint32_t HFSR;                        /*!< (@ 0x0000002C) Hard fault status register                                 */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t VECTTBL    : 1;            /*!< [1..1] Vector table hard fault                                            */
            uint32_t            : 28;
      __IOM uint32_t FORCED     : 1;            /*!< [30..30] Forced hard fault                                                */
      __IOM uint32_t DEBUG_VT   : 1;            /*!< [31..31] Reserved for Debug use                                           */
    } HFSR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t MMFAR;                       /*!< (@ 0x00000034) Memory management fault address register                   */
    
    struct {
      __IOM uint32_t ADDRESS    : 32;           /*!< [31..0] Memory management fault address                                   */
    } MMFAR_b;
  } ;
  
  union {
    __IOM uint32_t BFAR;                        /*!< (@ 0x00000038) Bus fault address register                                 */
    
    struct {
      __IOM uint32_t ADDRESS    : 32;           /*!< [31..0] Bus fault address                                                 */
    } BFAR_b;
  } ;
} SCB_Type;                                     /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                            PF                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief Processor features (PF)
  */

typedef struct {                                /*!< (@ 0xE000ED78) PF Structure                                               */
  
  union {
    __IM  uint32_t CLIDR;                       /*!< (@ 0x00000000) Cache Level ID register                                    */
    
    struct {
      __IM  uint32_t CL1        : 3;            /*!< [2..0] CL1                                                                */
      __IM  uint32_t CL2        : 3;            /*!< [5..3] CL2                                                                */
      __IM  uint32_t CL3        : 3;            /*!< [8..6] CL3                                                                */
      __IM  uint32_t CL4        : 3;            /*!< [11..9] CL4                                                               */
      __IM  uint32_t CL5        : 3;            /*!< [14..12] CL5                                                              */
      __IM  uint32_t CL6        : 3;            /*!< [17..15] CL6                                                              */
      __IM  uint32_t CL7        : 3;            /*!< [20..18] CL7                                                              */
      __IM  uint32_t LoUIS      : 3;            /*!< [23..21] LoUIS                                                            */
      __IM  uint32_t LoC        : 3;            /*!< [26..24] LoC                                                              */
      __IM  uint32_t LoU        : 3;            /*!< [29..27] LoU                                                              */
            uint32_t            : 2;
    } CLIDR_b;
  } ;
  
  union {
    __IM  uint32_t CTR;                         /*!< (@ 0x00000004) Cache Type register                                        */
    
    struct {
      __IM  uint32_t _IminLine  : 4;            /*!< [3..0] IminLine                                                           */
            uint32_t            : 12;
      __IM  uint32_t DMinLine   : 4;            /*!< [19..16] DMinLine                                                         */
      __IM  uint32_t ERG        : 4;            /*!< [23..20] ERG                                                              */
      __IM  uint32_t CWG        : 4;            /*!< [27..24] CWG                                                              */
            uint32_t            : 1;
      __IM  uint32_t Format     : 3;            /*!< [31..29] Format                                                           */
    } CTR_b;
  } ;
  
  union {
    __IM  uint32_t CCSIDR;                      /*!< (@ 0x00000008) Cache Size ID register                                     */
    
    struct {
      __IM  uint32_t LineSize   : 3;            /*!< [2..0] LineSize                                                           */
      __IM  uint32_t Associativity : 10;        /*!< [12..3] Associativity                                                     */
      __IM  uint32_t NumSets    : 15;           /*!< [27..13] NumSets                                                          */
      __IM  uint32_t WA         : 1;            /*!< [28..28] WA                                                               */
      __IM  uint32_t RA         : 1;            /*!< [29..29] RA                                                               */
      __IM  uint32_t WB         : 1;            /*!< [30..30] WB                                                               */
      __IM  uint32_t WT         : 1;            /*!< [31..31] WT                                                               */
    } CCSIDR_b;
  } ;
} PF_Type;                                      /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            AC                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief Access control (AC)
  */

typedef struct {                                /*!< (@ 0xE000EF90) AC Structure                                               */
  
  union {
    __IOM uint32_t ITCMCR;                      /*!< (@ 0x00000000) Instruction and Data Tightly-Coupled Memory Control
                                                                    Registers                                                  */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] EN                                                                 */
      __IOM uint32_t RMW        : 1;            /*!< [1..1] RMW                                                                */
      __IOM uint32_t RETEN      : 1;            /*!< [2..2] RETEN                                                              */
      __IOM uint32_t SZ         : 4;            /*!< [6..3] SZ                                                                 */
            uint32_t            : 25;
    } ITCMCR_b;
  } ;
  
  union {
    __IOM uint32_t DTCMCR;                      /*!< (@ 0x00000004) Instruction and Data Tightly-Coupled Memory Control
                                                                    Registers                                                  */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] EN                                                                 */
      __IOM uint32_t RMW        : 1;            /*!< [1..1] RMW                                                                */
      __IOM uint32_t RETEN      : 1;            /*!< [2..2] RETEN                                                              */
      __IOM uint32_t SZ         : 4;            /*!< [6..3] SZ                                                                 */
            uint32_t            : 25;
    } DTCMCR_b;
  } ;
  
  union {
    __IOM uint32_t AHBPCR;                      /*!< (@ 0x00000008) AHBP Control register                                      */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] EN                                                                 */
      __IOM uint32_t SZ         : 3;            /*!< [3..1] SZ                                                                 */
            uint32_t            : 28;
    } AHBPCR_b;
  } ;
  
  union {
    __IOM uint32_t CACR;                        /*!< (@ 0x0000000C) Auxiliary Cache Control register                           */
    
    struct {
      __IOM uint32_t SIWT       : 1;            /*!< [0..0] SIWT                                                               */
      __IOM uint32_t ECCEN      : 1;            /*!< [1..1] ECCEN                                                              */
      __IOM uint32_t FORCEWT    : 1;            /*!< [2..2] FORCEWT                                                            */
            uint32_t            : 29;
    } CACR_b;
  } ;
  
  union {
    __IOM uint32_t AHBSCR;                      /*!< (@ 0x00000010) AHB Slave Control register                                 */
    
    struct {
      __IOM uint32_t CTL        : 2;            /*!< [1..0] CTL                                                                */
      __IOM uint32_t TPRI       : 9;            /*!< [10..2] TPRI                                                              */
      __IOM uint32_t INITCOUNT  : 5;            /*!< [15..11] INITCOUNT                                                        */
            uint32_t            : 16;
    } AHBSCR_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ABFSR;                       /*!< (@ 0x00000018) Auxiliary Bus Fault Status register                        */
    
    struct {
      __IOM uint32_t ITCM       : 1;            /*!< [0..0] ITCM                                                               */
      __IOM uint32_t DTCM       : 1;            /*!< [1..1] DTCM                                                               */
      __IOM uint32_t AHBP       : 1;            /*!< [2..2] AHBP                                                               */
      __IOM uint32_t AXIM       : 1;            /*!< [3..3] AXIM                                                               */
      __IOM uint32_t EPPB       : 1;            /*!< [4..4] EPPB                                                               */
            uint32_t            : 3;
      __IOM uint32_t AXIMTYPE   : 2;            /*!< [9..8] AXIMTYPE                                                           */
            uint32_t            : 22;
    } ABFSR_b;
  } ;
} AC_Type;                                      /*!< Size = 28 (0x1c)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define COMP1_BASE                  0x58003800UL
#define CRS_BASE                    0x40008400UL
#define DAC_BASE                    0x40007400UL
#define BDMA_BASE                   0x58025400UL
#define DMA2D_BASE                  0x52001000UL
#define DMAMUX2_BASE                0x58025800UL
#define FMC_BASE                    0x52004000UL
#define CEC_BASE                    0x40006C00UL
#define HSEM_BASE                   0x58026400UL
#define I2C1_BASE                   0x40005400UL
#define I2C2_BASE                   0x40005800UL
#define I2C3_BASE                   0x40005C00UL
#define I2C4_BASE                   0x58001C00UL
#define GPIOA_BASE                  0x58020000UL
#define GPIOB_BASE                  0x58020400UL
#define GPIOC_BASE                  0x58020800UL
#define GPIOD_BASE                  0x58020C00UL
#define GPIOE_BASE                  0x58021000UL
#define GPIOF_BASE                  0x58021400UL
#define GPIOG_BASE                  0x58021800UL
#define GPIOH_BASE                  0x58021C00UL
#define GPIOI_BASE                  0x58022000UL
#define GPIOJ_BASE                  0x58022400UL
#define GPIOK_BASE                  0x58022800UL
#define JPEG_BASE                   0x52003000UL
#define MDMA_BASE                   0x52000000UL
#define QUADSPI_BASE                0x52005000UL
#define RNG_BASE                    0x48021800UL
#define RTC_BASE                    0x58004000UL
#define SAI4_BASE                   0x58005400UL
#define SAI1_BASE                   0x40015800UL
#define SAI2_BASE                   0x40015C00UL
#define SAI3_BASE                   0x40016000UL
#define SDMMC1_BASE                 0x52007000UL
#define SDMMC2_BASE                 0x48022400UL
#define VREFBUF_BASE                0x58003C00UL
#define IWDG_BASE                   0x58004800UL
#define WWDG_BASE                   0x50003000UL
#define PWR_BASE                    0x58024800UL
#define SPI1_BASE                   0x40013000UL
#define SPI2_BASE                   0x40003800UL
#define SPI3_BASE                   0x40003C00UL
#define SPI4_BASE                   0x40013400UL
#define SPI5_BASE                   0x40015000UL
#define SPI6_BASE                   0x58001400UL
#define LTDC_BASE                   0x50001000UL
#define SPDIFRX_BASE                0x40004000UL
#define ADC3_BASE                   0x58026000UL
#define ADC1_BASE                   0x40022000UL
#define ADC2_BASE                   0x40022100UL
#define ADC3_Common_BASE            0x58026300UL
#define ADC12_Common_BASE           0x40022300UL
#define DMAMUX1_BASE                0x40020800UL
#define CRC_BASE                    0x58024C00UL
#define RCC_BASE                    0x58024400UL
#define LPTIM1_BASE                 0x40002400UL
#define LPTIM2_BASE                 0x58002400UL
#define LPTIM3_BASE                 0x58002800UL
#define LPTIM4_BASE                 0x58002C00UL
#define LPTIM5_BASE                 0x58003000UL
#define LPUART1_BASE                0x58000C00UL
#define SYSCFG_BASE                 0x58000400UL
#define EXTI_BASE                   0x58000000UL
#define DELAY_Block_SDMMC1_BASE     0x52008000UL
#define DELAY_Block_QUADSPI_BASE    0x52006000UL
#define DELAY_Block_SDMMC2_BASE     0x48022800UL
#define Flash_BASE                  0x52002000UL
#define AXI_BASE                    0x51000000UL
#define HASH_BASE                   0x48021400UL
#define CRYP_BASE                   0x48021000UL
#define DCMI_BASE                   0x48020000UL
#define OTG1_HS_GLOBAL_BASE         0x40040000UL
#define OTG2_HS_GLOBAL_BASE         0x40080000UL
#define OTG1_HS_HOST_BASE           0x40040400UL
#define OTG2_HS_HOST_BASE           0x40080400UL
#define OTG1_HS_DEVICE_BASE         0x40040800UL
#define OTG2_HS_DEVICE_BASE         0x40080800UL
#define OTG1_HS_PWRCLK_BASE         0x40040E00UL
#define OTG2_HS_PWRCLK_BASE         0x40080E00UL
#define Ethernet_MAC_BASE           0x40028000UL
#define DMA1_BASE                   0x40020000UL
#define DMA2_BASE                   0x40020400UL
#define HRTIM_Master_BASE           0x40017400UL
#define HRTIM_TIMA_BASE             0x40017480UL
#define HRTIM_TIMB_BASE             0x40017500UL
#define HRTIM_TIMC_BASE             0x40017580UL
#define HRTIM_TIMD_BASE             0x40017600UL
#define HRTIM_TIME_BASE             0x40017680UL
#define HRTIM_Common_BASE           0x40017780UL
#define DFSDM_BASE                  0x40017000UL
#define TIM16_BASE                  0x40014400UL
#define TIM17_BASE                  0x40014800UL
#define TIM15_BASE                  0x40014000UL
#define USART1_BASE                 0x40011000UL
#define USART2_BASE                 0x40004400UL
#define USART3_BASE                 0x40004800UL
#define UART4_BASE                  0x40004C00UL
#define UART5_BASE                  0x40005000UL
#define USART6_BASE                 0x40011400UL
#define UART7_BASE                  0x40007800UL
#define UART8_BASE                  0x40007C00UL
#define TIM1_BASE                   0x40010000UL
#define TIM8_BASE                   0x40010400UL
#define FDCAN1_BASE                 0x4000A000UL
#define FDCAN2_BASE                 0x4000A400UL
#define CAN_CCU_BASE                0x4000A800UL
#define MDIOS_BASE                  0x40009400UL
#define OPAMP_BASE                  0x40009000UL
#define SWPMI_BASE                  0x40008800UL
#define TIM2_BASE                   0x40000000UL
#define TIM3_BASE                   0x40000400UL
#define TIM4_BASE                   0x40000800UL
#define TIM5_BASE                   0x40000C00UL
#define TIM12_BASE                  0x40001800UL
#define TIM13_BASE                  0x40001C00UL
#define TIM14_BASE                  0x40002000UL
#define TIM6_BASE                   0x40001000UL
#define TIM7_BASE                   0x40001400UL
#define NVIC_BASE                   0xE000E100UL
#define DBGMCU_BASE                 0x5C001000UL
#define MPU_BASE                    0xE000ED90UL
#define STK_BASE                    0xE000E010UL
#define NVIC_STIR_BASE              0xE000EF00UL
#define FPU_CPACR_BASE              0xE000ED88UL
#define SCB_ACTRL_BASE              0xE000E008UL
#define FPU_BASE                    0xE000EF34UL
#define SCB_BASE                    0xE000ED00UL
#define PF_BASE                     0xE000ED78UL
#define AC_BASE                     0xE000EF90UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define COMP1                       ((COMP1_Type*)             COMP1_BASE)
#define CRS                         ((CRS_Type*)               CRS_BASE)
#define DAC                         ((DAC_Type*)               DAC_BASE)
#define BDMA                        ((BDMA_Type*)              BDMA_BASE)
#define DMA2D                       ((DMA2D_Type*)             DMA2D_BASE)
#define DMAMUX2                     ((DMAMUX2_Type*)           DMAMUX2_BASE)
#define FMC                         ((FMC_Type*)               FMC_BASE)
#define CEC                         ((CEC_Type*)               CEC_BASE)
#define HSEM                        ((HSEM_Type*)              HSEM_BASE)
#define I2C1                        ((I2C1_Type*)              I2C1_BASE)
#define I2C2                        ((I2C1_Type*)              I2C2_BASE)
#define I2C3                        ((I2C1_Type*)              I2C3_BASE)
#define I2C4                        ((I2C1_Type*)              I2C4_BASE)
#define GPIOA                       ((GPIOA_Type*)             GPIOA_BASE)
#define GPIOB                       ((GPIOA_Type*)             GPIOB_BASE)
#define GPIOC                       ((GPIOA_Type*)             GPIOC_BASE)
#define GPIOD                       ((GPIOA_Type*)             GPIOD_BASE)
#define GPIOE                       ((GPIOA_Type*)             GPIOE_BASE)
#define GPIOF                       ((GPIOA_Type*)             GPIOF_BASE)
#define GPIOG                       ((GPIOA_Type*)             GPIOG_BASE)
#define GPIOH                       ((GPIOA_Type*)             GPIOH_BASE)
#define GPIOI                       ((GPIOA_Type*)             GPIOI_BASE)
#define GPIOJ                       ((GPIOA_Type*)             GPIOJ_BASE)
#define GPIOK                       ((GPIOA_Type*)             GPIOK_BASE)
#define JPEG                        ((JPEG_Type*)              JPEG_BASE)
#define MDMA                        ((MDMA_Type*)              MDMA_BASE)
#define QUADSPI                     ((QUADSPI_Type*)           QUADSPI_BASE)
#define RNG                         ((RNG_Type*)               RNG_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define SAI4                        ((SAI4_Type*)              SAI4_BASE)
#define SAI1                        ((SAI4_Type*)              SAI1_BASE)
#define SAI2                        ((SAI4_Type*)              SAI2_BASE)
#define SAI3                        ((SAI4_Type*)              SAI3_BASE)
#define SDMMC1                      ((SDMMC1_Type*)            SDMMC1_BASE)
#define SDMMC2                      ((SDMMC1_Type*)            SDMMC2_BASE)
#define VREFBUF                     ((VREFBUF_Type*)           VREFBUF_BASE)
#define IWDG                        ((IWDG_Type*)              IWDG_BASE)
#define WWDG                        ((WWDG_Type*)              WWDG_BASE)
#define PWR                         ((PWR_Type*)               PWR_BASE)
#define SPI1                        ((SPI1_Type*)              SPI1_BASE)
#define SPI2                        ((SPI1_Type*)              SPI2_BASE)
#define SPI3                        ((SPI1_Type*)              SPI3_BASE)
#define SPI4                        ((SPI1_Type*)              SPI4_BASE)
#define SPI5                        ((SPI1_Type*)              SPI5_BASE)
#define SPI6                        ((SPI1_Type*)              SPI6_BASE)
#define LTDC                        ((LTDC_Type*)              LTDC_BASE)
#define SPDIFRX                     ((SPDIFRX_Type*)           SPDIFRX_BASE)
#define ADC3                        ((ADC3_Type*)              ADC3_BASE)
#define ADC1                        ((ADC3_Type*)              ADC1_BASE)
#define ADC2                        ((ADC3_Type*)              ADC2_BASE)
#define ADC3_Common                 ((ADC3_Common_Type*)       ADC3_Common_BASE)
#define ADC12_Common                ((ADC3_Common_Type*)       ADC12_Common_BASE)
#define DMAMUX1                     ((DMAMUX1_Type*)           DMAMUX1_BASE)
#define CRC                         ((CRC_Type*)               CRC_BASE)
#define RCC                         ((RCC_Type*)               RCC_BASE)
#define LPTIM1                      ((LPTIM1_Type*)            LPTIM1_BASE)
#define LPTIM2                      ((LPTIM1_Type*)            LPTIM2_BASE)
#define LPTIM3                      ((LPTIM3_Type*)            LPTIM3_BASE)
#define LPTIM4                      ((LPTIM3_Type*)            LPTIM4_BASE)
#define LPTIM5                      ((LPTIM3_Type*)            LPTIM5_BASE)
#define LPUART1                     ((LPUART1_Type*)           LPUART1_BASE)
#define SYSCFG                      ((SYSCFG_Type*)            SYSCFG_BASE)
#define EXTI                        ((EXTI_Type*)              EXTI_BASE)
#define DELAY_Block_SDMMC1          ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_SDMMC1_BASE)
#define DELAY_Block_QUADSPI         ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_QUADSPI_BASE)
#define DELAY_Block_SDMMC2          ((DELAY_Block_SDMMC1_Type*)  DELAY_Block_SDMMC2_BASE)
#define Flash                       ((Flash_Type*)             Flash_BASE)
#define AXI                         ((AXI_Type*)               AXI_BASE)
#define HASH                        ((HASH_Type*)              HASH_BASE)
#define CRYP                        ((CRYP_Type*)              CRYP_BASE)
#define DCMI                        ((DCMI_Type*)              DCMI_BASE)
#define OTG1_HS_GLOBAL              ((OTG1_HS_GLOBAL_Type*)    OTG1_HS_GLOBAL_BASE)
#define OTG2_HS_GLOBAL              ((OTG1_HS_GLOBAL_Type*)    OTG2_HS_GLOBAL_BASE)
#define OTG1_HS_HOST                ((OTG1_HS_HOST_Type*)      OTG1_HS_HOST_BASE)
#define OTG2_HS_HOST                ((OTG1_HS_HOST_Type*)      OTG2_HS_HOST_BASE)
#define OTG1_HS_DEVICE              ((OTG1_HS_DEVICE_Type*)    OTG1_HS_DEVICE_BASE)
#define OTG2_HS_DEVICE              ((OTG1_HS_DEVICE_Type*)    OTG2_HS_DEVICE_BASE)
#define OTG1_HS_PWRCLK              ((OTG1_HS_PWRCLK_Type*)    OTG1_HS_PWRCLK_BASE)
#define OTG2_HS_PWRCLK              ((OTG1_HS_PWRCLK_Type*)    OTG2_HS_PWRCLK_BASE)
#define Ethernet_MAC                ((Ethernet_MAC_Type*)      Ethernet_MAC_BASE)
#define DMA1                        ((DMA1_Type*)              DMA1_BASE)
#define DMA2                        ((DMA1_Type*)              DMA2_BASE)
#define HRTIM_Master                ((HRTIM_Master_Type*)      HRTIM_Master_BASE)
#define HRTIM_TIMA                  ((HRTIM_TIMA_Type*)        HRTIM_TIMA_BASE)
#define HRTIM_TIMB                  ((HRTIM_TIMB_Type*)        HRTIM_TIMB_BASE)
#define HRTIM_TIMC                  ((HRTIM_TIMC_Type*)        HRTIM_TIMC_BASE)
#define HRTIM_TIMD                  ((HRTIM_TIMD_Type*)        HRTIM_TIMD_BASE)
#define HRTIM_TIME                  ((HRTIM_TIME_Type*)        HRTIM_TIME_BASE)
#define HRTIM_Common                ((HRTIM_Common_Type*)      HRTIM_Common_BASE)
#define DFSDM                       ((DFSDM_Type*)             DFSDM_BASE)
#define TIM16                       ((TIM16_Type*)             TIM16_BASE)
#define TIM17                       ((TIM17_Type*)             TIM17_BASE)
#define TIM15                       ((TIM15_Type*)             TIM15_BASE)
#define USART1                      ((USART1_Type*)            USART1_BASE)
#define USART2                      ((USART1_Type*)            USART2_BASE)
#define USART3                      ((USART1_Type*)            USART3_BASE)
#define UART4                       ((USART1_Type*)            UART4_BASE)
#define UART5                       ((USART1_Type*)            UART5_BASE)
#define USART6                      ((USART1_Type*)            USART6_BASE)
#define UART7                       ((USART1_Type*)            UART7_BASE)
#define UART8                       ((USART1_Type*)            UART8_BASE)
#define TIM1                        ((TIM1_Type*)              TIM1_BASE)
#define TIM8                        ((TIM1_Type*)              TIM8_BASE)
#define FDCAN1                      ((FDCAN1_Type*)            FDCAN1_BASE)
#define FDCAN2                      ((FDCAN1_Type*)            FDCAN2_BASE)
#define CAN_CCU                     ((CAN_CCU_Type*)           CAN_CCU_BASE)
#define MDIOS                       ((MDIOS_Type*)             MDIOS_BASE)
#define OPAMP                       ((OPAMP_Type*)             OPAMP_BASE)
#define SWPMI                       ((SWPMI_Type*)             SWPMI_BASE)
#define TIM2                        ((TIM2_Type*)              TIM2_BASE)
#define TIM3                        ((TIM2_Type*)              TIM3_BASE)
#define TIM4                        ((TIM2_Type*)              TIM4_BASE)
#define TIM5                        ((TIM2_Type*)              TIM5_BASE)
#define TIM12                       ((TIM2_Type*)              TIM12_BASE)
#define TIM13                       ((TIM2_Type*)              TIM13_BASE)
#define TIM14                       ((TIM2_Type*)              TIM14_BASE)
#define TIM6                        ((TIM6_Type*)              TIM6_BASE)
#define TIM7                        ((TIM6_Type*)              TIM7_BASE)
#define NVIC                        ((NVIC_Type*)              NVIC_BASE)
#define DBGMCU                      ((DBGMCU_Type*)            DBGMCU_BASE)
#define MPU                         ((MPU_Type*)               MPU_BASE)
#define STK                         ((STK_Type*)               STK_BASE)
#define NVIC_STIR                   ((NVIC_STIR_Type*)         NVIC_STIR_BASE)
#define FPU_CPACR                   ((FPU_CPACR_Type*)         FPU_CPACR_BASE)
#define SCB_ACTRL                   ((SCB_ACTRL_Type*)         SCB_ACTRL_BASE)
#define FPU                         ((FPU_Type*)               FPU_BASE)
#define SCB                         ((SCB_Type*)               SCB_BASE)
#define PF                          ((PF_Type*)                PF_BASE)
#define AC                          ((AC_Type*)                AC_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* STM32H750X_H */


/** @} */ /* End of group STM32H750x */

/** @} */ /* End of group  */
